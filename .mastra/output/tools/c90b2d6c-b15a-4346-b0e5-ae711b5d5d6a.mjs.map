{"version":3,"file":"c90b2d6c-b15a-4346-b0e5-ae711b5d5d6a.mjs","sources":["../../../src/mastra/tools/exampleTool.ts"],"sourcesContent":["import { createTool } from \"@mastra/core/tools\";\r\nimport { z } from \"zod\";\r\n\r\n/**\r\n * Example Mastra Tool\r\n *\r\n * MASTRA TOOL GUIDE:\r\n * - Tools are reusable functions that can be used by agents and workflows\r\n * - Use createTool() to define a tool with typed inputs/outputs\r\n * - Tools should be focused on a single task\r\n * - Always include clear descriptions for the tool and its parameters\r\n */\r\n\r\n// Define the input and output schemas using Zod\r\n// This provides type safety and validation\r\nexport const exampleTool = createTool({\r\n  id: \"example-tool\",\r\n\r\n  // Describe what your tool does - this helps agents understand when to use it\r\n  description:\r\n    \"A simple example tool that demonstrates how to create Mastra tools\",\r\n\r\n  // Define what inputs your tool expects\r\n  // Use .describe() to add helpful descriptions for each field\r\n  inputSchema: z.object({\r\n    message: z.string().describe(\"A message to process\"),\r\n    count: z.number().optional().describe(\"Optional number parameter\"),\r\n  }),\r\n\r\n  // Define what your tool will return\r\n  outputSchema: z.object({\r\n    processed: z.string(),\r\n    timestamp: z.string(),\r\n    metadata: z.object({\r\n      characterCount: z.number(),\r\n      wordCount: z.number(),\r\n    }),\r\n  }),\r\n\r\n  // The execute function contains your tool's logic\r\n  // Access mastra for logging and other utilities\r\n  execute: async ({ context, mastra }) => {\r\n    const logger = mastra?.getLogger();\r\n\r\n    // Use logger instead of console.log for proper observability\r\n    logger?.info(\"ðŸ”§ [exampleTool] Executing with:\", context);\r\n\r\n    // In a real tool, you might:\r\n    // 1. Call external APIs\r\n    // 2. Process data\r\n    // 3. Interact with databases\r\n    // 4. Transform information\r\n\r\n    // For this example, we'll do some trivial data processing\r\n    const processedMessage = context.message.toUpperCase();\r\n    const words = context.message.split(\" \").filter((w) => w.length > 0);\r\n\r\n    logger?.info(\"âœ… [exampleTool] Processing complete\");\r\n\r\n    // Return data matching the output schema\r\n    return {\r\n      processed: processedMessage,\r\n      timestamp: new Date().toISOString(),\r\n      metadata: {\r\n        characterCount: context.message.length,\r\n        wordCount: words.length,\r\n      },\r\n    };\r\n  },\r\n});\r\n"],"names":[],"mappings":";;;AAeO,MAAM,cAAc,UAAA,CAAW;AAAA,EACpC,EAAA,EAAI,cAAA;AAAA;AAAA,EAGJ,WAAA,EACE,oEAAA;AAAA;AAAA;AAAA,EAIF,WAAA,EAAa,EAAE,MAAA,CAAO;AAAA,IACpB,OAAA,EAAS,CAAA,CAAE,MAAA,EAAO,CAAE,SAAS,sBAAsB,CAAA;AAAA,IACnD,OAAO,CAAA,CAAE,MAAA,GAAS,QAAA,EAAS,CAAE,SAAS,2BAA2B;AAAA,GAClE,CAAA;AAAA;AAAA,EAGD,YAAA,EAAc,EAAE,MAAA,CAAO;AAAA,IACrB,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA,IACpB,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA,IACpB,QAAA,EAAU,EAAE,MAAA,CAAO;AAAA,MACjB,cAAA,EAAgB,EAAE,MAAA,EAAO;AAAA,MACzB,SAAA,EAAW,EAAE,MAAA;AAAO,KACrB;AAAA,GACF,CAAA;AAAA;AAAA;AAAA,EAID,OAAA,EAAS,OAAO,EAAE,OAAA,EAAS,QAAO,KAAM;AACtC,IAAA,MAAM,MAAA,GAAS,QAAQ,SAAA,EAAU;AAGjC,IAAA,MAAA,EAAQ,IAAA,CAAK,2CAAoC,OAAO,CAAA;AASxD,IAAA,MAAM,gBAAA,GAAmB,OAAA,CAAQ,OAAA,CAAQ,WAAA,EAAY;AACrD,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,CAAE,MAAA,GAAS,CAAC,CAAA;AAEnE,IAAA,MAAA,EAAQ,KAAK,0CAAqC,CAAA;AAGlD,IAAA,OAAO;AAAA,MACL,SAAA,EAAW,gBAAA;AAAA,MACX,SAAA,EAAA,iBAAW,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,MAClC,QAAA,EAAU;AAAA,QACR,cAAA,EAAgB,QAAQ,OAAA,CAAQ,MAAA;AAAA,QAChC,WAAW,KAAA,CAAM;AAAA;AACnB,KACF;AAAA,EACF;AACF,CAAC;;;;"}