{"version":3,"file":"f4f5cbb0-2aaa-438d-8f67-5e4185f2c06d.mjs","sources":["../../../src/mastra/tools/exampleTool.ts"],"sourcesContent":["import { createTool } from \"@mastra/core/tools\";\nimport { z } from \"zod\";\n\n/**\n * Example Mastra Tool\n *\n * MASTRA TOOL GUIDE:\n * - Tools are reusable functions that can be used by agents and workflows\n * - Use createTool() to define a tool with typed inputs/outputs\n * - Tools should be focused on a single task\n * - Always include clear descriptions for the tool and its parameters\n */\n\n// Define the input and output schemas using Zod\n// This provides type safety and validation\nexport const exampleTool = createTool({\n  id: \"example-tool\",\n\n  // Describe what your tool does - this helps agents understand when to use it\n  description:\n    \"A simple example tool that demonstrates how to create Mastra tools\",\n\n  // Define what inputs your tool expects\n  // Use .describe() to add helpful descriptions for each field\n  inputSchema: z.object({\n    message: z.string().describe(\"A message to process\"),\n    count: z.number().optional().describe(\"Optional number parameter\"),\n  }),\n\n  // Define what your tool will return\n  outputSchema: z.object({\n    processed: z.string(),\n    timestamp: z.string(),\n    metadata: z.object({\n      characterCount: z.number(),\n      wordCount: z.number(),\n    }),\n  }),\n\n  // The execute function contains your tool's logic\n  // Access mastra for logging and other utilities\n  execute: async ({ context, mastra }) => {\n    const logger = mastra?.getLogger();\n\n    // Use logger instead of console.log for proper observability\n    logger?.info(\"ðŸ”§ [exampleTool] Executing with:\", context);\n\n    // In a real tool, you might:\n    // 1. Call external APIs\n    // 2. Process data\n    // 3. Interact with databases\n    // 4. Transform information\n\n    // For this example, we'll do some trivial data processing\n    const processedMessage = context.message.toUpperCase();\n    const words = context.message.split(\" \").filter((w) => w.length > 0);\n\n    logger?.info(\"âœ… [exampleTool] Processing complete\");\n\n    // Return data matching the output schema\n    return {\n      processed: processedMessage,\n      timestamp: new Date().toISOString(),\n      metadata: {\n        characterCount: context.message.length,\n        wordCount: words.length,\n      },\n    };\n  },\n});\n"],"names":[],"mappings":";;;AAeO,MAAM,cAAc,UAAA,CAAW;AAAA,EACpC,EAAA,EAAI,cAAA;AAAA;AAAA,EAGJ,WAAA,EACE,oEAAA;AAAA;AAAA;AAAA,EAIF,WAAA,EAAa,EAAE,MAAA,CAAO;AAAA,IACpB,OAAA,EAAS,CAAA,CAAE,MAAA,EAAO,CAAE,SAAS,sBAAsB,CAAA;AAAA,IACnD,OAAO,CAAA,CAAE,MAAA,GAAS,QAAA,EAAS,CAAE,SAAS,2BAA2B;AAAA,GAClE,CAAA;AAAA;AAAA,EAGD,YAAA,EAAc,EAAE,MAAA,CAAO;AAAA,IACrB,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA,IACpB,SAAA,EAAW,EAAE,MAAA,EAAO;AAAA,IACpB,QAAA,EAAU,EAAE,MAAA,CAAO;AAAA,MACjB,cAAA,EAAgB,EAAE,MAAA,EAAO;AAAA,MACzB,SAAA,EAAW,EAAE,MAAA;AAAO,KACrB;AAAA,GACF,CAAA;AAAA;AAAA;AAAA,EAID,OAAA,EAAS,OAAO,EAAE,OAAA,EAAS,QAAO,KAAM;AACtC,IAAA,MAAM,MAAA,GAAS,QAAQ,SAAA,EAAU;AAGjC,IAAA,MAAA,EAAQ,IAAA,CAAK,2CAAoC,OAAO,CAAA;AASxD,IAAA,MAAM,gBAAA,GAAmB,OAAA,CAAQ,OAAA,CAAQ,WAAA,EAAY;AACrD,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA,CAAE,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,CAAE,MAAA,GAAS,CAAC,CAAA;AAEnE,IAAA,MAAA,EAAQ,KAAK,0CAAqC,CAAA;AAGlD,IAAA,OAAO;AAAA,MACL,SAAA,EAAW,gBAAA;AAAA,MACX,SAAA,EAAA,iBAAW,IAAI,IAAA,EAAK,EAAE,WAAA,EAAY;AAAA,MAClC,QAAA,EAAU;AAAA,QACR,cAAA,EAAgB,QAAQ,OAAA,CAAQ,MAAA;AAAA,QAChC,WAAW,KAAA,CAAM;AAAA;AACnB,KACF;AAAA,EACF;AACF,CAAC;;;;"}