import $RefParser from '@apidevtools/json-schema-ref-parser';
import { MastraBase } from '@mastra/core/base';
import { MastraError, ErrorCategory, ErrorDomain } from '@mastra/core/error';
import { createTool } from '@mastra/core/tools';
import { makeCoreTool, isZodType } from '@mastra/core/utils';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';
import { StdioClientTransport, getDefaultEnvironment } from '@modelcontextprotocol/sdk/client/stdio.js';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
import { DEFAULT_REQUEST_TIMEOUT_MSEC } from '@modelcontextprotocol/sdk/shared/protocol.js';
import { ListToolsRequestSchema, CallToolRequestSchema, SetLevelRequestSchema, ListResourcesRequestSchema, ReadResourceRequestSchema, ListResourceTemplatesRequestSchema, SubscribeRequestSchema, UnsubscribeRequestSchema, ListPromptsRequestSchema, PromptSchema, GetPromptRequestSchema, ListResourcesResultSchema, ReadResourceResultSchema, ListResourceTemplatesResultSchema, ListPromptsResultSchema, GetPromptResultSchema, PromptListChangedNotificationSchema, ResourceUpdatedNotificationSchema, ResourceListChangedNotificationSchema, ElicitRequestSchema, CallToolResultSchema, JSONRPCMessageSchema, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { asyncExitHook, gracefulExit } from 'exit-hook';
import { z } from 'zod';
import { convertJsonSchemaToZod } from 'zod-from-json-schema';
import { convertJsonSchemaToZod as convertJsonSchemaToZod$1 } from 'zod-from-json-schema-v3';
import equal from 'fast-deep-equal';
import { v5 } from 'uuid';
import { randomUUID } from 'crypto';
import { MCPServerBase } from '@mastra/core/mcp';
import { RuntimeContext } from '@mastra/core/runtime-context';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';

// src/client/client.ts

// src/client/elicitationActions.ts
var ElicitationClientActions = class {
  client;
  logger;
  /**
   * @internal
   */
  constructor({ client, logger }) {
    this.client = client;
    this.logger = logger;
  }
  /**
   * Sets a handler function for processing elicitation requests from the server.
   *
   * The handler is called when the server needs to collect user input during tool execution.
   * The handler must return a response with action ('accept', 'decline', or 'cancel') and
   * optional content matching the requested schema.
   *
   * @param handler - Callback function to handle elicitation requests
   *
   * @example
   * ```typescript
   * client.elicitation.onRequest(async (request) => {
   *   console.log('Server message:', request.message);
   *   console.log('Requested schema:', request.requestedSchema);
   *
   *   // Collect user input (e.g., via CLI prompt or UI form)
   *   const userInput = await collectUserInput(request.requestedSchema);
   *
   *   return {
   *     action: 'accept',
   *     content: userInput
   *   };
   * });
   * ```
   *
   * @example
   * ```typescript
   * // Declining an elicitation request
   * client.elicitation.onRequest(async (request) => {
   *   if (!shouldAcceptRequest(request)) {
   *     return { action: 'decline' };
   *   }
   *
   *   const input = await getInput();
   *   return { action: 'accept', content: input };
   * });
   * ```
   */
  onRequest(handler) {
    this.client.setElicitationRequestHandler(handler);
  }
};
var PromptClientActions = class {
  client;
  logger;
  /**
   * @internal
   */
  constructor({ client, logger }) {
    this.client = client;
    this.logger = logger;
  }
  /**
   * Retrieves all available prompts from the connected MCP server.
   *
   * Returns an empty array if the server doesn't support prompts (MethodNotFound error).
   *
   * @returns Promise resolving to array of prompts with their metadata
   * @throws {Error} If fetching prompts fails (excluding MethodNotFound)
   *
   * @example
   * ```typescript
   * const prompts = await client.prompts.list();
   * prompts.forEach(prompt => {
   *   console.log(`${prompt.name} (v${prompt.version}): ${prompt.description}`);
   * });
   * ```
   */
  async list() {
    try {
      const response = await this.client.listPrompts();
      if (response && response.prompts && Array.isArray(response.prompts)) {
        return response.prompts.map((prompt) => ({ ...prompt, version: prompt.version || "" }));
      } else {
        this.logger.warn(`Prompts response from server ${this.client.name} did not have expected structure.`, {
          response
        });
        return [];
      }
    } catch (e) {
      if (e.code === ErrorCode.MethodNotFound) {
        return [];
      }
      this.logger.error(`Error getting prompts from server ${this.client.name}`, {
        error: e instanceof Error ? e.message : String(e)
      });
      throw new Error(
        `Failed to fetch prompts from server ${this.client.name}: ${e instanceof Error ? e.stack || e.message : String(e)}`
      );
    }
  }
  /**
   * Retrieves a specific prompt with its messages from the MCP server.
   *
   * Prompts can accept arguments to parameterize the template. The returned messages
   * can be used directly in AI chat completions.
   *
   * @param params - Parameters for the prompt request
   * @param params.name - Name of the prompt to retrieve
   * @param params.args - Optional arguments to populate the prompt template
   * @param params.version - Optional specific version of the prompt to retrieve
   * @returns Promise resolving to the prompt result with messages
   * @throws {Error} If fetching the prompt fails or prompt not found
   *
   * @example
   * ```typescript
   * const prompt = await client.prompts.get({
   *   name: 'code-review',
   *   args: {
   *     language: 'typescript',
   *     code: 'const x = 1;'
   *   },
   *   version: '1.0'
   * });
   *
   * // Use prompt messages in AI completion
   * console.log(prompt.messages);
   * ```
   */
  async get({
    name,
    args,
    version
  }) {
    return this.client.getPrompt({ name, args, version });
  }
  /**
   * Sets a notification handler for when the list of available prompts changes.
   *
   * The handler is called when prompts are added, removed, or modified on the server.
   *
   * @param handler - Callback function invoked when the prompt list changes
   *
   * @example
   * ```typescript
   * await client.prompts.onListChanged(async () => {
   *   console.log('Prompt list changed, re-fetching...');
   *   const prompts = await client.prompts.list();
   *   console.log('Available prompts:', prompts.map(p => p.name));
   * });
   * ```
   */
  async onListChanged(handler) {
    this.client.setPromptListChangedNotificationHandler(handler);
  }
};
var ResourceClientActions = class {
  client;
  logger;
  /**
   * @internal
   */
  constructor({ client, logger }) {
    this.client = client;
    this.logger = logger;
  }
  /**
   * Retrieves all available resources from the connected MCP server.
   *
   * Returns an empty array if the server doesn't support resources (MethodNotFound error).
   *
   * @returns Promise resolving to array of resources
   * @throws {Error} If fetching resources fails (excluding MethodNotFound)
   *
   * @example
   * ```typescript
   * const resources = await client.resources.list();
   * resources.forEach(resource => {
   *   console.log(`${resource.name}: ${resource.uri}`);
   * });
   * ```
   */
  async list() {
    try {
      const response = await this.client.listResources();
      if (response && response.resources && Array.isArray(response.resources)) {
        return response.resources;
      } else {
        this.logger.warn(`Resources response from server ${this.client.name} did not have expected structure.`, {
          response
        });
        return [];
      }
    } catch (e) {
      if (e.code === ErrorCode.MethodNotFound) {
        return [];
      }
      this.logger.error(`Error getting resources from server ${this.client.name}`, {
        error: e instanceof Error ? e.message : String(e)
      });
      throw new Error(
        `Failed to fetch resources from server ${this.client.name}: ${e instanceof Error ? e.stack || e.message : String(e)}`
      );
    }
  }
  /**
   * Retrieves all available resource templates from the connected MCP server.
   *
   * Resource templates are URI templates (RFC 6570) that describe dynamic resources.
   * Returns an empty array if the server doesn't support resource templates.
   *
   * @returns Promise resolving to array of resource templates
   * @throws {Error} If fetching resource templates fails (excluding MethodNotFound)
   *
   * @example
   * ```typescript
   * const templates = await client.resources.templates();
   * templates.forEach(template => {
   *   console.log(`${template.name}: ${template.uriTemplate}`);
   * });
   * ```
   */
  async templates() {
    try {
      const response = await this.client.listResourceTemplates();
      if (response && response.resourceTemplates && Array.isArray(response.resourceTemplates)) {
        return response.resourceTemplates;
      } else {
        this.logger.warn(
          `Resource templates response from server ${this.client.name} did not have expected structure.`,
          { response }
        );
        return [];
      }
    } catch (e) {
      if (e.code === ErrorCode.MethodNotFound) {
        return [];
      }
      this.logger.error(`Error getting resource templates from server ${this.client.name}`, {
        error: e instanceof Error ? e.message : String(e)
      });
      throw new Error(
        `Failed to fetch resource templates from server ${this.client.name}: ${e instanceof Error ? e.stack || e.message : String(e)}`
      );
    }
  }
  /**
   * Reads the content of a specific resource from the MCP server.
   *
   * @param uri - URI of the resource to read (e.g., 'file://path/to/file.txt')
   * @returns Promise resolving to the resource content
   * @throws {Error} If reading the resource fails or resource not found
   *
   * @example
   * ```typescript
   * const result = await client.resources.read('file://data/config.json');
   * console.log(result.contents[0].text); // Resource text content
   * ```
   */
  async read(uri) {
    return this.client.readResource(uri);
  }
  /**
   * Subscribes to updates for a specific resource.
   *
   * After subscribing, you'll receive notifications via the `onUpdated` handler
   * when the resource content changes.
   *
   * @param uri - URI of the resource to subscribe to
   * @returns Promise resolving when subscription is established
   * @throws {Error} If subscription fails
   *
   * @example
   * ```typescript
   * await client.resources.subscribe('file://data/config.json');
   * ```
   */
  async subscribe(uri) {
    return this.client.subscribeResource(uri);
  }
  /**
   * Unsubscribes from updates for a specific resource.
   *
   * Stops receiving notifications for this resource URI.
   *
   * @param uri - URI of the resource to unsubscribe from
   * @returns Promise resolving when unsubscription is complete
   * @throws {Error} If unsubscription fails
   *
   * @example
   * ```typescript
   * await client.resources.unsubscribe('file://data/config.json');
   * ```
   */
  async unsubscribe(uri) {
    return this.client.unsubscribeResource(uri);
  }
  /**
   * Sets a notification handler for when subscribed resources are updated.
   *
   * The handler is called whenever the server sends a resource update notification
   * for any resource you've subscribed to.
   *
   * @param handler - Callback function receiving the updated resource URI
   *
   * @example
   * ```typescript
   * await client.resources.onUpdated(async (params) => {
   *   console.log(`Resource updated: ${params.uri}`);
   *   // Re-fetch the resource
   *   const content = await client.resources.read(params.uri);
   *   console.log('New content:', content);
   * });
   * ```
   */
  async onUpdated(handler) {
    this.client.setResourceUpdatedNotificationHandler(handler);
  }
  /**
   * Sets a notification handler for when the list of available resources changes.
   *
   * The handler is called when resources are added or removed from the server.
   *
   * @param handler - Callback function invoked when the resource list changes
   *
   * @example
   * ```typescript
   * await client.resources.onListChanged(async () => {
   *   console.log('Resource list changed, re-fetching...');
   *   const resources = await client.resources.list();
   *   console.log('Updated resource count:', resources.length);
   * });
   * ```
   */
  async onListChanged(handler) {
    this.client.setResourceListChangedNotificationHandler(handler);
  }
};

// src/client/client.ts
function convertLogLevelToLoggerMethod(level) {
  switch (level) {
    case "debug":
      return "debug";
    case "info":
    case "notice":
      return "info";
    case "warning":
      return "warn";
    case "error":
    case "critical":
    case "alert":
    case "emergency":
      return "error";
    default:
      return "info";
  }
}
var InternalMastraMCPClient = class extends MastraBase {
  name;
  client;
  timeout;
  logHandler;
  enableServerLogs;
  serverConfig;
  transport;
  currentOperationContext = null;
  /** Provides access to resource operations (list, read, subscribe, etc.) */
  resources;
  /** Provides access to prompt operations (list, get, notifications) */
  prompts;
  /** Provides access to elicitation operations (request handling) */
  elicitation;
  /**
   * @internal
   */
  constructor({
    name,
    version = "1.0.0",
    server,
    capabilities = {},
    timeout = DEFAULT_REQUEST_TIMEOUT_MSEC
  }) {
    super({ name: "MastraMCPClient" });
    this.name = name;
    this.timeout = timeout;
    this.logHandler = server.logger;
    this.enableServerLogs = server.enableServerLogs ?? true;
    this.serverConfig = server;
    const clientCapabilities = { ...capabilities, elicitation: {} };
    this.client = new Client(
      {
        name,
        version
      },
      {
        capabilities: clientCapabilities
      }
    );
    this.setupLogging();
    this.resources = new ResourceClientActions({ client: this, logger: this.logger });
    this.prompts = new PromptClientActions({ client: this, logger: this.logger });
    this.elicitation = new ElicitationClientActions({ client: this, logger: this.logger });
  }
  /**
   * Log a message at the specified level
   * @param level Log level
   * @param message Log message
   * @param details Optional additional details
   */
  log(level, message, details) {
    const loggerMethod = convertLogLevelToLoggerMethod(level);
    const msg = `[${this.name}] ${message}`;
    this.logger[loggerMethod](msg, details);
    if (this.logHandler) {
      this.logHandler({
        level,
        message: msg,
        timestamp: /* @__PURE__ */ new Date(),
        serverName: this.name,
        details,
        runtimeContext: this.currentOperationContext
      });
    }
  }
  setupLogging() {
    if (this.enableServerLogs) {
      this.client.setNotificationHandler(
        z.object({
          method: z.literal("notifications/message"),
          params: z.object({
            level: z.string()
          }).passthrough()
        }),
        (notification) => {
          const { level, ...params } = notification.params;
          this.log(level, "[MCP SERVER LOG]", params);
        }
      );
    }
  }
  async connectStdio(command) {
    this.log("debug", `Using Stdio transport for command: ${command}`);
    try {
      this.transport = new StdioClientTransport({
        command,
        args: this.serverConfig.args,
        env: { ...getDefaultEnvironment(), ...this.serverConfig.env || {} }
      });
      await this.client.connect(this.transport, { timeout: this.serverConfig.timeout ?? this.timeout });
      this.log("debug", `Successfully connected to MCP server via Stdio`);
    } catch (e) {
      this.log("error", e instanceof Error ? e.stack || e.message : JSON.stringify(e));
      throw e;
    }
  }
  async connectHttp(url) {
    const { requestInit, eventSourceInit, authProvider } = this.serverConfig;
    this.log("debug", `Attempting to connect to URL: ${url}`);
    let shouldTrySSE = url.pathname.endsWith(`/sse`);
    if (!shouldTrySSE) {
      try {
        this.log("debug", "Trying Streamable HTTP transport...");
        const streamableTransport = new StreamableHTTPClientTransport(url, {
          requestInit,
          reconnectionOptions: this.serverConfig.reconnectionOptions,
          authProvider
        });
        await this.client.connect(streamableTransport, {
          timeout: (
            // this is hardcoded to 3s because the long default timeout would be extremely slow for sse backwards compat (60s)
            3e3
          )
        });
        this.transport = streamableTransport;
        this.log("debug", "Successfully connected using Streamable HTTP transport.");
      } catch (error) {
        this.log("debug", `Streamable HTTP transport failed: ${error}`);
        shouldTrySSE = true;
      }
    }
    if (shouldTrySSE) {
      this.log("debug", "Falling back to deprecated HTTP+SSE transport...");
      try {
        const sseTransport = new SSEClientTransport(url, { requestInit, eventSourceInit, authProvider });
        await this.client.connect(sseTransport, { timeout: this.serverConfig.timeout ?? this.timeout });
        this.transport = sseTransport;
        this.log("debug", "Successfully connected using deprecated HTTP+SSE transport.");
      } catch (sseError) {
        this.log(
          "error",
          `Failed to connect with SSE transport after failing to connect to Streamable HTTP transport first. SSE error: ${sseError}`
        );
        throw new Error("Could not connect to server with any available HTTP transport");
      }
    }
  }
  isConnected = null;
  /**
   * Connects to the MCP server using the configured transport.
   *
   * Automatically detects transport type based on configuration (stdio vs HTTP).
   * Safe to call multiple times - returns existing connection if already connected.
   *
   * @returns Promise resolving to true when connected
   * @throws {MastraError} If connection fails
   *
   * @internal
   */
  async connect() {
    if (await this.isConnected) {
      return true;
    }
    this.isConnected = new Promise(async (resolve, reject) => {
      try {
        const { command, url } = this.serverConfig;
        if (command) {
          await this.connectStdio(command);
        } else if (url) {
          await this.connectHttp(url);
        } else {
          throw new Error("Server configuration must include either a command or a url.");
        }
        resolve(true);
        const originalOnClose = this.client.onclose;
        this.client.onclose = () => {
          this.log("debug", `MCP server connection closed`);
          this.isConnected = null;
          if (typeof originalOnClose === "function") {
            originalOnClose();
          }
        };
      } catch (e) {
        this.isConnected = null;
        reject(e);
      }
    });
    asyncExitHook(
      async () => {
        this.log("debug", `Disconnecting MCP server during exit`);
        await this.disconnect();
      },
      { wait: 5e3 }
    );
    process.on("SIGTERM", () => gracefulExit());
    this.log("debug", `Successfully connected to MCP server`);
    return this.isConnected;
  }
  /**
   * Gets the current session ID if using Streamable HTTP transport.
   *
   * Returns undefined if not connected or not using Streamable HTTP transport.
   *
   * @returns Session ID string or undefined
   *
   * @internal
   */
  get sessionId() {
    if (this.transport instanceof StreamableHTTPClientTransport) {
      return this.transport.sessionId;
    }
    return void 0;
  }
  async disconnect() {
    if (!this.transport) {
      this.log("debug", "Disconnect called but no transport was connected.");
      return;
    }
    this.log("debug", `Disconnecting from MCP server`);
    try {
      await this.transport.close();
      this.log("debug", "Successfully disconnected from MCP server");
    } catch (e) {
      this.log("error", "Error during MCP server disconnect", {
        error: e instanceof Error ? e.stack : JSON.stringify(e, null, 2)
      });
      throw e;
    } finally {
      this.transport = void 0;
      this.isConnected = Promise.resolve(false);
    }
  }
  async listResources() {
    this.log("debug", `Requesting resources from MCP server`);
    return await this.client.request({ method: "resources/list" }, ListResourcesResultSchema, {
      timeout: this.timeout
    });
  }
  async readResource(uri) {
    this.log("debug", `Reading resource from MCP server: ${uri}`);
    return await this.client.request({ method: "resources/read", params: { uri } }, ReadResourceResultSchema, {
      timeout: this.timeout
    });
  }
  async subscribeResource(uri) {
    this.log("debug", `Subscribing to resource on MCP server: ${uri}`);
    return await this.client.request({ method: "resources/subscribe", params: { uri } }, z.object({}), {
      timeout: this.timeout
    });
  }
  async unsubscribeResource(uri) {
    this.log("debug", `Unsubscribing from resource on MCP server: ${uri}`);
    return await this.client.request({ method: "resources/unsubscribe", params: { uri } }, z.object({}), {
      timeout: this.timeout
    });
  }
  async listResourceTemplates() {
    this.log("debug", `Requesting resource templates from MCP server`);
    return await this.client.request({ method: "resources/templates/list" }, ListResourceTemplatesResultSchema, {
      timeout: this.timeout
    });
  }
  /**
   * Fetch the list of available prompts from the MCP server.
   */
  async listPrompts() {
    this.log("debug", `Requesting prompts from MCP server`);
    return await this.client.request({ method: "prompts/list" }, ListPromptsResultSchema, {
      timeout: this.timeout
    });
  }
  /**
   * Get a prompt and its dynamic messages from the server.
   * @param name The prompt name
   * @param args Arguments for the prompt
   * @param version (optional) The prompt version to retrieve
   */
  async getPrompt({
    name,
    args,
    version
  }) {
    this.log("debug", `Requesting prompt from MCP server: ${name}`);
    return await this.client.request(
      { method: "prompts/get", params: { name, arguments: args, version } },
      GetPromptResultSchema,
      { timeout: this.timeout }
    );
  }
  /**
   * Register a handler to be called when the prompt list changes on the server.
   * Use this to refresh cached prompt lists in the client/UI if needed.
   */
  setPromptListChangedNotificationHandler(handler) {
    this.log("debug", "Setting prompt list changed notification handler");
    this.client.setNotificationHandler(PromptListChangedNotificationSchema, () => {
      handler();
    });
  }
  setResourceUpdatedNotificationHandler(handler) {
    this.log("debug", "Setting resource updated notification handler");
    this.client.setNotificationHandler(ResourceUpdatedNotificationSchema, (notification) => {
      handler(notification.params);
    });
  }
  setResourceListChangedNotificationHandler(handler) {
    this.log("debug", "Setting resource list changed notification handler");
    this.client.setNotificationHandler(ResourceListChangedNotificationSchema, () => {
      handler();
    });
  }
  setElicitationRequestHandler(handler) {
    this.log("debug", "Setting elicitation request handler");
    this.client.setRequestHandler(ElicitRequestSchema, async (request) => {
      this.log("debug", `Received elicitation request: ${request.params.message}`);
      return handler(request.params);
    });
  }
  async convertInputSchema(inputSchema) {
    if (isZodType(inputSchema)) {
      return inputSchema;
    }
    try {
      await $RefParser.dereference(inputSchema);
      const jsonSchemaToConvert = "jsonSchema" in inputSchema ? inputSchema.jsonSchema : inputSchema;
      if ("toJSONSchema" in z) {
        return convertJsonSchemaToZod(jsonSchemaToConvert);
      } else {
        return convertJsonSchemaToZod$1(jsonSchemaToConvert);
      }
    } catch (error) {
      let errorDetails;
      if (error instanceof Error) {
        errorDetails = error.stack;
      } else {
        try {
          errorDetails = JSON.stringify(error);
        } catch {
          errorDetails = String(error);
        }
      }
      this.log("error", "Failed to convert JSON schema to Zod schema using zodFromJsonSchema", {
        error: errorDetails,
        originalJsonSchema: inputSchema
      });
      throw new MastraError({
        id: "MCP_TOOL_INPUT_SCHEMA_CONVERSION_FAILED",
        domain: ErrorDomain.MCP,
        category: ErrorCategory.USER,
        details: { error: errorDetails ?? "Unknown error" }
      });
    }
  }
  async convertOutputSchema(outputSchema) {
    if (!outputSchema) return;
    if (isZodType(outputSchema)) {
      return outputSchema;
    }
    try {
      await $RefParser.dereference(outputSchema);
      const jsonSchemaToConvert = "jsonSchema" in outputSchema ? outputSchema.jsonSchema : outputSchema;
      if ("toJSONSchema" in z) {
        return convertJsonSchemaToZod(jsonSchemaToConvert);
      } else {
        return convertJsonSchemaToZod$1(jsonSchemaToConvert);
      }
    } catch (error) {
      let errorDetails;
      if (error instanceof Error) {
        errorDetails = error.stack;
      } else {
        try {
          errorDetails = JSON.stringify(error);
        } catch {
          errorDetails = String(error);
        }
      }
      this.log("error", "Failed to convert JSON schema to Zod schema using zodFromJsonSchema", {
        error: errorDetails,
        originalJsonSchema: outputSchema
      });
      throw new MastraError({
        id: "MCP_TOOL_OUTPUT_SCHEMA_CONVERSION_FAILED",
        domain: ErrorDomain.MCP,
        category: ErrorCategory.USER,
        details: { error: errorDetails ?? "Unknown error" }
      });
    }
  }
  async tools() {
    this.log("debug", `Requesting tools from MCP server`);
    const { tools } = await this.client.listTools({ timeout: this.timeout });
    const toolsRes = {};
    for (const tool of tools) {
      this.log("debug", `Processing tool: ${tool.name}`);
      try {
        const mastraTool = createTool({
          id: `${this.name}_${tool.name}`,
          description: tool.description || "",
          inputSchema: await this.convertInputSchema(tool.inputSchema),
          outputSchema: await this.convertOutputSchema(tool.outputSchema),
          execute: async ({ context, runtimeContext }) => {
            const previousContext = this.currentOperationContext;
            this.currentOperationContext = runtimeContext || null;
            try {
              this.log("debug", `Executing tool: ${tool.name}`, { toolArgs: context });
              const res = await this.client.callTool(
                {
                  name: tool.name,
                  arguments: context
                },
                CallToolResultSchema,
                {
                  timeout: this.timeout
                }
              );
              this.log("debug", `Tool executed successfully: ${tool.name}`);
              return res;
            } catch (e) {
              this.log("error", `Error calling tool: ${tool.name}`, {
                error: e instanceof Error ? e.stack : JSON.stringify(e, null, 2),
                toolArgs: context
              });
              throw e;
            } finally {
              this.currentOperationContext = previousContext;
            }
          }
        });
        if (tool.name) {
          toolsRes[tool.name] = mastraTool;
        }
      } catch (toolCreationError) {
        this.log("error", `Failed to create Mastra tool wrapper for MCP tool: ${tool.name}`, {
          error: toolCreationError instanceof Error ? toolCreationError.stack : String(toolCreationError),
          mcpToolDefinition: tool
        });
      }
    }
    return toolsRes;
  }
};
var MastraMCPClient = class extends InternalMastraMCPClient {
  constructor(args) {
    super(args);
    this.logger.warn(
      "[DEPRECATION] MastraMCPClient is deprecated and will be removed in a future release. Please use MCPClient instead."
    );
  }
};
var mcpClientInstances = /* @__PURE__ */ new Map();
var MCPClient = class extends MastraBase {
  serverConfigs = {};
  id;
  defaultTimeout;
  mcpClientsById = /* @__PURE__ */ new Map();
  disconnectPromise = null;
  /**
   * Creates a new MCPClient instance for managing MCP server connections.
   *
   * The client automatically manages connection lifecycle and prevents memory leaks by
   * caching instances with identical configurations.
   *
   * @param args - Configuration options
   * @param args.id - Optional unique identifier to allow multiple instances with same config
   * @param args.servers - Map of server names to server configurations
   * @param args.timeout - Optional global timeout in milliseconds (default: 60000)
   *
   * @throws {Error} If multiple instances with identical config are created without an ID
   *
   * @example
   * ```typescript
   * const mcp = new MCPClient({
   *   servers: {
   *     weatherServer: {
   *       url: new URL('http://localhost:8080/sse'),
   *       requestInit: {
   *         headers: { Authorization: 'Bearer token' }
   *       }
   *     }
   *   },
   *   timeout: 30000
   * });
   * ```
   */
  constructor(args) {
    super({ name: "MCPClient" });
    this.defaultTimeout = args.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
    this.serverConfigs = args.servers;
    this.id = args.id ?? this.makeId();
    if (args.id) {
      this.id = args.id;
      const cached = mcpClientInstances.get(this.id);
      if (cached && !equal(cached.serverConfigs, args.servers)) {
        const existingInstance2 = mcpClientInstances.get(this.id);
        if (existingInstance2) {
          void existingInstance2.disconnect();
          mcpClientInstances.delete(this.id);
        }
      }
    } else {
      this.id = this.makeId();
    }
    const existingInstance = mcpClientInstances.get(this.id);
    if (existingInstance) {
      if (!args.id) {
        throw new Error(`MCPClient was initialized multiple times with the same configuration options.

This error is intended to prevent memory leaks.

To fix this you have three different options:
1. If you need multiple MCPClient class instances with identical server configurations, set an id when configuring: new MCPClient({ id: "my-unique-id" })
2. Call "await client.disconnect()" after you're done using the client and before you recreate another instance with the same options. If the identical MCPClient instance is already closed at the time of re-creating it, you will not see this error.
3. If you only need one instance of MCPClient in your app, refactor your code so it's only created one time (ex. move it out of a loop into a higher scope code block)
`);
      }
      return existingInstance;
    }
    mcpClientInstances.set(this.id, this);
    this.addToInstanceCache();
    return this;
  }
  /**
   * Provides access to elicitation-related operations for interactive user input collection.
   *
   * Elicitation allows MCP servers to request structured information from users during tool execution.
   *
   * @example
   * ```typescript
   * // Set up handler for elicitation requests from a server
   * await mcp.elicitation.onRequest('serverName', async (request) => {
   *   console.log(`Server requests: ${request.message}`);
   *   console.log('Schema:', request.requestedSchema);
   *
   *   // Collect user input and return response
   *   return {
   *     action: 'accept',
   *     content: { name: 'John Doe', email: 'john@example.com' }
   *   };
   * });
   * ```
   */
  get elicitation() {
    this.addToInstanceCache();
    return {
      /**
       * Sets up a handler function for elicitation requests from a specific server.
       *
       * The handler receives requests for user input and must return a response with
       * action ('accept', 'decline', or 'cancel') and optional content.
       *
       * @param serverName - Name of the server to handle elicitation requests for
       * @param handler - Function to handle elicitation requests
       * @throws {MastraError} If setting up the handler fails
       *
       * @example
       * ```typescript
       * await mcp.elicitation.onRequest('weatherServer', async (request) => {
       *   // Prompt user for input
       *   const userInput = await promptUser(request.requestedSchema);
       *   return { action: 'accept', content: userInput };
       * });
       * ```
       */
      onRequest: async (serverName, handler) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.elicitation.onRequest(handler);
        } catch (err) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_ON_REQUEST_ELICITATION_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName
              }
            },
            err
          );
        }
      }
    };
  }
  /**
   * Provides access to resource-related operations across all configured servers.
   *
   * Resources represent data exposed by MCP servers (files, database records, API responses, etc.).
   *
   * @example
   * ```typescript
   * // List all resources from all servers
   * const allResources = await mcp.resources.list();
   * Object.entries(allResources).forEach(([serverName, resources]) => {
   *   console.log(`${serverName}: ${resources.length} resources`);
   * });
   *
   * // Read a specific resource
   * const content = await mcp.resources.read('weatherServer', 'file://data.json');
   *
   * // Subscribe to resource updates
   * await mcp.resources.subscribe('weatherServer', 'file://data.json');
   * await mcp.resources.onUpdated('weatherServer', async (params) => {
   *   console.log(`Resource updated: ${params.uri}`);
   * });
   * ```
   */
  get resources() {
    this.addToInstanceCache();
    return {
      /**
       * Lists all available resources from all configured servers.
       *
       * Returns a map of server names to their resource arrays. Errors for individual
       * servers are logged but don't throw - failed servers return empty arrays.
       *
       * @returns Promise resolving to object mapping server names to resource arrays
       *
       * @example
       * ```typescript
       * const resources = await mcp.resources.list();
       * console.log(resources.weatherServer); // Array of resources
       * ```
       */
      list: async () => {
        const allResources = {};
        for (const serverName of Object.keys(this.serverConfigs)) {
          try {
            const internalClient = await this.getConnectedClientForServer(serverName);
            allResources[serverName] = await internalClient.resources.list();
          } catch (error) {
            const mastraError = new MastraError(
              {
                id: "MCP_CLIENT_LIST_RESOURCES_FAILED",
                domain: ErrorDomain.MCP,
                category: ErrorCategory.THIRD_PARTY,
                details: {
                  serverName
                }
              },
              error
            );
            this.logger.trackException(mastraError);
            this.logger.error("Failed to list resources from server:", { error: mastraError.toString() });
          }
        }
        return allResources;
      },
      /**
       * Lists all available resource templates from all configured servers.
       *
       * Resource templates are URI templates (RFC 6570) describing dynamic resources.
       * Errors for individual servers are logged but don't throw.
       *
       * @returns Promise resolving to object mapping server names to template arrays
       *
       * @example
       * ```typescript
       * const templates = await mcp.resources.templates();
       * console.log(templates.weatherServer); // Array of resource templates
       * ```
       */
      templates: async () => {
        const allTemplates = {};
        for (const serverName of Object.keys(this.serverConfigs)) {
          try {
            const internalClient = await this.getConnectedClientForServer(serverName);
            allTemplates[serverName] = await internalClient.resources.templates();
          } catch (error) {
            const mastraError = new MastraError(
              {
                id: "MCP_CLIENT_LIST_RESOURCE_TEMPLATES_FAILED",
                domain: ErrorDomain.MCP,
                category: ErrorCategory.THIRD_PARTY,
                details: {
                  serverName
                }
              },
              error
            );
            this.logger.trackException(mastraError);
            this.logger.error("Failed to list resource templates from server:", { error: mastraError.toString() });
          }
        }
        return allTemplates;
      },
      /**
       * Reads the content of a specific resource from a server.
       *
       * @param serverName - Name of the server to read from
       * @param uri - URI of the resource to read
       * @returns Promise resolving to the resource content
       * @throws {MastraError} If reading the resource fails
       *
       * @example
       * ```typescript
       * const content = await mcp.resources.read('weatherServer', 'file://config.json');
       * console.log(content.contents[0].text);
       * ```
       */
      read: async (serverName, uri) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.resources.read(uri);
        } catch (error) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_READ_RESOURCE_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName,
                uri
              }
            },
            error
          );
        }
      },
      /**
       * Subscribes to updates for a specific resource on a server.
       *
       * @param serverName - Name of the server
       * @param uri - URI of the resource to subscribe to
       * @returns Promise resolving when subscription is established
       * @throws {MastraError} If subscription fails
       *
       * @example
       * ```typescript
       * await mcp.resources.subscribe('weatherServer', 'file://config.json');
       * ```
       */
      subscribe: async (serverName, uri) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.resources.subscribe(uri);
        } catch (error) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_SUBSCRIBE_RESOURCE_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName,
                uri
              }
            },
            error
          );
        }
      },
      /**
       * Unsubscribes from updates for a specific resource on a server.
       *
       * @param serverName - Name of the server
       * @param uri - URI of the resource to unsubscribe from
       * @returns Promise resolving when unsubscription is complete
       * @throws {MastraError} If unsubscription fails
       *
       * @example
       * ```typescript
       * await mcp.resources.unsubscribe('weatherServer', 'file://config.json');
       * ```
       */
      unsubscribe: async (serverName, uri) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.resources.unsubscribe(uri);
        } catch (err) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_UNSUBSCRIBE_RESOURCE_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName,
                uri
              }
            },
            err
          );
        }
      },
      /**
       * Sets a notification handler for when subscribed resources are updated on a server.
       *
       * @param serverName - Name of the server to monitor
       * @param handler - Callback function receiving the updated resource URI
       * @returns Promise resolving when handler is registered
       * @throws {MastraError} If setting up the handler fails
       *
       * @example
       * ```typescript
       * await mcp.resources.onUpdated('weatherServer', async (params) => {
       *   console.log(`Resource updated: ${params.uri}`);
       *   const content = await mcp.resources.read('weatherServer', params.uri);
       * });
       * ```
       */
      onUpdated: async (serverName, handler) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.resources.onUpdated(handler);
        } catch (err) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_ON_UPDATED_RESOURCE_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName
              }
            },
            err
          );
        }
      },
      /**
       * Sets a notification handler for when the resource list changes on a server.
       *
       * @param serverName - Name of the server to monitor
       * @param handler - Callback function invoked when resources are added/removed
       * @returns Promise resolving when handler is registered
       * @throws {MastraError} If setting up the handler fails
       *
       * @example
       * ```typescript
       * await mcp.resources.onListChanged('weatherServer', async () => {
       *   console.log('Resource list changed, re-fetching...');
       *   const resources = await mcp.resources.list();
       * });
       * ```
       */
      onListChanged: async (serverName, handler) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.resources.onListChanged(handler);
        } catch (err) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_ON_LIST_CHANGED_RESOURCE_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName
              }
            },
            err
          );
        }
      }
    };
  }
  /**
   * Provides access to prompt-related operations across all configured servers.
   *
   * Prompts are reusable message templates exposed by MCP servers that can be parameterized
   * and used for AI interactions.
   *
   * @example
   * ```typescript
   * // List all prompts from all servers
   * const allPrompts = await mcp.prompts.list();
   * Object.entries(allPrompts).forEach(([serverName, prompts]) => {
   *   console.log(`${serverName}: ${prompts.map(p => p.name).join(', ')}`);
   * });
   *
   * // Get a specific prompt with arguments
   * const prompt = await mcp.prompts.get({
   *   serverName: 'weatherServer',
   *   name: 'forecast-template',
   *   args: { city: 'London', days: 7 }
   * });
   * ```
   */
  get prompts() {
    this.addToInstanceCache();
    return {
      /**
       * Lists all available prompts from all configured servers.
       *
       * Returns a map of server names to their prompt arrays. Errors for individual
       * servers are logged but don't throw - failed servers return empty arrays.
       *
       * @returns Promise resolving to object mapping server names to prompt arrays
       *
       * @example
       * ```typescript
       * const prompts = await mcp.prompts.list();
       * console.log(prompts.weatherServer); // Array of prompts
       * ```
       */
      list: async () => {
        const allPrompts = {};
        for (const serverName of Object.keys(this.serverConfigs)) {
          try {
            const internalClient = await this.getConnectedClientForServer(serverName);
            allPrompts[serverName] = await internalClient.prompts.list();
          } catch (error) {
            const mastraError = new MastraError(
              {
                id: "MCP_CLIENT_LIST_PROMPTS_FAILED",
                domain: ErrorDomain.MCP,
                category: ErrorCategory.THIRD_PARTY,
                details: {
                  serverName
                }
              },
              error
            );
            this.logger.trackException(mastraError);
            this.logger.error("Failed to list prompts from server:", { error: mastraError.toString() });
          }
        }
        return allPrompts;
      },
      /**
       * Retrieves a specific prompt with its messages from a server.
       *
       * @param params - Parameters for the prompt request
       * @param params.serverName - Name of the server to retrieve from
       * @param params.name - Name of the prompt to retrieve
       * @param params.args - Optional arguments to populate the prompt template
       * @param params.version - Optional specific version of the prompt
       * @returns Promise resolving to the prompt result with messages
       * @throws {MastraError} If fetching the prompt fails
       *
       * @example
       * ```typescript
       * const prompt = await mcp.prompts.get({
       *   serverName: 'weatherServer',
       *   name: 'forecast',
       *   args: { city: 'London' },
       *   version: '1.0'
       * });
       * console.log(prompt.messages);
       * ```
       */
      get: async ({
        serverName,
        name,
        args,
        version
      }) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.prompts.get({ name, args, version });
        } catch (error) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_GET_PROMPT_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName,
                name
              }
            },
            error
          );
        }
      },
      /**
       * Sets a notification handler for when the prompt list changes on a server.
       *
       * @param serverName - Name of the server to monitor
       * @param handler - Callback function invoked when prompts are added/removed/modified
       * @returns Promise resolving when handler is registered
       * @throws {MastraError} If setting up the handler fails
       *
       * @example
       * ```typescript
       * await mcp.prompts.onListChanged('weatherServer', async () => {
       *   console.log('Prompt list changed, re-fetching...');
       *   const prompts = await mcp.prompts.list();
       * });
       * ```
       */
      onListChanged: async (serverName, handler) => {
        try {
          const internalClient = await this.getConnectedClientForServer(serverName);
          return internalClient.prompts.onListChanged(handler);
        } catch (error) {
          throw new MastraError(
            {
              id: "MCP_CLIENT_ON_LIST_CHANGED_PROMPT_FAILED",
              domain: ErrorDomain.MCP,
              category: ErrorCategory.THIRD_PARTY,
              details: {
                serverName
              }
            },
            error
          );
        }
      }
    };
  }
  addToInstanceCache() {
    if (!mcpClientInstances.has(this.id)) {
      mcpClientInstances.set(this.id, this);
    }
  }
  makeId() {
    const text = JSON.stringify(this.serverConfigs).normalize("NFKC");
    const idNamespace = v5(`MCPClient`, v5.DNS);
    return v5(text, idNamespace);
  }
  /**
   * Disconnects from all MCP servers and cleans up resources.
   *
   * This method gracefully closes all server connections and clears internal caches.
   * Safe to call multiple times - subsequent calls will wait for the first disconnect to complete.
   *
   * @example
   * ```typescript
   * // Cleanup on application shutdown
   * process.on('SIGTERM', async () => {
   *   await mcp.disconnect();
   *   process.exit(0);
   * });
   * ```
   */
  async disconnect() {
    if (this.disconnectPromise) {
      return this.disconnectPromise;
    }
    this.disconnectPromise = (async () => {
      try {
        mcpClientInstances.delete(this.id);
        await Promise.all(Array.from(this.mcpClientsById.values()).map((client) => client.disconnect()));
        this.mcpClientsById.clear();
      } finally {
        this.disconnectPromise = null;
      }
    })();
    return this.disconnectPromise;
  }
  /**
   * Retrieves all tools from all configured servers with namespaced names.
   *
   * Tool names are namespaced as `serverName_toolName` to prevent conflicts between servers.
   * This method is intended to be passed directly to an Agent definition.
   *
   * @returns Object mapping namespaced tool names to tool implementations
   * @throws {MastraError} If retrieving tools fails
   *
   * @example
   * ```typescript
   * const agent = new Agent({
   *   name: 'Multi-tool Agent',
   *   instructions: 'You have access to weather and stock tools.',
   *   model: openai('gpt-4'),
   *   tools: await mcp.getTools(), // weather_getWeather, stockPrice_getPrice
   * });
   * ```
   */
  async getTools() {
    this.addToInstanceCache();
    const connectedTools = {};
    try {
      await this.eachClientTools(async ({ serverName, tools }) => {
        for (const [toolName, toolConfig] of Object.entries(tools)) {
          connectedTools[`${serverName}_${toolName}`] = toolConfig;
        }
      });
    } catch (error) {
      throw new MastraError(
        {
          id: "MCP_CLIENT_GET_TOOLS_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY
        },
        error
      );
    }
    return connectedTools;
  }
  /**
   * Returns toolsets organized by server name for dynamic tool injection.
   *
   * Unlike getTools(), this returns tools grouped by server without namespacing.
   * This is intended to be passed dynamically to the generate() or stream() method.
   *
   * @returns Object mapping server names to their tool collections
   * @throws {MastraError} If retrieving toolsets fails
   *
   * @example
   * ```typescript
   * const agent = new Agent({
   *   name: 'Dynamic Agent',
   *   instructions: 'You can use tools dynamically.',
   *   model: openai('gpt-4'),
   * });
   *
   * const response = await agent.stream(prompt, {
   *   toolsets: await mcp.getToolsets(), // { weather: {...}, stockPrice: {...} }
   * });
   * ```
   */
  async getToolsets() {
    this.addToInstanceCache();
    const connectedToolsets = {};
    try {
      await this.eachClientTools(async ({ serverName, tools }) => {
        if (tools) {
          connectedToolsets[serverName] = tools;
        }
      });
    } catch (error) {
      throw new MastraError(
        {
          id: "MCP_CLIENT_GET_TOOLSETS_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY
        },
        error
      );
    }
    return connectedToolsets;
  }
  /**
   * @deprecated all resource actions have been moved to the this.resources object. Use this.resources.list() instead.
   */
  async getResources() {
    return this.resources.list();
  }
  /**
   * Gets current session IDs for all connected MCP clients using Streamable HTTP transport.
   *
   * Returns an object mapping server names to their session IDs. Only includes servers
   * that are currently connected via Streamable HTTP transport.
   *
   * @returns Object mapping server names to session IDs
   *
   * @example
   * ```typescript
   * const sessions = mcp.sessionIds;
   * console.log(sessions);
   * // { weatherServer: 'abc-123', stockServer: 'def-456' }
   * ```
   */
  get sessionIds() {
    const sessionIds = {};
    for (const [serverName, client] of this.mcpClientsById.entries()) {
      if (client.sessionId) {
        sessionIds[serverName] = client.sessionId;
      }
    }
    return sessionIds;
  }
  async getConnectedClient(name, config) {
    if (this.disconnectPromise) {
      await this.disconnectPromise;
    }
    const exists = this.mcpClientsById.has(name);
    const existingClient = this.mcpClientsById.get(name);
    this.logger.debug(`getConnectedClient ${name} exists: ${exists}`);
    if (exists) {
      if (!existingClient) {
        throw new Error(`Client ${name} exists but is undefined`);
      }
      await existingClient.connect();
      return existingClient;
    }
    this.logger.debug(`Connecting to ${name} MCP server`);
    const mcpClient = new InternalMastraMCPClient({
      name,
      server: config,
      timeout: config.timeout ?? this.defaultTimeout
    });
    mcpClient.__setLogger(this.logger);
    this.mcpClientsById.set(name, mcpClient);
    try {
      await mcpClient.connect();
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_CLIENT_CONNECT_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY,
          text: `Failed to connect to MCP server ${name}: ${e instanceof Error ? e.stack || e.message : String(e)}`,
          details: {
            name
          }
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("MCPClient errored connecting to MCP server:", { error: mastraError.toString() });
      this.mcpClientsById.delete(name);
      throw mastraError;
    }
    this.logger.debug(`Connected to ${name} MCP server`);
    return mcpClient;
  }
  async getConnectedClientForServer(serverName) {
    const serverConfig = this.serverConfigs[serverName];
    if (!serverConfig) {
      throw new Error(`Server configuration not found for name: ${serverName}`);
    }
    return this.getConnectedClient(serverName, serverConfig);
  }
  async eachClientTools(cb) {
    await Promise.all(
      Object.entries(this.serverConfigs).map(async ([serverName, serverConfig]) => {
        const client = await this.getConnectedClient(serverName, serverConfig);
        const tools = await client.tools();
        await cb({ serverName, tools, client });
      })
    );
  }
};
var MCPConfiguration = class extends MCPClient {
  /**
   * @deprecated Use MCPClient constructor instead
   */
  constructor(args) {
    super(args);
    this.logger.warn(
      `MCPConfiguration has been renamed to MCPClient and MCPConfiguration is deprecated. The API is identical but the MCPConfiguration export will be removed in the future. Update your imports now to prevent future errors.`
    );
  }
};

// ../../node_modules/.pnpm/hono@4.9.7/node_modules/hono/dist/utils/stream.js
var StreamingApi = class {
  writer;
  encoder;
  writable;
  abortSubscribers = [];
  responseReadable;
  aborted = false;
  closed = false;
  constructor(writable, _readable) {
    this.writable = writable;
    this.writer = writable.getWriter();
    this.encoder = new TextEncoder();
    const reader = _readable.getReader();
    this.abortSubscribers.push(async () => {
      await reader.cancel();
    });
    this.responseReadable = new ReadableStream({
      async pull(controller) {
        const { done, value } = await reader.read();
        done ? controller.close() : controller.enqueue(value);
      },
      cancel: () => {
        this.abort();
      }
    });
  }
  async write(input) {
    try {
      if (typeof input === "string") {
        input = this.encoder.encode(input);
      }
      await this.writer.write(input);
    } catch {
    }
    return this;
  }
  async writeln(input) {
    await this.write(input + "\n");
    return this;
  }
  sleep(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  async close() {
    try {
      await this.writer.close();
    } catch {
    }
    this.closed = true;
  }
  async pipe(body) {
    this.writer.releaseLock();
    await body.pipeTo(this.writable, { preventClose: true });
    this.writer = this.writable.getWriter();
  }
  onAbort(listener) {
    this.abortSubscribers.push(listener);
  }
  abort() {
    if (!this.aborted) {
      this.aborted = true;
      this.abortSubscribers.forEach((subscriber) => subscriber());
    }
  }
};

// ../../node_modules/.pnpm/hono@4.9.7/node_modules/hono/dist/helper/streaming/utils.js
var isOldBunVersion = () => {
  const version = typeof Bun !== "undefined" ? Bun.version : void 0;
  if (version === void 0) {
    return false;
  }
  const result = version.startsWith("1.1") || version.startsWith("1.0") || version.startsWith("0.");
  isOldBunVersion = () => result;
  return result;
};

// ../../node_modules/.pnpm/hono@4.9.7/node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  {
    return resStr;
  }
};

// ../../node_modules/.pnpm/hono@4.9.7/node_modules/hono/dist/helper/streaming/sse.js
var SSEStreamingApi = class extends StreamingApi {
  constructor(writable, readable) {
    super(writable, readable);
  }
  async writeSSE(message) {
    const data = await resolveCallback(message.data, HtmlEscapedCallbackPhase.Stringify, false, {});
    const dataLines = data.split("\n").map((line) => {
      return `data: ${line}`;
    }).join("\n");
    const sseData = [
      message.event && `event: ${message.event}`,
      dataLines,
      message.id && `id: ${message.id}`,
      message.retry && `retry: ${message.retry}`
    ].filter(Boolean).join("\n") + "\n\n";
    await this.write(sseData);
  }
};
var run = async (stream2, cb, onError) => {
  try {
    await cb(stream2);
  } catch (e) {
    {
      console.error(e);
    }
  } finally {
    stream2.close();
  }
};
var contextStash = /* @__PURE__ */ new WeakMap();
var streamSSE = (c, cb, onError) => {
  const { readable, writable } = new TransformStream();
  const stream2 = new SSEStreamingApi(writable, readable);
  if (isOldBunVersion()) {
    c.req.raw.signal.addEventListener("abort", () => {
      if (!stream2.closed) {
        stream2.abort();
      }
    });
  }
  contextStash.set(stream2.responseReadable, c);
  c.header("Transfer-Encoding", "chunked");
  c.header("Content-Type", "text/event-stream");
  c.header("Cache-Control", "no-cache");
  c.header("Connection", "keep-alive");
  run(stream2, cb);
  return c.newResponse(stream2.responseReadable);
};
var MAXIMUM_MESSAGE_SIZE = 4 * 1024 * 1024;
var SSETransport = class {
  messageUrl;
  stream;
  _sessionId;
  onclose;
  onerror;
  onmessage;
  /**
   * Creates a new SSETransport, which will direct the MPC client to POST messages to messageUrl
   */
  constructor(messageUrl, stream2) {
    this.messageUrl = messageUrl;
    this.stream = stream2;
    this._sessionId = crypto.randomUUID();
    this.stream.onAbort(() => {
      void this.close();
    });
  }
  get sessionId() {
    return this._sessionId;
  }
  // start() is automatically called after MCP Server connects to the transport
  async start() {
    if (this.stream == null) {
      throw new Error("Stream not initialized");
    }
    if (this.stream.closed) {
      throw new Error("SSE transport already closed!");
    }
    await this.stream.writeSSE({
      event: "ping",
      data: ""
    });
    await this.stream.writeSSE({
      event: "endpoint",
      data: `${this.messageUrl}?sessionId=${this.sessionId}`
    });
  }
  async handlePostMessage(context) {
    if (this.stream?.closed == null) {
      return context.text("SSE connection not established", 500);
    }
    try {
      const contentType = context.req.header("content-type") || "";
      if (!contentType.includes("application/json")) {
        throw new Error(`Unsupported content-type: ${contentType}`);
      }
      const contentLength = Number.parseInt(context.req.header("content-length") || "0", 10);
      if (contentLength > MAXIMUM_MESSAGE_SIZE) {
        throw new Error(`Request body too large: ${contentLength} bytes`);
      }
      const body = await context.req.json();
      await this.handleMessage(body);
      return context.text("Accepted", 202);
    } catch (error) {
      this.onerror?.(error);
      return context.text("Error", 400);
    }
  }
  /**
   * Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.
   */
  async handleMessage(message) {
    let parsedMessage;
    try {
      parsedMessage = JSONRPCMessageSchema.parse(message);
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
    this.onmessage?.(parsedMessage);
  }
  async close() {
    if (this.stream?.closed) {
      this.stream.abort();
    }
  }
  async send(message) {
    if (this.stream?.closed) {
      throw new Error("Not connected");
    }
    await this.stream.writeSSE({
      event: "message",
      data: JSON.stringify(message)
    });
  }
};
var ServerPromptActions = class {
  getLogger;
  getSdkServer;
  clearDefinedPrompts;
  /**
   * @internal
   */
  constructor(dependencies) {
    this.getLogger = dependencies.getLogger;
    this.getSdkServer = dependencies.getSdkServer;
    this.clearDefinedPrompts = dependencies.clearDefinedPrompts;
  }
  /**
   * Notifies clients that the overall list of available prompts has changed.
   *
   * This clears the internal prompt cache and sends a `notifications/prompts/list_changed`
   * message to all clients, prompting them to re-fetch the prompt list.
   *
   * @throws {MastraError} If sending the notification fails
   *
   * @example
   * ```typescript
   * // After adding or modifying prompts
   * await server.prompts.notifyListChanged();
   * ```
   */
  async notifyListChanged() {
    this.getLogger().info("Prompt list change externally notified. Clearing definedPrompts and sending notification.");
    this.clearDefinedPrompts();
    try {
      await this.getSdkServer().sendPromptListChanged();
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_PROMPT_LIST_CHANGED_NOTIFICATION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY,
          text: "Failed to send prompt list changed notification"
        },
        error
      );
      this.getLogger().error("Failed to send prompt list changed notification:", {
        error: mastraError.toString()
      });
      this.getLogger().trackException(mastraError);
      throw mastraError;
    }
  }
};
var ServerResourceActions = class {
  getSubscriptions;
  getLogger;
  getSdkServer;
  clearDefinedResources;
  clearDefinedResourceTemplates;
  /**
   * @internal
   */
  constructor(dependencies) {
    this.getSubscriptions = dependencies.getSubscriptions;
    this.getLogger = dependencies.getLogger;
    this.getSdkServer = dependencies.getSdkServer;
    this.clearDefinedResources = dependencies.clearDefinedResources;
    this.clearDefinedResourceTemplates = dependencies.clearDefinedResourceTemplates;
  }
  /**
   * Notifies subscribed clients that a specific resource has been updated.
   *
   * If clients are subscribed to the resource URI, they will receive a
   * `notifications/resources/updated` message to re-fetch the resource content.
   *
   * @param params - Notification parameters
   * @param params.uri - URI of the resource that was updated
   * @throws {MastraError} If sending the notification fails
   *
   * @example
   * ```typescript
   * // After updating a file resource
   * await server.resources.notifyUpdated({ uri: 'file://data.txt' });
   * ```
   */
  async notifyUpdated({ uri }) {
    if (this.getSubscriptions().has(uri)) {
      this.getLogger().info(`Sending notifications/resources/updated for externally notified resource: ${uri}`);
      try {
        await this.getSdkServer().sendResourceUpdated({ uri });
      } catch (error) {
        const mastraError = new MastraError(
          {
            id: "MCP_SERVER_RESOURCE_UPDATED_NOTIFICATION_FAILED",
            domain: ErrorDomain.MCP,
            category: ErrorCategory.THIRD_PARTY,
            text: "Failed to send resource updated notification",
            details: {
              uri
            }
          },
          error
        );
        this.getLogger().trackException(mastraError);
        this.getLogger().error("Failed to send resource updated notification:", {
          error: mastraError.toString()
        });
        throw mastraError;
      }
    } else {
      this.getLogger().debug(`Resource ${uri} was updated, but no active subscriptions for it.`);
    }
  }
  /**
   * Notifies clients that the overall list of available resources has changed.
   *
   * This clears the internal resource cache and sends a `notifications/resources/list_changed`
   * message to all clients, prompting them to re-fetch the resource list.
   *
   * @throws {MastraError} If sending the notification fails
   *
   * @example
   * ```typescript
   * // After adding a new resource to your resource handler
   * await server.resources.notifyListChanged();
   * ```
   */
  async notifyListChanged() {
    this.getLogger().info(
      "Resource list change externally notified. Clearing definedResources and sending notification."
    );
    this.clearDefinedResources();
    this.clearDefinedResourceTemplates();
    try {
      await this.getSdkServer().sendResourceListChanged();
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_RESOURCE_LIST_CHANGED_NOTIFICATION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY,
          text: "Failed to send resource list changed notification"
        },
        error
      );
      this.getLogger().trackException(mastraError);
      this.getLogger().error("Failed to send resource list changed notification:", {
        error: mastraError.toString()
      });
      throw mastraError;
    }
  }
};

// src/server/server.ts
var MCPServer = class extends MCPServerBase {
  server;
  stdioTransport;
  sseTransport;
  sseHonoTransports;
  streamableHTTPTransports = /* @__PURE__ */ new Map();
  // Track server instances for each HTTP session
  httpServerInstances = /* @__PURE__ */ new Map();
  definedResources;
  definedResourceTemplates;
  resourceOptions;
  definedPrompts;
  promptOptions;
  subscriptions = /* @__PURE__ */ new Set();
  currentLoggingLevel;
  /**
   * Provides methods to notify clients about resource changes.
   *
   * @example
   * ```typescript
   * // Notify that a specific resource was updated
   * await server.resources.notifyUpdated({ uri: 'file://data.txt' });
   *
   * // Notify that the resource list changed
   * await server.resources.notifyListChanged();
   * ```
   */
  resources;
  /**
   * Provides methods to notify clients about prompt changes.
   *
   * @example
   * ```typescript
   * // Notify that the prompt list changed
   * await server.prompts.notifyListChanged();
   * ```
   */
  prompts;
  /**
   * Provides methods for interactive user input collection during tool execution.
   *
   * @example
   * ```typescript
   * // Within a tool's execute function
   * const result = await options.elicitation.sendRequest({
   *   message: 'Please provide your email address',
   *   requestedSchema: {
   *     type: 'object',
   *     properties: {
   *       email: { type: 'string', format: 'email' }
   *     },
   *     required: ['email']
   *   }
   * });
   * ```
   */
  elicitation;
  /**
   * Gets the stdio transport instance if the server was started using stdio.
   *
   * This is primarily for internal checks or testing purposes.
   *
   * @returns The stdio transport instance, or undefined if not using stdio transport
   */
  getStdioTransport() {
    return this.stdioTransport;
  }
  /**
   * Gets the SSE transport instance if the server was started using SSE.
   *
   * This is primarily for internal checks or testing purposes.
   *
   * @returns The SSE transport instance, or undefined if not using SSE transport
   */
  getSseTransport() {
    return this.sseTransport;
  }
  /**
   * Gets the Hono SSE transport instance for a specific session.
   *
   * This is primarily for internal checks or testing purposes.
   *
   * @param sessionId - The session identifier
   * @returns The Hono SSE transport instance, or undefined if session not found
   */
  getSseHonoTransport(sessionId) {
    return this.sseHonoTransports.get(sessionId);
  }
  /**
   * Gets the underlying MCP SDK Server instance.
   *
   * This provides access to the low-level server instance for advanced use cases.
   *
   * @returns The Server instance from @modelcontextprotocol/sdk
   */
  getServer() {
    return this.server;
  }
  /**
   * Creates a new MCPServer instance.
   *
   * The server exposes tools, agents, and workflows to MCP clients. Agents are automatically
   * converted to tools named `ask_<agentKey>`, and workflows become tools named `run_<workflowKey>`.
   *
   * @param opts - Configuration options for the server
   * @param opts.name - Descriptive name for the server (e.g., 'My Weather Server')
   * @param opts.version - Semantic version of the server (e.g., '1.0.0')
   * @param opts.tools - Object mapping tool names to tool definitions
   * @param opts.agents - Optional object mapping agent identifiers to Agent instances
   * @param opts.workflows - Optional object mapping workflow identifiers to Workflow instances
   * @param opts.resources - Optional resource configuration for exposing data and content
   * @param opts.prompts - Optional prompt configuration for exposing reusable templates
   * @param opts.id - Optional unique identifier (generated if not provided)
   * @param opts.description - Optional description of what the server does
   *
   * @example
   * ```typescript
   * import { MCPServer } from '@mastra/mcp';
   * import { Agent } from '@mastra/core/agent';
   * import { createTool } from '@mastra/core/tools';
   * import { z } from 'zod';
   *
   * const myAgent = new Agent({
   *   name: 'Helper',
   *   description: 'A helpful assistant',
   *   instructions: 'You are helpful.',
   *   model: openai('gpt-4o-mini'),
   * });
   *
   * const server = new MCPServer({
   *   name: 'My Server',
   *   version: '1.0.0',
   *   tools: {
   *     weatherTool: createTool({
   *       id: 'getWeather',
   *       description: 'Gets weather',
   *       inputSchema: z.object({ location: z.string() }),
   *       execute: async ({ context }) => `Sunny in ${context.location}`,
   *     })
   *   },
   *   agents: { myAgent },
   * });
   * ```
   */
  constructor(opts) {
    super(opts);
    this.resourceOptions = opts.resources;
    this.promptOptions = opts.prompts;
    const capabilities = {
      tools: {},
      logging: { enabled: true },
      elicitation: {}
    };
    if (opts.resources) {
      capabilities.resources = { subscribe: true, listChanged: true };
    }
    if (opts.prompts) {
      capabilities.prompts = { listChanged: true };
    }
    this.server = new Server({ name: this.name, version: this.version }, { capabilities });
    this.logger.info(
      `Initialized MCPServer '${this.name}' v${this.version} (ID: ${this.id}) with tools: ${Object.keys(this.convertedTools).join(", ")} and resources. Capabilities: ${JSON.stringify(capabilities)}`
    );
    this.sseHonoTransports = /* @__PURE__ */ new Map();
    this.registerHandlersOnServer(this.server);
    this.resources = new ServerResourceActions({
      getSubscriptions: () => this.subscriptions,
      getLogger: () => this.logger,
      getSdkServer: () => this.server,
      clearDefinedResources: () => {
        this.definedResources = void 0;
      },
      clearDefinedResourceTemplates: () => {
        this.definedResourceTemplates = void 0;
      }
    });
    this.prompts = new ServerPromptActions({
      getLogger: () => this.logger,
      getSdkServer: () => this.server,
      clearDefinedPrompts: () => {
        this.definedPrompts = void 0;
      }
    });
    this.elicitation = {
      sendRequest: async (request) => {
        return this.handleElicitationRequest(request);
      }
    };
  }
  /**
   * Handle an elicitation request by sending it to the connected client.
   * This method sends an elicitation/create request to the client and waits for the response.
   *
   * @param request - The elicitation request containing message and schema
   * @param serverInstance - Optional server instance to use; defaults to main server for backward compatibility
   * @returns Promise that resolves to the client's response
   */
  async handleElicitationRequest(request, serverInstance) {
    this.logger.debug(`Sending elicitation request: ${request.message}`);
    const server = serverInstance || this.server;
    const response = await server.elicitInput(request);
    this.logger.debug(`Received elicitation response: ${JSON.stringify(response)}`);
    return response;
  }
  /**
   * Creates a new Server instance configured with all handlers for HTTP sessions.
   * Each HTTP client connection gets its own Server instance to avoid routing conflicts.
   */
  createServerInstance() {
    const capabilities = {
      tools: {},
      logging: { enabled: true },
      elicitation: {}
    };
    if (this.resourceOptions) {
      capabilities.resources = { subscribe: true, listChanged: true };
    }
    if (this.promptOptions) {
      capabilities.prompts = { listChanged: true };
    }
    const serverInstance = new Server({ name: this.name, version: this.version }, { capabilities });
    this.registerHandlersOnServer(serverInstance);
    return serverInstance;
  }
  /**
   * Registers all MCP handlers on a given server instance.
   * This allows us to create multiple server instances with identical functionality.
   */
  registerHandlersOnServer(serverInstance) {
    serverInstance.setRequestHandler(ListToolsRequestSchema, async () => {
      this.logger.debug("Handling ListTools request");
      return {
        tools: Object.values(this.convertedTools).map((tool) => {
          const toolSpec = {
            name: tool.name,
            description: tool.description,
            inputSchema: tool.parameters.jsonSchema
          };
          if (tool.outputSchema) {
            toolSpec.outputSchema = tool.outputSchema.jsonSchema;
          }
          return toolSpec;
        })
      };
    });
    serverInstance.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
      const startTime = Date.now();
      try {
        const tool = this.convertedTools[request.params.name];
        if (!tool) {
          this.logger.warn(`CallTool: Unknown tool '${request.params.name}' requested.`);
          return {
            content: [{ type: "text", text: `Unknown tool: ${request.params.name}` }],
            isError: true
          };
        }
        const validation = tool.parameters.validate?.(request.params.arguments ?? {});
        if (validation && !validation.success) {
          this.logger.warn(`CallTool: Invalid tool arguments for '${request.params.name}'`, {
            errors: validation.error
          });
          let errorMessages = "Validation failed";
          if ("errors" in validation.error && Array.isArray(validation.error.errors)) {
            errorMessages = validation.error.errors.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
          } else if (validation.error instanceof Error) {
            errorMessages = validation.error.message;
          }
          return {
            content: [
              {
                type: "text",
                text: `Tool validation failed. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${JSON.stringify(request.params.arguments, null, 2)}`
              }
            ],
            isError: true
            // Set to true so the LLM sees the error and can self-correct
          };
        }
        if (!tool.execute) {
          this.logger.warn(`CallTool: Tool '${request.params.name}' does not have an execute function.`);
          return {
            content: [{ type: "text", text: `Tool '${request.params.name}' does not have an execute function.` }],
            isError: true
          };
        }
        const sessionElicitation = {
          sendRequest: async (request2) => {
            return this.handleElicitationRequest(request2, serverInstance);
          }
        };
        const result = await tool.execute(validation?.value ?? request.params.arguments ?? {}, {
          messages: [],
          toolCallId: "",
          elicitation: sessionElicitation,
          extra
        });
        this.logger.debug(`CallTool: Tool '${request.params.name}' executed successfully with result:`, result);
        const duration = Date.now() - startTime;
        this.logger.info(`Tool '${request.params.name}' executed successfully in ${duration}ms.`);
        const response = { isError: false, content: [] };
        if (tool.outputSchema) {
          let structuredContent;
          if (result && typeof result === "object" && "structuredContent" in result) {
            structuredContent = result.structuredContent;
          } else {
            structuredContent = result;
          }
          const outputValidation = tool.outputSchema.validate?.(structuredContent ?? {});
          if (outputValidation && !outputValidation.success) {
            this.logger.warn(`CallTool: Invalid structured content for '${request.params.name}'`, {
              errors: outputValidation.error
            });
            throw new Error(
              `Invalid structured content for tool ${request.params.name}: ${JSON.stringify(outputValidation.error)}`
            );
          }
          response.structuredContent = structuredContent;
        }
        if (response.structuredContent) {
          response.content = [{ type: "text", text: JSON.stringify(response.structuredContent) }];
        } else {
          response.content = [
            {
              type: "text",
              text: typeof result === "string" ? result : JSON.stringify(result)
            }
          ];
        }
        return response;
      } catch (error) {
        const duration = Date.now() - startTime;
        if (error instanceof z.ZodError) {
          this.logger.warn("Invalid tool arguments", {
            tool: request.params.name,
            errors: error.errors,
            duration: `${duration}ms`
          });
          return {
            content: [
              {
                type: "text",
                text: `Invalid arguments: ${error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ")}`
              }
            ],
            isError: true
          };
        }
        this.logger.error(`Tool execution failed: ${request.params.name}`, { error });
        return {
          content: [{ type: "text", text: `Error: ${error instanceof Error ? error.message : String(error)}` }],
          isError: true
        };
      }
    });
    serverInstance.setRequestHandler(SetLevelRequestSchema, async (request) => {
      this.currentLoggingLevel = request.params.level;
      this.logger.debug(`Logging level set to: ${request.params.level}`);
      return {};
    });
    if (this.resourceOptions) {
      this.registerResourceHandlersOnServer(serverInstance);
    }
    if (this.promptOptions) {
      this.registerPromptHandlersOnServer(serverInstance);
    }
  }
  /**
   * Registers resource-related handlers on a server instance.
   */
  registerResourceHandlersOnServer(serverInstance) {
    const capturedResourceOptions = this.resourceOptions;
    if (!capturedResourceOptions) return;
    if (capturedResourceOptions.listResources) {
      serverInstance.setRequestHandler(ListResourcesRequestSchema, async (_request, extra) => {
        this.logger.debug("Handling ListResources request");
        if (this.definedResources) {
          return { resources: this.definedResources };
        } else {
          try {
            const resources = await capturedResourceOptions.listResources({ extra });
            this.definedResources = resources;
            this.logger.debug(`Fetched and cached ${this.definedResources.length} resources.`);
            return { resources: this.definedResources };
          } catch (error) {
            this.logger.error("Error fetching resources via listResources():", { error });
            throw error;
          }
        }
      });
    }
    if (capturedResourceOptions.getResourceContent) {
      serverInstance.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
        const startTime = Date.now();
        const uri = request.params.uri;
        this.logger.debug(`Handling ReadResource request for URI: ${uri}`);
        if (!this.definedResources) {
          const resources = await this.resourceOptions?.listResources?.({ extra });
          if (!resources) throw new Error("Failed to load resources");
          this.definedResources = resources;
        }
        const resource = this.definedResources?.find((r) => r.uri === uri);
        if (!resource) {
          this.logger.warn(`ReadResource: Unknown resource URI '${uri}' requested.`);
          throw new Error(`Resource not found: ${uri}`);
        }
        try {
          const resourcesOrResourceContent = await capturedResourceOptions.getResourceContent({ uri, extra });
          const resourcesContent = Array.isArray(resourcesOrResourceContent) ? resourcesOrResourceContent : [resourcesOrResourceContent];
          const contents = resourcesContent.map((resourceContent) => {
            const contentItem = {
              uri: resource.uri,
              mimeType: resource.mimeType
            };
            if ("text" in resourceContent) {
              contentItem.text = resourceContent.text;
            }
            if ("blob" in resourceContent) {
              contentItem.blob = resourceContent.blob;
            }
            return contentItem;
          });
          const duration = Date.now() - startTime;
          this.logger.info(`Resource '${uri}' read successfully in ${duration}ms.`);
          return {
            contents
          };
        } catch (error) {
          const duration = Date.now() - startTime;
          this.logger.error(`Failed to get content for resource URI '${uri}' in ${duration}ms`, { error });
          throw error;
        }
      });
    }
    if (capturedResourceOptions.resourceTemplates) {
      serverInstance.setRequestHandler(ListResourceTemplatesRequestSchema, async (_request, extra) => {
        this.logger.debug("Handling ListResourceTemplates request");
        if (this.definedResourceTemplates) {
          return { resourceTemplates: this.definedResourceTemplates };
        } else {
          try {
            const templates = await capturedResourceOptions.resourceTemplates({ extra });
            this.definedResourceTemplates = templates;
            this.logger.debug(`Fetched and cached ${this.definedResourceTemplates.length} resource templates.`);
            return { resourceTemplates: this.definedResourceTemplates };
          } catch (error) {
            this.logger.error("Error fetching resource templates via resourceTemplates():", { error });
            throw error;
          }
        }
      });
    }
    serverInstance.setRequestHandler(SubscribeRequestSchema, async (request) => {
      const uri = request.params.uri;
      this.logger.info(`Received resources/subscribe request for URI: ${uri}`);
      this.subscriptions.add(uri);
      return {};
    });
    serverInstance.setRequestHandler(UnsubscribeRequestSchema, async (request) => {
      const uri = request.params.uri;
      this.logger.info(`Received resources/unsubscribe request for URI: ${uri}`);
      this.subscriptions.delete(uri);
      return {};
    });
  }
  /**
   * Registers prompt-related handlers on a server instance.
   */
  registerPromptHandlersOnServer(serverInstance) {
    const capturedPromptOptions = this.promptOptions;
    if (!capturedPromptOptions) return;
    if (capturedPromptOptions.listPrompts) {
      serverInstance.setRequestHandler(ListPromptsRequestSchema, async (_request, extra) => {
        this.logger.debug("Handling ListPrompts request");
        if (this.definedPrompts) {
          return {
            prompts: this.definedPrompts?.map((p) => ({ ...p, version: p.version ?? void 0 }))
          };
        } else {
          try {
            const prompts = await capturedPromptOptions.listPrompts({ extra });
            for (const prompt of prompts) {
              PromptSchema.parse(prompt);
            }
            this.definedPrompts = prompts;
            this.logger.debug(`Fetched and cached ${this.definedPrompts.length} prompts.`);
            return {
              prompts: this.definedPrompts?.map((p) => ({ ...p, version: p.version ?? void 0 }))
            };
          } catch (error) {
            this.logger.error("Error fetching prompts via listPrompts():", {
              error: error instanceof Error ? error.message : String(error)
            });
            throw error;
          }
        }
      });
    }
    if (capturedPromptOptions.getPromptMessages) {
      serverInstance.setRequestHandler(
        GetPromptRequestSchema,
        async (request, extra) => {
          const startTime = Date.now();
          const { name, version, arguments: args } = request.params;
          if (!this.definedPrompts) {
            const prompts = await this.promptOptions?.listPrompts?.({ extra });
            if (!prompts) throw new Error("Failed to load prompts");
            this.definedPrompts = prompts;
          }
          let prompt;
          if (version) {
            prompt = this.definedPrompts?.find((p) => p.name === name && p.version === version);
          } else {
            prompt = this.definedPrompts?.find((p) => p.name === name);
          }
          if (!prompt) throw new Error(`Prompt "${name}"${version ? ` (version ${version})` : ""} not found`);
          if (prompt.arguments) {
            for (const arg of prompt.arguments) {
              if (arg.required && (args?.[arg.name] === void 0 || args?.[arg.name] === null)) {
                throw new Error(`Missing required argument: ${arg.name}`);
              }
            }
          }
          try {
            let messages = [];
            if (capturedPromptOptions.getPromptMessages) {
              messages = await capturedPromptOptions.getPromptMessages({ name, version, args, extra });
            }
            const duration = Date.now() - startTime;
            this.logger.info(
              `Prompt '${name}'${version ? ` (version ${version})` : ""} retrieved successfully in ${duration}ms.`
            );
            return { prompt, messages };
          } catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Failed to get content for prompt '${name}' in ${duration}ms`, { error });
            throw error;
          }
        }
      );
    }
  }
  convertAgentsToTools(agentsConfig, definedConvertedTools) {
    const agentTools = {};
    if (!agentsConfig) {
      return agentTools;
    }
    for (const agentKey in agentsConfig) {
      const agent = agentsConfig[agentKey];
      if (!agent || !("generate" in agent)) {
        this.logger.warn(`Agent instance for '${agentKey}' is invalid or missing a generate function. Skipping.`);
        continue;
      }
      const agentDescription = agent.getDescription();
      if (!agentDescription) {
        throw new Error(
          `Agent '${agent.name}' (key: '${agentKey}') must have a non-empty description to be used in an MCPServer.`
        );
      }
      const agentToolName = `ask_${agentKey}`;
      if (definedConvertedTools?.[agentToolName] || agentTools[agentToolName]) {
        this.logger.warn(
          `Tool with name '${agentToolName}' already exists. Agent '${agentKey}' will not be added as a duplicate tool.`
        );
        continue;
      }
      const agentToolDefinition = createTool({
        id: agentToolName,
        description: `Ask agent '${agent.name}' a question. Agent description: ${agentDescription}`,
        inputSchema: z.object({
          message: z.string().describe("The question or input for the agent.")
        }),
        execute: async ({ context, runtimeContext, tracingContext }) => {
          this.logger.debug(
            `Executing agent tool '${agentToolName}' for agent '${agent.name}' with message: "${context.message}"`
          );
          try {
            const response = await agent.generate(context.message, { runtimeContext, tracingContext });
            return response;
          } catch (error) {
            this.logger.error(`Error executing agent tool '${agentToolName}' for agent '${agent.name}':`, error);
            throw error;
          }
        }
      });
      const options = {
        name: agentToolName,
        logger: this.logger,
        mastra: this.mastra,
        runtimeContext: new RuntimeContext(),
        tracingContext: {},
        description: agentToolDefinition.description
      };
      const coreTool = makeCoreTool(agentToolDefinition, options);
      agentTools[agentToolName] = {
        name: agentToolName,
        description: coreTool.description,
        parameters: coreTool.parameters,
        execute: coreTool.execute,
        toolType: "agent"
      };
      this.logger.info(`Registered agent '${agent.name}' (key: '${agentKey}') as tool: '${agentToolName}'`);
    }
    return agentTools;
  }
  convertWorkflowsToTools(workflowsConfig, definedConvertedTools) {
    const workflowTools = {};
    if (!workflowsConfig) {
      return workflowTools;
    }
    for (const workflowKey in workflowsConfig) {
      const workflow = workflowsConfig[workflowKey];
      if (!workflow || typeof workflow.createRun !== "function") {
        this.logger.warn(
          `Workflow instance for '${workflowKey}' is invalid or missing a createRun function. Skipping.`
        );
        continue;
      }
      const workflowDescription = workflow.description;
      if (!workflowDescription) {
        throw new Error(
          `Workflow '${workflow.id}' (key: '${workflowKey}') must have a non-empty description to be used in an MCPServer.`
        );
      }
      const workflowToolName = `run_${workflowKey}`;
      if (definedConvertedTools?.[workflowToolName] || workflowTools[workflowToolName]) {
        this.logger.warn(
          `Tool with name '${workflowToolName}' already exists. Workflow '${workflowKey}' will not be added as a duplicate tool.`
        );
        continue;
      }
      const workflowToolDefinition = createTool({
        id: workflowToolName,
        description: `Run workflow '${workflowKey}'. Workflow description: ${workflowDescription}`,
        inputSchema: workflow.inputSchema,
        execute: async ({ context, runtimeContext, tracingContext }) => {
          this.logger.debug(
            `Executing workflow tool '${workflowToolName}' for workflow '${workflow.id}' with input:`,
            context
          );
          try {
            const run2 = await workflow.createRunAsync({ runId: runtimeContext?.get("runId") });
            const response = await run2.start({ inputData: context, runtimeContext, tracingContext });
            return response;
          } catch (error) {
            this.logger.error(
              `Error executing workflow tool '${workflowToolName}' for workflow '${workflow.id}':`,
              error
            );
            throw error;
          }
        }
      });
      const options = {
        name: workflowToolName,
        logger: this.logger,
        mastra: this.mastra,
        runtimeContext: new RuntimeContext(),
        tracingContext: {},
        description: workflowToolDefinition.description
      };
      const coreTool = makeCoreTool(workflowToolDefinition, options);
      workflowTools[workflowToolName] = {
        name: workflowToolName,
        description: coreTool.description,
        parameters: coreTool.parameters,
        outputSchema: coreTool.outputSchema,
        execute: coreTool.execute,
        toolType: "workflow"
      };
      this.logger.info(`Registered workflow '${workflow.id}' (key: '${workflowKey}') as tool: '${workflowToolName}'`);
    }
    return workflowTools;
  }
  /**
   * Convert and validate all provided tools, logging registration status.
   * Also converts agents and workflows into tools.
   * @param tools Tool definitions
   * @param agentsConfig Agent definitions to be converted to tools, expected from MCPServerConfig
   * @param workflowsConfig Workflow definitions to be converted to tools, expected from MCPServerConfig
   * @returns Converted tools registry
   */
  convertTools(tools, agentsConfig, workflowsConfig) {
    const definedConvertedTools = {};
    for (const toolName of Object.keys(tools)) {
      const toolInstance = tools[toolName];
      if (!toolInstance) {
        this.logger.warn(`Tool instance for '${toolName}' is undefined. Skipping.`);
        continue;
      }
      if (typeof toolInstance.execute !== "function") {
        this.logger.warn(`Tool '${toolName}' does not have a valid execute function. Skipping.`);
        continue;
      }
      const options = {
        name: toolName,
        runtimeContext: new RuntimeContext(),
        tracingContext: {},
        mastra: this.mastra,
        logger: this.logger,
        description: toolInstance?.description
      };
      const coreTool = makeCoreTool(toolInstance, options);
      definedConvertedTools[toolName] = {
        name: toolName,
        description: coreTool.description,
        parameters: coreTool.parameters,
        outputSchema: coreTool.outputSchema,
        execute: coreTool.execute
      };
      this.logger.info(`Registered explicit tool: '${toolName}'`);
    }
    this.logger.info(`Total defined tools registered: ${Object.keys(definedConvertedTools).length}`);
    let agentDerivedTools = {};
    let workflowDerivedTools = {};
    try {
      agentDerivedTools = this.convertAgentsToTools(agentsConfig, definedConvertedTools);
      workflowDerivedTools = this.convertWorkflowsToTools(workflowsConfig, definedConvertedTools);
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_AGENT_OR_WORKFLOW_TOOL_CONVERSION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to convert tools:", {
        error: mastraError.toString()
      });
      throw mastraError;
    }
    const allConvertedTools = { ...definedConvertedTools, ...agentDerivedTools, ...workflowDerivedTools };
    const finalToolCount = Object.keys(allConvertedTools).length;
    const definedCount = Object.keys(definedConvertedTools).length;
    const fromAgentsCount = Object.keys(agentDerivedTools).length;
    const fromWorkflowsCount = Object.keys(workflowDerivedTools).length;
    this.logger.info(
      `${finalToolCount} total tools registered (${definedCount} defined + ${fromAgentsCount} agents + ${fromWorkflowsCount} workflows)`
    );
    return allConvertedTools;
  }
  /**
   * Starts the MCP server using standard input/output (stdio) transport.
   *
   * This is typically used when running the server as a command-line program that MCP clients
   * spawn as a subprocess (e.g., integration with Windsurf, Cursor, or Claude Desktop).
   *
   * @throws {MastraError} If the stdio connection fails
   *
   * @example
   * ```typescript
   * const server = new MCPServer({
   *   name: 'My Server',
   *   version: '1.0.0',
   *   tools: { weatherTool },
   * });
   *
   * await server.startStdio();
   * ```
   */
  async startStdio() {
    this.stdioTransport = new StdioServerTransport();
    try {
      await this.server.connect(this.stdioTransport);
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_STDIO_CONNECTION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY
        },
        error
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to connect MCP server using stdio transport:", {
        error: mastraError.toString()
      });
      throw mastraError;
    }
    this.logger.info("Started MCP Server (stdio)");
  }
  /**
   * Integrates the MCP server with an existing HTTP server using Server-Sent Events (SSE).
   *
   * Call this method from your web server's request handler for both the SSE and message paths.
   * This enables web-based MCP clients to connect to your server.
   *
   * @param options - Configuration for SSE integration
   * @param options.url - Parsed URL of the incoming request
   * @param options.ssePath - Path for establishing SSE connection (e.g., '/sse')
   * @param options.messagePath - Path for POSTing client messages (e.g., '/message')
   * @param options.req - Incoming HTTP request object
   * @param options.res - HTTP response object (must support .write/.end)
   *
   * @throws {MastraError} If SSE connection setup fails
   *
   * @example
   * ```typescript
   * import http from 'http';
   *
   * const httpServer = http.createServer(async (req, res) => {
   *   await server.startSSE({
   *     url: new URL(req.url || '', `http://localhost:1234`),
   *     ssePath: '/sse',
   *     messagePath: '/message',
   *     req,
   *     res,
   *   });
   * });
   *
   * httpServer.listen(1234, () => {
   *   console.log('MCP server listening on http://localhost:1234/sse');
   * });
   * ```
   */
  async startSSE({ url, ssePath, messagePath, req, res }) {
    try {
      if (url.pathname === ssePath) {
        await this.connectSSE({
          messagePath,
          res
        });
      } else if (url.pathname === messagePath) {
        this.logger.debug("Received message");
        if (!this.sseTransport) {
          res.writeHead(503);
          res.end("SSE connection not established");
          return;
        }
        await this.sseTransport.handlePostMessage(req, res);
      } else {
        this.logger.debug("Unknown path:", { path: url.pathname });
        res.writeHead(404);
        res.end();
      }
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_SSE_START_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            url: url.toString(),
            ssePath,
            messagePath
          }
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to start MCP Server (SSE):", { error: mastraError.toString() });
      throw mastraError;
    }
  }
  /**
   * Integrates the MCP server with a Hono web framework using Server-Sent Events (SSE).
   *
   * Call this method from your Hono server's request handler for both the SSE and message paths.
   * This enables Hono-based web applications to expose MCP servers.
   *
   * @param options - Configuration for Hono SSE integration
   * @param options.url - Parsed URL of the incoming request
   * @param options.ssePath - Path for establishing SSE connection (e.g., '/hono-sse')
   * @param options.messagePath - Path for POSTing client messages (e.g., '/message')
   * @param options.context - Hono context object
   *
   * @throws {MastraError} If Hono SSE connection setup fails
   *
   * @example
   * ```typescript
   * import { Hono } from 'hono';
   *
   * const app = new Hono();
   *
   * app.all('*', async (c) => {
   *   const url = new URL(c.req.url);
   *   return await server.startHonoSSE({
   *     url,
   *     ssePath: '/hono-sse',
   *     messagePath: '/message',
   *     context: c,
   *   });
   * });
   *
   * export default app;
   * ```
   */
  async startHonoSSE({ url, ssePath, messagePath, context }) {
    try {
      if (url.pathname === ssePath) {
        return streamSSE(context, async (stream2) => {
          await this.connectHonoSSE({
            messagePath,
            stream: stream2
          });
        });
      } else if (url.pathname === messagePath) {
        this.logger.debug("Received message");
        const sessionId = context.req.query("sessionId");
        this.logger.debug("Received message for sessionId", { sessionId });
        if (!sessionId) {
          return context.text("No sessionId provided", 400);
        }
        if (!this.sseHonoTransports.has(sessionId)) {
          return context.text(`No transport found for sessionId ${sessionId}`, 400);
        }
        const message = await this.sseHonoTransports.get(sessionId)?.handlePostMessage(context);
        if (!message) {
          return context.text("Transport not found", 400);
        }
        return message;
      } else {
        this.logger.debug("Unknown path:", { path: url.pathname });
        return context.text("Unknown path", 404);
      }
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_HONO_SSE_START_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            url: url.toString(),
            ssePath,
            messagePath
          }
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to start MCP Server (Hono SSE):", { error: mastraError.toString() });
      throw mastraError;
    }
  }
  /**
   * Integrates the MCP server with an existing HTTP server using streamable HTTP transport.
   *
   * This is the recommended modern transport method, providing better session management and
   * reliability compared to SSE. Call this from your HTTP server's request handler.
   *
   * @param options - Configuration for HTTP integration
   * @param options.url - Parsed URL of the incoming request
   * @param options.httpPath - Path for the MCP endpoint (e.g., '/mcp')
   * @param options.req - Incoming HTTP request (http.IncomingMessage)
   * @param options.res - HTTP response object (http.ServerResponse)
   * @param options.options - Optional transport options
   * @param options.options.sessionIdGenerator - Function to generate unique session IDs (defaults to randomUUID)
   * @param options.options.onsessioninitialized - Callback when a new session is initialized
   * @param options.options.enableJsonResponse - If true, return JSON instead of SSE streaming
   * @param options.options.eventStore - Event store for message resumability
   *
   * @throws {MastraError} If HTTP connection setup fails
   *
   * @example
   * ```typescript
   * import http from 'http';
   * import { randomUUID } from 'crypto';
   *
   * const httpServer = http.createServer(async (req, res) => {
   *   await server.startHTTP({
   *     url: new URL(req.url || '', 'http://localhost:1234'),
   *     httpPath: '/mcp',
   *     req,
   *     res,
   *     options: {
   *       sessionIdGenerator: () => randomUUID(),
   *       onsessioninitialized: (sessionId) => {
   *         console.log(`New MCP session: ${sessionId}`);
   *       },
   *     },
   *   });
   * });
   *
   * httpServer.listen(1234);
   * ```
   */
  async startHTTP({
    url,
    httpPath,
    req,
    res,
    options = { sessionIdGenerator: () => randomUUID() }
  }) {
    this.logger.debug(`startHTTP: Received ${req.method} request to ${url.pathname}`);
    if (url.pathname !== httpPath) {
      this.logger.debug(`startHTTP: Pathname ${url.pathname} does not match httpPath ${httpPath}. Returning 404.`);
      res.writeHead(404);
      res.end();
      return;
    }
    const sessionId = req.headers["mcp-session-id"];
    let transport;
    this.logger.debug(
      `startHTTP: Session ID from headers: ${sessionId}. Active transports: ${Array.from(this.streamableHTTPTransports.keys()).join(", ")}`
    );
    try {
      if (sessionId && this.streamableHTTPTransports.has(sessionId)) {
        transport = this.streamableHTTPTransports.get(sessionId);
        this.logger.debug(`startHTTP: Using existing Streamable HTTP transport for session ID: ${sessionId}`);
        if (req.method === "GET") {
          this.logger.debug(
            `startHTTP: Handling GET request for existing session ${sessionId}. Calling transport.handleRequest.`
          );
        }
        const body = req.method === "POST" ? await new Promise((resolve, reject) => {
          let data = "";
          req.on("data", (chunk) => data += chunk);
          req.on("end", () => {
            try {
              resolve(JSON.parse(data));
            } catch (e) {
              reject(e);
            }
          });
          req.on("error", reject);
        }) : void 0;
        await transport.handleRequest(req, res, body);
      } else {
        this.logger.debug(`startHTTP: No existing Streamable HTTP session ID found. ${req.method}`);
        if (req.method === "POST") {
          const body = await new Promise((resolve, reject) => {
            let data = "";
            req.on("data", (chunk) => data += chunk);
            req.on("end", () => {
              try {
                resolve(JSON.parse(data));
              } catch (e) {
                reject(e);
              }
            });
            req.on("error", reject);
          });
          const { isInitializeRequest } = await import('@modelcontextprotocol/sdk/types.js');
          if (isInitializeRequest(body)) {
            this.logger.debug("startHTTP: Received Streamable HTTP initialize request, creating new transport.");
            transport = new StreamableHTTPServerTransport({
              ...options,
              sessionIdGenerator: () => randomUUID(),
              onsessioninitialized: (id) => {
                this.streamableHTTPTransports.set(id, transport);
              }
            });
            transport.onclose = () => {
              const closedSessionId = transport?.sessionId;
              if (closedSessionId && this.streamableHTTPTransports.has(closedSessionId)) {
                this.logger.debug(
                  `startHTTP: Streamable HTTP transport closed for session ${closedSessionId}, removing from map.`
                );
                this.streamableHTTPTransports.delete(closedSessionId);
                if (this.httpServerInstances.has(closedSessionId)) {
                  this.httpServerInstances.delete(closedSessionId);
                  this.logger.debug(`startHTTP: Cleaned up server instance for closed session ${closedSessionId}`);
                }
              }
            };
            const sessionServerInstance = this.createServerInstance();
            await sessionServerInstance.connect(transport);
            if (transport.sessionId) {
              this.streamableHTTPTransports.set(transport.sessionId, transport);
              this.httpServerInstances.set(transport.sessionId, sessionServerInstance);
              this.logger.debug(
                `startHTTP: Streamable HTTP session initialized and stored with ID: ${transport.sessionId}`
              );
            } else {
              this.logger.warn("startHTTP: Streamable HTTP transport initialized without a session ID.");
            }
            return await transport.handleRequest(req, res, body);
          } else {
            this.logger.warn("startHTTP: Received non-initialize POST request without a session ID.");
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(
              JSON.stringify({
                jsonrpc: "2.0",
                error: {
                  code: -32e3,
                  message: "Bad Request: No valid session ID provided for non-initialize request"
                },
                id: body?.id ?? null
                // Include original request ID if available
              })
            );
          }
        } else {
          this.logger.warn(`startHTTP: Received ${req.method} request without a session ID.`);
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(
            JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: `Bad Request: ${req.method} request requires a valid session ID`
              },
              id: null
            })
          );
        }
      }
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_HTTP_CONNECTION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          text: "Failed to connect MCP server using HTTP transport"
        },
        error
      );
      this.logger.trackException(mastraError);
      this.logger.error("startHTTP: Error handling Streamable HTTP request:", { error: mastraError });
      if (!res.headersSent) {
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(
          JSON.stringify({
            jsonrpc: "2.0",
            error: {
              code: -32603,
              message: "Internal server error"
            },
            id: null
            // Cannot determine original request ID in catch
          })
        );
      }
    }
  }
  /**
   * Establishes the SSE connection for the MCP server.
   *
   * This is a lower-level method called internally by `startSSE()`. In most cases,
   * you should use `startSSE()` instead which handles both connection establishment
   * and message routing.
   *
   * @param params - Connection parameters
   * @param params.messagePath - Path for POST requests from the client
   * @param params.res - HTTP response object for the SSE stream
   * @throws {MastraError} If SSE connection establishment fails
   *
   * @example
   * ```typescript
   * // Usually called internally by startSSE()
   * await server.connectSSE({
   *   messagePath: '/message',
   *   res: response
   * });
   * ```
   */
  async connectSSE({
    messagePath,
    res
  }) {
    try {
      this.logger.debug("Received SSE connection");
      this.sseTransport = new SSEServerTransport(messagePath, res);
      await this.server.connect(this.sseTransport);
      this.server.onclose = async () => {
        this.sseTransport = void 0;
        await this.server.close();
      };
      res.on("close", () => {
        this.sseTransport = void 0;
      });
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_SSE_CONNECT_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            messagePath
          }
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to connect to MCP Server (SSE):", { error: mastraError });
      throw mastraError;
    }
  }
  /**
   * Establishes the Hono SSE connection for the MCP server.
   *
   * This is a lower-level method called internally by `startHonoSSE()`. In most cases,
   * you should use `startHonoSSE()` instead which handles both connection establishment
   * and message routing.
   *
   * @param params - Connection parameters
   * @param params.messagePath - Path for POST requests from the client
   * @param params.stream - Hono SSE streaming API object
   * @throws {MastraError} If Hono SSE connection establishment fails
   *
   * @example
   * ```typescript
   * // Usually called internally by startHonoSSE()
   * await server.connectHonoSSE({
   *   messagePath: '/message',
   *   stream: sseStream
   * });
   * ```
   */
  async connectHonoSSE({ messagePath, stream: stream2 }) {
    this.logger.debug("Received SSE connection");
    const sseTransport = new SSETransport(messagePath, stream2);
    const sessionId = sseTransport.sessionId;
    this.logger.debug("SSE Transport created with sessionId:", { sessionId });
    this.sseHonoTransports.set(sessionId, sseTransport);
    stream2.onAbort(() => {
      this.logger.debug("SSE Transport aborted with sessionId:", { sessionId });
      this.sseHonoTransports.delete(sessionId);
    });
    try {
      await this.server.connect(sseTransport);
      this.server.onclose = async () => {
        this.logger.debug("SSE Transport closed with sessionId:", { sessionId });
        this.sseHonoTransports.delete(sessionId);
        await this.server.close();
      };
      while (true) {
        await stream2.sleep(6e4);
        const sessionIds = Array.from(this.sseHonoTransports.keys() || []);
        this.logger.debug("Active Hono SSE sessions:", { sessionIds });
        await stream2.write(":keep-alive\n\n");
      }
    } catch (e) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_HONO_SSE_CONNECT_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            messagePath
          }
        },
        e
      );
      this.logger.trackException(mastraError);
      this.logger.error("Failed to connect to MCP Server (Hono SSE):", { error: mastraError });
      throw mastraError;
    }
  }
  /**
   * Closes the MCP server and releases all resources.
   *
   * This method cleanly shuts down all active transports (stdio, SSE, HTTP) and their
   * associated connections. Call this when your application is shutting down.
   *
   * @throws {MastraError} If closing the server fails
   *
   * @example
   * ```typescript
   * // Graceful shutdown
   * process.on('SIGTERM', async () => {
   *   await server.close();
   *   process.exit(0);
   * });
   * ```
   */
  async close() {
    try {
      if (this.stdioTransport) {
        await this.stdioTransport.close?.();
        this.stdioTransport = void 0;
      }
      if (this.sseTransport) {
        await this.sseTransport.close?.();
        this.sseTransport = void 0;
      }
      if (this.sseHonoTransports) {
        for (const transport of this.sseHonoTransports.values()) {
          await transport.close?.();
        }
        this.sseHonoTransports.clear();
      }
      if (this.streamableHTTPTransports) {
        for (const transport of this.streamableHTTPTransports.values()) {
          await transport.close?.();
        }
        this.streamableHTTPTransports.clear();
      }
      if (this.httpServerInstances) {
        for (const serverInstance of this.httpServerInstances.values()) {
          await serverInstance.close?.();
        }
        this.httpServerInstances.clear();
      }
      await this.server.close();
      this.logger.info("MCP server closed.");
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_CLOSE_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.THIRD_PARTY
        },
        error
      );
      this.logger.trackException(mastraError);
      this.logger.error("Error closing MCP server:", { error: mastraError });
      throw mastraError;
    }
  }
  /**
   * Gets basic information about the server.
   *
   * Returns metadata including server ID, name, description, repository, and version details.
   * This information conforms to the MCP Server schema.
   *
   * @returns Server information object
   *
   * @example
   * ```typescript
   * const info = server.getServerInfo();
   * console.log(`${info.name} v${info.version_detail.version}`);
   * // Output: My Weather Server v1.0.0
   * ```
   */
  getServerInfo() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      repository: this.repository,
      version_detail: {
        version: this.version,
        release_date: this.releaseDate,
        is_latest: this.isLatest
      }
    };
  }
  /**
   * Gets detailed information about the server including packaging and deployment metadata.
   *
   * Returns extended server information with package details, remotes, and deployment configurations.
   * This information conforms to the MCP ServerDetail schema.
   *
   * @returns Detailed server information object
   *
   * @example
   * ```typescript
   * const detail = server.getServerDetail();
   * console.log(detail.package_canonical); // 'npm'
   * console.log(detail.packages); // Package installation info
   * ```
   */
  getServerDetail() {
    return {
      ...this.getServerInfo(),
      package_canonical: this.packageCanonical,
      packages: this.packages,
      remotes: this.remotes
    };
  }
  /**
   * Gets a list of all tools provided by this MCP server with their schemas.
   *
   * Returns information about all registered tools including explicit tools, agent-derived tools,
   * and workflow-derived tools. Includes input/output schemas and tool types.
   *
   * @returns Object containing array of tool information
   *
   * @example
   * ```typescript
   * const toolList = server.getToolListInfo();
   * toolList.tools.forEach(tool => {
   *   console.log(`${tool.name}: ${tool.description}`);
   *   console.log(`Type: ${tool.toolType || 'tool'}`);
   * });
   * ```
   */
  getToolListInfo() {
    this.logger.debug(`Getting tool list information for MCPServer '${this.name}'`);
    return {
      tools: Object.entries(this.convertedTools).map(([toolId, tool]) => ({
        id: toolId,
        name: tool.name,
        description: tool.description,
        inputSchema: tool.parameters?.jsonSchema || tool.parameters,
        outputSchema: tool.outputSchema?.jsonSchema || tool.outputSchema,
        toolType: tool.toolType
      }))
    };
  }
  /**
   * Gets information for a specific tool provided by this MCP server.
   *
   * Returns detailed information about a single tool including its name, description, schemas, and type.
   * Returns undefined if the tool is not found.
   *
   * @param toolId - The ID/name of the tool to retrieve
   * @returns Tool information object or undefined if not found
   *
   * @example
   * ```typescript
   * const toolInfo = server.getToolInfo('getWeather');
   * if (toolInfo) {
   *   console.log(toolInfo.description);
   *   console.log(toolInfo.inputSchema);
   * }
   * ```
   */
  getToolInfo(toolId) {
    const tool = this.convertedTools[toolId];
    if (!tool) {
      this.logger.debug(`Tool '${toolId}' not found on MCPServer '${this.name}'`);
      return void 0;
    }
    this.logger.debug(`Getting info for tool '${toolId}' on MCPServer '${this.name}'`);
    return {
      name: tool.name,
      description: tool.description,
      inputSchema: tool.parameters?.jsonSchema || tool.parameters,
      outputSchema: tool.outputSchema?.jsonSchema || tool.outputSchema,
      toolType: tool.toolType
    };
  }
  /**
   * Executes a specific tool provided by this MCP server.
   *
   * This method validates the tool arguments against the input schema and executes the tool.
   * If validation fails, returns an error object instead of throwing.
   *
   * @param toolId - The ID/name of the tool to execute
   * @param args - The arguments to pass to the tool's execute function
   * @param executionContext - Optional context including messages and toolCallId
   * @returns Promise resolving to the tool execution result
   * @throws {MastraError} If the tool is not found or execution fails
   *
   * @example
   * ```typescript
   * const result = await server.executeTool(
   *   'getWeather',
   *   { location: 'London' },
   *   { toolCallId: 'call_123' }
   * );
   * console.log(result);
   * ```
   */
  async executeTool(toolId, args, executionContext) {
    const tool = this.convertedTools[toolId];
    let validatedArgs = args;
    try {
      if (!tool) {
        this.logger.warn(`ExecuteTool: Unknown tool '${toolId}' requested on MCPServer '${this.name}'.`);
        throw new Error(`Unknown tool: ${toolId}`);
      }
      this.logger.debug(`ExecuteTool: Invoking '${toolId}' with arguments:`, args);
      if (tool.parameters instanceof z.ZodType && typeof tool.parameters.safeParse === "function") {
        const validation = tool.parameters.safeParse(args ?? {});
        if (!validation.success) {
          const errorMessages = validation.error.errors.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
          this.logger.warn(`ExecuteTool: Invalid tool arguments for '${toolId}': ${errorMessages}`, {
            errors: validation.error.format()
          });
          return {
            error: true,
            message: `Tool validation failed. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${JSON.stringify(args, null, 2)}`,
            validationErrors: validation.error.format()
          };
        }
        validatedArgs = validation.data;
      } else {
        this.logger.debug(
          `ExecuteTool: Tool '${toolId}' parameters is not a Zod schema with safeParse or is undefined. Skipping validation.`
        );
      }
      if (!tool.execute) {
        this.logger.error(`ExecuteTool: Tool '${toolId}' does not have an execute function.`);
        throw new Error(`Tool '${toolId}' cannot be executed.`);
      }
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_TOOL_EXECUTE_PREPARATION_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            toolId,
            args
          }
        },
        error
      );
      this.logger.trackException(mastraError);
      throw mastraError;
    }
    try {
      const finalExecutionContext = {
        messages: executionContext?.messages || [],
        toolCallId: executionContext?.toolCallId || randomUUID()
      };
      const result = await tool.execute(validatedArgs, finalExecutionContext);
      this.logger.info(`ExecuteTool: Tool '${toolId}' executed successfully.`);
      return result;
    } catch (error) {
      const mastraError = new MastraError(
        {
          id: "MCP_SERVER_TOOL_EXECUTE_FAILED",
          domain: ErrorDomain.MCP,
          category: ErrorCategory.USER,
          details: {
            toolId,
            validatedArgs
          }
        },
        error
      );
      this.logger.trackException(mastraError);
      this.logger.error(`ExecuteTool: Tool execution failed for '${toolId}':`, { error });
      throw mastraError;
    }
  }
};

export { MCPClient, MCPConfiguration, MCPServer, MastraMCPClient };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map