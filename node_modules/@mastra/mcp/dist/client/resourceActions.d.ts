import type { IMastraLogger } from '@mastra/core/logger';
import type { Resource, ResourceTemplate } from '@modelcontextprotocol/sdk/types.js';
import type { InternalMastraMCPClient } from './client.js';
interface ResourceClientActionsConfig {
    client: InternalMastraMCPClient;
    logger: IMastraLogger;
}
/**
 * Client-side resource actions for interacting with MCP server resources.
 *
 * Provides methods to list, read, subscribe to, and manage resources exposed by an MCP server.
 * Resources represent any kind of data that a server wants to make available (files, database
 * records, API responses, etc.).
 */
export declare class ResourceClientActions {
    private readonly client;
    private readonly logger;
    /**
     * @internal
     */
    constructor({ client, logger }: ResourceClientActionsConfig);
    /**
     * Retrieves all available resources from the connected MCP server.
     *
     * Returns an empty array if the server doesn't support resources (MethodNotFound error).
     *
     * @returns Promise resolving to array of resources
     * @throws {Error} If fetching resources fails (excluding MethodNotFound)
     *
     * @example
     * ```typescript
     * const resources = await client.resources.list();
     * resources.forEach(resource => {
     *   console.log(`${resource.name}: ${resource.uri}`);
     * });
     * ```
     */
    list(): Promise<Resource[]>;
    /**
     * Retrieves all available resource templates from the connected MCP server.
     *
     * Resource templates are URI templates (RFC 6570) that describe dynamic resources.
     * Returns an empty array if the server doesn't support resource templates.
     *
     * @returns Promise resolving to array of resource templates
     * @throws {Error} If fetching resource templates fails (excluding MethodNotFound)
     *
     * @example
     * ```typescript
     * const templates = await client.resources.templates();
     * templates.forEach(template => {
     *   console.log(`${template.name}: ${template.uriTemplate}`);
     * });
     * ```
     */
    templates(): Promise<ResourceTemplate[]>;
    /**
     * Reads the content of a specific resource from the MCP server.
     *
     * @param uri - URI of the resource to read (e.g., 'file://path/to/file.txt')
     * @returns Promise resolving to the resource content
     * @throws {Error} If reading the resource fails or resource not found
     *
     * @example
     * ```typescript
     * const result = await client.resources.read('file://data/config.json');
     * console.log(result.contents[0].text); // Resource text content
     * ```
     */
    read(uri: string): Promise<import("zod").objectOutputType<{
        _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
    } & {
        contents: import("zod").ZodArray<import("zod").ZodUnion<[import("zod").ZodObject<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            text: import("zod").ZodString;
        }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            text: import("zod").ZodString;
        }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            text: import("zod").ZodString;
        }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
        }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
        }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<{
            uri: import("zod").ZodString;
            mimeType: import("zod").ZodOptional<import("zod").ZodString>;
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        }, {
            blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
        }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
    }, import("zod").ZodTypeAny, "passthrough">>;
    /**
     * Subscribes to updates for a specific resource.
     *
     * After subscribing, you'll receive notifications via the `onUpdated` handler
     * when the resource content changes.
     *
     * @param uri - URI of the resource to subscribe to
     * @returns Promise resolving when subscription is established
     * @throws {Error} If subscription fails
     *
     * @example
     * ```typescript
     * await client.resources.subscribe('file://data/config.json');
     * ```
     */
    subscribe(uri: string): Promise<{}>;
    /**
     * Unsubscribes from updates for a specific resource.
     *
     * Stops receiving notifications for this resource URI.
     *
     * @param uri - URI of the resource to unsubscribe from
     * @returns Promise resolving when unsubscription is complete
     * @throws {Error} If unsubscription fails
     *
     * @example
     * ```typescript
     * await client.resources.unsubscribe('file://data/config.json');
     * ```
     */
    unsubscribe(uri: string): Promise<{}>;
    /**
     * Sets a notification handler for when subscribed resources are updated.
     *
     * The handler is called whenever the server sends a resource update notification
     * for any resource you've subscribed to.
     *
     * @param handler - Callback function receiving the updated resource URI
     *
     * @example
     * ```typescript
     * await client.resources.onUpdated(async (params) => {
     *   console.log(`Resource updated: ${params.uri}`);
     *   // Re-fetch the resource
     *   const content = await client.resources.read(params.uri);
     *   console.log('New content:', content);
     * });
     * ```
     */
    onUpdated(handler: (params: {
        uri: string;
    }) => void): Promise<void>;
    /**
     * Sets a notification handler for when the list of available resources changes.
     *
     * The handler is called when resources are added or removed from the server.
     *
     * @param handler - Callback function invoked when the resource list changes
     *
     * @example
     * ```typescript
     * await client.resources.onListChanged(async () => {
     *   console.log('Resource list changed, re-fetching...');
     *   const resources = await client.resources.list();
     *   console.log('Updated resource count:', resources.length);
     * });
     * ```
     */
    onListChanged(handler: () => void): Promise<void>;
}
export {};
//# sourceMappingURL=resourceActions.d.ts.map