import { MastraBase } from '@mastra/core/base';
import type { ElicitRequest, ElicitResult, Prompt, Resource, ResourceTemplate } from '@modelcontextprotocol/sdk/types.js';
import type { MastraMCPServerDefinition } from './client.js';
/**
 * Configuration options for creating an MCPClient instance.
 */
export interface MCPClientOptions {
    /** Optional unique identifier to prevent memory leaks when creating multiple instances with identical configurations */
    id?: string;
    /** Map of server names to their connection configurations (stdio or HTTP-based) */
    servers: Record<string, MastraMCPServerDefinition>;
    /** Optional global timeout in milliseconds for all servers (default: 60000ms) */
    timeout?: number;
}
/**
 * MCPClient manages multiple MCP server connections and their tools in a Mastra application.
 *
 * This class handles connection lifecycle, tool namespacing, and provides access to tools,
 * resources, prompts, and elicitation across all configured servers.
 *
 * @example
 * ```typescript
 * import { MCPClient } from '@mastra/mcp';
 * import { Agent } from '@mastra/core/agent';
 * import { openai } from '@ai-sdk/openai';
 *
 * const mcp = new MCPClient({
 *   servers: {
 *     weather: {
 *       url: new URL('http://localhost:8080/sse'),
 *     },
 *     stockPrice: {
 *       command: 'npx',
 *       args: ['tsx', 'stock-price.ts'],
 *       env: { API_KEY: 'your-api-key' },
 *     },
 *   },
 *   timeout: 30000,
 * });
 *
 * const agent = new Agent({
 *   name: 'Multi-tool Agent',
 *   instructions: 'You have access to multiple tools.',
 *   model: openai('gpt-4'),
 *   tools: await mcp.getTools(),
 * });
 * ```
 */
export declare class MCPClient extends MastraBase {
    private serverConfigs;
    private id;
    private defaultTimeout;
    private mcpClientsById;
    private disconnectPromise;
    /**
     * Creates a new MCPClient instance for managing MCP server connections.
     *
     * The client automatically manages connection lifecycle and prevents memory leaks by
     * caching instances with identical configurations.
     *
     * @param args - Configuration options
     * @param args.id - Optional unique identifier to allow multiple instances with same config
     * @param args.servers - Map of server names to server configurations
     * @param args.timeout - Optional global timeout in milliseconds (default: 60000)
     *
     * @throws {Error} If multiple instances with identical config are created without an ID
     *
     * @example
     * ```typescript
     * const mcp = new MCPClient({
     *   servers: {
     *     weatherServer: {
     *       url: new URL('http://localhost:8080/sse'),
     *       requestInit: {
     *         headers: { Authorization: 'Bearer token' }
     *       }
     *     }
     *   },
     *   timeout: 30000
     * });
     * ```
     */
    constructor(args: MCPClientOptions);
    /**
     * Provides access to elicitation-related operations for interactive user input collection.
     *
     * Elicitation allows MCP servers to request structured information from users during tool execution.
     *
     * @example
     * ```typescript
     * // Set up handler for elicitation requests from a server
     * await mcp.elicitation.onRequest('serverName', async (request) => {
     *   console.log(`Server requests: ${request.message}`);
     *   console.log('Schema:', request.requestedSchema);
     *
     *   // Collect user input and return response
     *   return {
     *     action: 'accept',
     *     content: { name: 'John Doe', email: 'john@example.com' }
     *   };
     * });
     * ```
     */
    get elicitation(): {
        /**
         * Sets up a handler function for elicitation requests from a specific server.
         *
         * The handler receives requests for user input and must return a response with
         * action ('accept', 'decline', or 'cancel') and optional content.
         *
         * @param serverName - Name of the server to handle elicitation requests for
         * @param handler - Function to handle elicitation requests
         * @throws {MastraError} If setting up the handler fails
         *
         * @example
         * ```typescript
         * await mcp.elicitation.onRequest('weatherServer', async (request) => {
         *   // Prompt user for input
         *   const userInput = await promptUser(request.requestedSchema);
         *   return { action: 'accept', content: userInput };
         * });
         * ```
         */
        onRequest: (serverName: string, handler: (request: ElicitRequest["params"]) => Promise<ElicitResult>) => Promise<void>;
    };
    /**
     * Provides access to resource-related operations across all configured servers.
     *
     * Resources represent data exposed by MCP servers (files, database records, API responses, etc.).
     *
     * @example
     * ```typescript
     * // List all resources from all servers
     * const allResources = await mcp.resources.list();
     * Object.entries(allResources).forEach(([serverName, resources]) => {
     *   console.log(`${serverName}: ${resources.length} resources`);
     * });
     *
     * // Read a specific resource
     * const content = await mcp.resources.read('weatherServer', 'file://data.json');
     *
     * // Subscribe to resource updates
     * await mcp.resources.subscribe('weatherServer', 'file://data.json');
     * await mcp.resources.onUpdated('weatherServer', async (params) => {
     *   console.log(`Resource updated: ${params.uri}`);
     * });
     * ```
     */
    get resources(): {
        /**
         * Lists all available resources from all configured servers.
         *
         * Returns a map of server names to their resource arrays. Errors for individual
         * servers are logged but don't throw - failed servers return empty arrays.
         *
         * @returns Promise resolving to object mapping server names to resource arrays
         *
         * @example
         * ```typescript
         * const resources = await mcp.resources.list();
         * console.log(resources.weatherServer); // Array of resources
         * ```
         */
        list: () => Promise<Record<string, Resource[]>>;
        /**
         * Lists all available resource templates from all configured servers.
         *
         * Resource templates are URI templates (RFC 6570) describing dynamic resources.
         * Errors for individual servers are logged but don't throw.
         *
         * @returns Promise resolving to object mapping server names to template arrays
         *
         * @example
         * ```typescript
         * const templates = await mcp.resources.templates();
         * console.log(templates.weatherServer); // Array of resource templates
         * ```
         */
        templates: () => Promise<Record<string, ResourceTemplate[]>>;
        /**
         * Reads the content of a specific resource from a server.
         *
         * @param serverName - Name of the server to read from
         * @param uri - URI of the resource to read
         * @returns Promise resolving to the resource content
         * @throws {MastraError} If reading the resource fails
         *
         * @example
         * ```typescript
         * const content = await mcp.resources.read('weatherServer', 'file://config.json');
         * console.log(content.contents[0].text);
         * ```
         */
        read: (serverName: string, uri: string) => Promise<import("zod").objectOutputType<{
            _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
        } & {
            contents: import("zod").ZodArray<import("zod").ZodUnion<[import("zod").ZodObject<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                text: import("zod").ZodString;
            }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                text: import("zod").ZodString;
            }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                text: import("zod").ZodString;
            }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
            }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
            }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<{
                uri: import("zod").ZodString;
                mimeType: import("zod").ZodOptional<import("zod").ZodString>;
                _meta: import("zod").ZodOptional<import("zod").ZodObject<{}, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{}, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{}, import("zod").ZodTypeAny, "passthrough">>>;
            }, {
                blob: import("zod").ZodEffects<import("zod").ZodString, string, string>;
            }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
        }, import("zod").ZodTypeAny, "passthrough">>;
        /**
         * Subscribes to updates for a specific resource on a server.
         *
         * @param serverName - Name of the server
         * @param uri - URI of the resource to subscribe to
         * @returns Promise resolving when subscription is established
         * @throws {MastraError} If subscription fails
         *
         * @example
         * ```typescript
         * await mcp.resources.subscribe('weatherServer', 'file://config.json');
         * ```
         */
        subscribe: (serverName: string, uri: string) => Promise<{}>;
        /**
         * Unsubscribes from updates for a specific resource on a server.
         *
         * @param serverName - Name of the server
         * @param uri - URI of the resource to unsubscribe from
         * @returns Promise resolving when unsubscription is complete
         * @throws {MastraError} If unsubscription fails
         *
         * @example
         * ```typescript
         * await mcp.resources.unsubscribe('weatherServer', 'file://config.json');
         * ```
         */
        unsubscribe: (serverName: string, uri: string) => Promise<{}>;
        /**
         * Sets a notification handler for when subscribed resources are updated on a server.
         *
         * @param serverName - Name of the server to monitor
         * @param handler - Callback function receiving the updated resource URI
         * @returns Promise resolving when handler is registered
         * @throws {MastraError} If setting up the handler fails
         *
         * @example
         * ```typescript
         * await mcp.resources.onUpdated('weatherServer', async (params) => {
         *   console.log(`Resource updated: ${params.uri}`);
         *   const content = await mcp.resources.read('weatherServer', params.uri);
         * });
         * ```
         */
        onUpdated: (serverName: string, handler: (params: {
            uri: string;
        }) => void) => Promise<void>;
        /**
         * Sets a notification handler for when the resource list changes on a server.
         *
         * @param serverName - Name of the server to monitor
         * @param handler - Callback function invoked when resources are added/removed
         * @returns Promise resolving when handler is registered
         * @throws {MastraError} If setting up the handler fails
         *
         * @example
         * ```typescript
         * await mcp.resources.onListChanged('weatherServer', async () => {
         *   console.log('Resource list changed, re-fetching...');
         *   const resources = await mcp.resources.list();
         * });
         * ```
         */
        onListChanged: (serverName: string, handler: () => void) => Promise<void>;
    };
    /**
     * Provides access to prompt-related operations across all configured servers.
     *
     * Prompts are reusable message templates exposed by MCP servers that can be parameterized
     * and used for AI interactions.
     *
     * @example
     * ```typescript
     * // List all prompts from all servers
     * const allPrompts = await mcp.prompts.list();
     * Object.entries(allPrompts).forEach(([serverName, prompts]) => {
     *   console.log(`${serverName}: ${prompts.map(p => p.name).join(', ')}`);
     * });
     *
     * // Get a specific prompt with arguments
     * const prompt = await mcp.prompts.get({
     *   serverName: 'weatherServer',
     *   name: 'forecast-template',
     *   args: { city: 'London', days: 7 }
     * });
     * ```
     */
    get prompts(): {
        /**
         * Lists all available prompts from all configured servers.
         *
         * Returns a map of server names to their prompt arrays. Errors for individual
         * servers are logged but don't throw - failed servers return empty arrays.
         *
         * @returns Promise resolving to object mapping server names to prompt arrays
         *
         * @example
         * ```typescript
         * const prompts = await mcp.prompts.list();
         * console.log(prompts.weatherServer); // Array of prompts
         * ```
         */
        list: () => Promise<Record<string, Prompt[]>>;
        /**
         * Retrieves a specific prompt with its messages from a server.
         *
         * @param params - Parameters for the prompt request
         * @param params.serverName - Name of the server to retrieve from
         * @param params.name - Name of the prompt to retrieve
         * @param params.args - Optional arguments to populate the prompt template
         * @param params.version - Optional specific version of the prompt
         * @returns Promise resolving to the prompt result with messages
         * @throws {MastraError} If fetching the prompt fails
         *
         * @example
         * ```typescript
         * const prompt = await mcp.prompts.get({
         *   serverName: 'weatherServer',
         *   name: 'forecast',
         *   args: { city: 'London' },
         *   version: '1.0'
         * });
         * console.log(prompt.messages);
         * ```
         */
        get: ({ serverName, name, args, version, }: {
            serverName: string;
            name: string;
            args?: Record<string, any>;
            version?: string;
        }) => Promise<{
            [x: string]: unknown;
            messages: {
                [x: string]: unknown;
                content: {
                    [x: string]: unknown;
                    type: "text";
                    text: string;
                    _meta?: {
                        [x: string]: unknown;
                    } | undefined;
                } | {
                    [x: string]: unknown;
                    type: "image";
                    data: string;
                    mimeType: string;
                    _meta?: {
                        [x: string]: unknown;
                    } | undefined;
                } | {
                    [x: string]: unknown;
                    type: "audio";
                    data: string;
                    mimeType: string;
                    _meta?: {
                        [x: string]: unknown;
                    } | undefined;
                } | {
                    [x: string]: unknown;
                    type: "resource_link";
                    name: string;
                    uri: string;
                    _meta?: {
                        [x: string]: unknown;
                    } | undefined;
                    title?: string | undefined;
                    description?: string | undefined;
                    mimeType?: string | undefined;
                } | {
                    [x: string]: unknown;
                    type: "resource";
                    resource: {
                        [x: string]: unknown;
                        text: string;
                        uri: string;
                        _meta?: {
                            [x: string]: unknown;
                        } | undefined;
                        mimeType?: string | undefined;
                    } | {
                        [x: string]: unknown;
                        uri: string;
                        blob: string;
                        _meta?: {
                            [x: string]: unknown;
                        } | undefined;
                        mimeType?: string | undefined;
                    };
                    _meta?: {
                        [x: string]: unknown;
                    } | undefined;
                };
                role: "user" | "assistant";
            }[];
            _meta?: {
                [x: string]: unknown;
            } | undefined;
            description?: string | undefined;
        }>;
        /**
         * Sets a notification handler for when the prompt list changes on a server.
         *
         * @param serverName - Name of the server to monitor
         * @param handler - Callback function invoked when prompts are added/removed/modified
         * @returns Promise resolving when handler is registered
         * @throws {MastraError} If setting up the handler fails
         *
         * @example
         * ```typescript
         * await mcp.prompts.onListChanged('weatherServer', async () => {
         *   console.log('Prompt list changed, re-fetching...');
         *   const prompts = await mcp.prompts.list();
         * });
         * ```
         */
        onListChanged: (serverName: string, handler: () => void) => Promise<void>;
    };
    private addToInstanceCache;
    private makeId;
    /**
     * Disconnects from all MCP servers and cleans up resources.
     *
     * This method gracefully closes all server connections and clears internal caches.
     * Safe to call multiple times - subsequent calls will wait for the first disconnect to complete.
     *
     * @example
     * ```typescript
     * // Cleanup on application shutdown
     * process.on('SIGTERM', async () => {
     *   await mcp.disconnect();
     *   process.exit(0);
     * });
     * ```
     */
    disconnect(): Promise<void>;
    /**
     * Retrieves all tools from all configured servers with namespaced names.
     *
     * Tool names are namespaced as `serverName_toolName` to prevent conflicts between servers.
     * This method is intended to be passed directly to an Agent definition.
     *
     * @returns Object mapping namespaced tool names to tool implementations
     * @throws {MastraError} If retrieving tools fails
     *
     * @example
     * ```typescript
     * const agent = new Agent({
     *   name: 'Multi-tool Agent',
     *   instructions: 'You have access to weather and stock tools.',
     *   model: openai('gpt-4'),
     *   tools: await mcp.getTools(), // weather_getWeather, stockPrice_getPrice
     * });
     * ```
     */
    getTools(): Promise<Record<string, any>>;
    /**
     * Returns toolsets organized by server name for dynamic tool injection.
     *
     * Unlike getTools(), this returns tools grouped by server without namespacing.
     * This is intended to be passed dynamically to the generate() or stream() method.
     *
     * @returns Object mapping server names to their tool collections
     * @throws {MastraError} If retrieving toolsets fails
     *
     * @example
     * ```typescript
     * const agent = new Agent({
     *   name: 'Dynamic Agent',
     *   instructions: 'You can use tools dynamically.',
     *   model: openai('gpt-4'),
     * });
     *
     * const response = await agent.stream(prompt, {
     *   toolsets: await mcp.getToolsets(), // { weather: {...}, stockPrice: {...} }
     * });
     * ```
     */
    getToolsets(): Promise<Record<string, Record<string, any>>>;
    /**
     * @deprecated all resource actions have been moved to the this.resources object. Use this.resources.list() instead.
     */
    getResources(): Promise<Record<string, {
        [x: string]: unknown;
        name: string;
        uri: string;
        _meta?: {
            [x: string]: unknown;
        } | undefined;
        title?: string | undefined;
        description?: string | undefined;
        mimeType?: string | undefined;
    }[]>>;
    /**
     * Gets current session IDs for all connected MCP clients using Streamable HTTP transport.
     *
     * Returns an object mapping server names to their session IDs. Only includes servers
     * that are currently connected via Streamable HTTP transport.
     *
     * @returns Object mapping server names to session IDs
     *
     * @example
     * ```typescript
     * const sessions = mcp.sessionIds;
     * console.log(sessions);
     * // { weatherServer: 'abc-123', stockServer: 'def-456' }
     * ```
     */
    get sessionIds(): Record<string, string>;
    private getConnectedClient;
    private getConnectedClientForServer;
    private eachClientTools;
}
/**
 * @deprecated MCPConfigurationOptions is deprecated and will be removed in a future release. Use {@link MCPClientOptions} instead.
 *
 * This interface has been renamed to MCPClientOptions. The API is identical.
 */
export interface MCPConfigurationOptions {
    /** @deprecated Use MCPClientOptions.id instead */
    id?: string;
    /** @deprecated Use MCPClientOptions.servers instead */
    servers: Record<string, MastraMCPServerDefinition>;
    /** @deprecated Use MCPClientOptions.timeout instead */
    timeout?: number;
}
/**
 * @deprecated MCPConfiguration is deprecated and will be removed in a future release. Use {@link MCPClient} instead.
 *
 * This class has been renamed to MCPClient. The API is identical but the class name changed
 * for clarity and consistency.
 *
 * @example
 * ```typescript
 * // Old way (deprecated)
 * const config = new MCPConfiguration({
 *   servers: { myServer: { command: 'npx', args: ['tsx', 'server.ts'] } }
 * });
 *
 * // New way (recommended)
 * const client = new MCPClient({
 *   servers: { myServer: { command: 'npx', args: ['tsx', 'server.ts'] } }
 * });
 * ```
 */
export declare class MCPConfiguration extends MCPClient {
    /**
     * @deprecated Use MCPClient constructor instead
     */
    constructor(args: MCPClientOptions);
}
//# sourceMappingURL=configuration.d.ts.map