import { MastraBase } from '@mastra/core/base';
import type { RuntimeContext } from '@mastra/core/di';
import type { SSEClientTransportOptions } from '@modelcontextprotocol/sdk/client/sse.js';
import type { StreamableHTTPClientTransportOptions } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
import type { ClientCapabilities, ElicitRequest, ElicitResult, GetPromptResult, ListPromptsResult, LoggingLevel } from '@modelcontextprotocol/sdk/types.js';
import { ResourceUpdatedNotificationSchema } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { ElicitationClientActions } from './elicitationActions.js';
import { PromptClientActions } from './promptActions.js';
import { ResourceClientActions } from './resourceActions.js';
export type { LoggingLevel } from '@modelcontextprotocol/sdk/types.js';
/**
 * Log message structure for MCP client logging.
 */
export interface LogMessage {
    /** Logging level (debug, info, warning, error, etc.) */
    level: LoggingLevel;
    /** Log message content */
    message: string;
    /** Timestamp when the log was created */
    timestamp: Date;
    /** Name of the MCP server that generated the log */
    serverName: string;
    /** Optional additional details */
    details?: Record<string, any>;
    runtimeContext?: RuntimeContext | null;
}
/**
 * Handler function for processing log messages from MCP servers.
 */
export type LogHandler = (logMessage: LogMessage) => void;
/**
 * Handler function for processing elicitation requests from MCP servers.
 *
 * @param request - The elicitation request parameters including message and schema
 * @returns Promise resolving to the user's response (accept/decline/cancel with optional content)
 */
export type ElicitationHandler = (request: ElicitRequest['params']) => Promise<ElicitResult>;
/**
 * Base options common to all MCP server definitions.
 */
type BaseServerOptions = {
    /** Optional handler for server log messages */
    logger?: LogHandler;
    /** Optional timeout in milliseconds for server operations */
    timeout?: number;
    /** Optional client capabilities to advertise to the server */
    capabilities?: ClientCapabilities;
    /** Whether to enable server log forwarding (default: true) */
    enableServerLogs?: boolean;
};
/**
 * Configuration for MCP servers using stdio (subprocess) transport.
 *
 * Used when the MCP server is spawned as a subprocess that communicates via stdin/stdout.
 */
type StdioServerDefinition = BaseServerOptions & {
    /** Command to execute (e.g., 'node', 'python', 'npx') */
    command: string;
    /** Optional arguments to pass to the command */
    args?: string[];
    /** Optional environment variables for the subprocess */
    env?: Record<string, string>;
    url?: never;
    requestInit?: never;
    eventSourceInit?: never;
    authProvider?: never;
    reconnectionOptions?: never;
    sessionId?: never;
};
/**
 * Configuration for MCP servers using HTTP-based transport (Streamable HTTP or SSE fallback).
 *
 * Used when connecting to remote MCP servers over HTTP. The client will attempt Streamable HTTP
 * transport first and fall back to SSE if that fails.
 */
type HttpServerDefinition = BaseServerOptions & {
    /** URL of the MCP server endpoint */
    url: URL;
    command?: never;
    args?: never;
    env?: never;
    /** Optional request configuration for HTTP requests */
    requestInit?: StreamableHTTPClientTransportOptions['requestInit'];
    /** Optional configuration for SSE fallback (required when using custom headers with SSE) */
    eventSourceInit?: SSEClientTransportOptions['eventSourceInit'];
    /** Optional authentication provider for HTTP requests */
    authProvider?: StreamableHTTPClientTransportOptions['authProvider'];
    /** Optional reconnection configuration for Streamable HTTP */
    reconnectionOptions?: StreamableHTTPClientTransportOptions['reconnectionOptions'];
    /** Optional session ID for Streamable HTTP */
    sessionId?: StreamableHTTPClientTransportOptions['sessionId'];
};
/**
 * Configuration for connecting to an MCP server.
 *
 * Either stdio-based (subprocess) or HTTP-based (remote server). The transport type is
 * automatically detected based on whether `command` or `url` is provided.
 *
 * @example
 * ```typescript
 * // Stdio server
 * const stdioServer: MastraMCPServerDefinition = {
 *   command: 'npx',
 *   args: ['tsx', 'server.ts'],
 *   env: { API_KEY: 'secret' }
 * };
 *
 * // HTTP server
 * const httpServer: MastraMCPServerDefinition = {
 *   url: new URL('http://localhost:8080/mcp'),
 *   requestInit: {
 *     headers: { Authorization: 'Bearer token' }
 *   }
 * };
 * ```
 */
export type MastraMCPServerDefinition = StdioServerDefinition | HttpServerDefinition;
/**
 * Options for creating an internal MCP client instance.
 *
 * @internal
 */
export type InternalMastraMCPClientOptions = {
    /** Name identifier for this client */
    name: string;
    /** Server connection configuration */
    server: MastraMCPServerDefinition;
    /** Optional client capabilities */
    capabilities?: ClientCapabilities;
    /** Optional client version */
    version?: string;
    /** Optional timeout in milliseconds */
    timeout?: number;
};
/**
 * Internal MCP client implementation for connecting to a single MCP server.
 *
 * This class handles the low-level connection, transport management, and protocol
 * communication with an MCP server. Most users should use MCPClient instead.
 *
 * @internal
 */
export declare class InternalMastraMCPClient extends MastraBase {
    name: string;
    private client;
    private readonly timeout;
    private logHandler?;
    private enableServerLogs?;
    private serverConfig;
    private transport?;
    private currentOperationContext;
    /** Provides access to resource operations (list, read, subscribe, etc.) */
    readonly resources: ResourceClientActions;
    /** Provides access to prompt operations (list, get, notifications) */
    readonly prompts: PromptClientActions;
    /** Provides access to elicitation operations (request handling) */
    readonly elicitation: ElicitationClientActions;
    /**
     * @internal
     */
    constructor({ name, version, server, capabilities, timeout, }: InternalMastraMCPClientOptions);
    /**
     * Log a message at the specified level
     * @param level Log level
     * @param message Log message
     * @param details Optional additional details
     */
    private log;
    private setupLogging;
    private connectStdio;
    private connectHttp;
    private isConnected;
    /**
     * Connects to the MCP server using the configured transport.
     *
     * Automatically detects transport type based on configuration (stdio vs HTTP).
     * Safe to call multiple times - returns existing connection if already connected.
     *
     * @returns Promise resolving to true when connected
     * @throws {MastraError} If connection fails
     *
     * @internal
     */
    connect(): Promise<boolean>;
    /**
     * Gets the current session ID if using Streamable HTTP transport.
     *
     * Returns undefined if not connected or not using Streamable HTTP transport.
     *
     * @returns Session ID string or undefined
     *
     * @internal
     */
    get sessionId(): string | undefined;
    disconnect(): Promise<void>;
    listResources(): Promise<z.objectOutputType<{
        _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
    } & {
        nextCursor: z.ZodOptional<z.ZodString>;
    } & {
        resources: z.ZodArray<z.ZodObject<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uri: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uri: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uri: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, z.ZodTypeAny, "passthrough">>, "many">;
    }, z.ZodTypeAny, "passthrough">>;
    readResource(uri: string): Promise<z.objectOutputType<{
        _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
    } & {
        contents: z.ZodArray<z.ZodUnion<[z.ZodObject<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            text: z.ZodString;
        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            text: z.ZodString;
        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            text: z.ZodString;
        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            blob: z.ZodEffects<z.ZodString, string, string>;
        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            blob: z.ZodEffects<z.ZodString, string, string>;
        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
            uri: z.ZodString;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }, {
            blob: z.ZodEffects<z.ZodString, string, string>;
        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
    }, z.ZodTypeAny, "passthrough">>;
    subscribeResource(uri: string): Promise<{}>;
    unsubscribeResource(uri: string): Promise<{}>;
    listResourceTemplates(): Promise<z.objectOutputType<{
        _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
    } & {
        nextCursor: z.ZodOptional<z.ZodString>;
    } & {
        resourceTemplates: z.ZodArray<z.ZodObject<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uriTemplate: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uriTemplate: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<{
            name: z.ZodString;
            title: z.ZodOptional<z.ZodString>;
        }, {
            uriTemplate: z.ZodString;
            description: z.ZodOptional<z.ZodString>;
            mimeType: z.ZodOptional<z.ZodString>;
            _meta: z.ZodOptional<z.ZodObject<{}, "passthrough", z.ZodTypeAny, z.objectOutputType<{}, z.ZodTypeAny, "passthrough">, z.objectInputType<{}, z.ZodTypeAny, "passthrough">>>;
        }>, z.ZodTypeAny, "passthrough">>, "many">;
    }, z.ZodTypeAny, "passthrough">>;
    /**
     * Fetch the list of available prompts from the MCP server.
     */
    listPrompts(): Promise<ListPromptsResult>;
    /**
     * Get a prompt and its dynamic messages from the server.
     * @param name The prompt name
     * @param args Arguments for the prompt
     * @param version (optional) The prompt version to retrieve
     */
    getPrompt({ name, args, version, }: {
        name: string;
        args?: Record<string, any>;
        version?: string;
    }): Promise<GetPromptResult>;
    /**
     * Register a handler to be called when the prompt list changes on the server.
     * Use this to refresh cached prompt lists in the client/UI if needed.
     */
    setPromptListChangedNotificationHandler(handler: () => void): void;
    setResourceUpdatedNotificationHandler(handler: (params: z.infer<typeof ResourceUpdatedNotificationSchema>['params']) => void): void;
    setResourceListChangedNotificationHandler(handler: () => void): void;
    setElicitationRequestHandler(handler: ElicitationHandler): void;
    private convertInputSchema;
    private convertOutputSchema;
    tools(): Promise<Record<string, any>>;
}
/**
 * @deprecated MastraMCPClient is deprecated and will be removed in a future release. Please use MCPClient instead.
 */
export declare class MastraMCPClient extends InternalMastraMCPClient {
    constructor(args: InternalMastraMCPClientOptions);
}
//# sourceMappingURL=client.d.ts.map