import { sanitizeBody, validateBody } from './chunk-4QCXUEAT.js';
import { stringify } from './chunk-LF2ZLOFP.js';
import { handleError } from './chunk-CY4TP3FK.js';
import { HTTPException } from './chunk-MMROOK5J.js';
import { __export } from './chunk-PR4QN5HX.js';
import { PROVIDER_REGISTRY } from '@mastra/core/llm';
import { RuntimeContext } from '@mastra/core/runtime-context';
import { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';

// src/server/handlers/agents.ts
var agents_exports = {};
__export(agents_exports, {
  approveToolCallHandler: () => approveToolCallHandler,
  declineToolCallHandler: () => declineToolCallHandler,
  generateHandler: () => generateHandler,
  generateLegacyHandler: () => generateLegacyHandler,
  getAgentByIdHandler: () => getAgentByIdHandler,
  getAgentsHandler: () => getAgentsHandler,
  getEvalsByAgentIdHandler: () => getEvalsByAgentIdHandler,
  getLiveEvalsByAgentIdHandler: () => getLiveEvalsByAgentIdHandler,
  getProvidersHandler: () => getProvidersHandler,
  getSerializedAgentTools: () => getSerializedAgentTools,
  getSerializedProcessors: () => getSerializedProcessors,
  reorderAgentModelListHandler: () => reorderAgentModelListHandler,
  streamGenerateHandler: () => streamGenerateHandler,
  streamGenerateLegacyHandler: () => streamGenerateLegacyHandler,
  streamNetworkHandler: () => streamNetworkHandler,
  streamUIMessageHandler: () => streamUIMessageHandler,
  updateAgentModelHandler: () => updateAgentModelHandler,
  updateAgentModelInModelListHandler: () => updateAgentModelInModelListHandler
});
async function getSerializedAgentTools(tools) {
  return Object.entries(tools || {}).reduce((acc, [key, tool]) => {
    const _tool = tool;
    const toolId = _tool.id ?? `tool-${key}`;
    let inputSchemaForReturn = void 0;
    if (_tool.inputSchema) {
      if (_tool.inputSchema && typeof _tool.inputSchema === "object" && "jsonSchema" in _tool.inputSchema) {
        inputSchemaForReturn = stringify(_tool.inputSchema.jsonSchema);
      } else if (_tool.inputSchema) {
        inputSchemaForReturn = stringify(zodToJsonSchema(_tool.inputSchema));
      }
    }
    let outputSchemaForReturn = void 0;
    if (_tool.outputSchema) {
      if (_tool.outputSchema && typeof _tool.outputSchema === "object" && "jsonSchema" in _tool.outputSchema) {
        outputSchemaForReturn = stringify(_tool.outputSchema.jsonSchema);
      } else if (_tool.outputSchema) {
        outputSchemaForReturn = stringify(zodToJsonSchema(_tool.outputSchema));
      }
    }
    acc[key] = {
      ..._tool,
      id: toolId,
      inputSchema: inputSchemaForReturn,
      outputSchema: outputSchemaForReturn
    };
    return acc;
  }, {});
}
function getSerializedProcessors(processors) {
  return processors.map((processor) => {
    return {
      name: processor.name || processor.constructor.name
    };
  });
}
async function getSerializedAgentDefinition({
  agent,
  runtimeContext
}) {
  let serializedAgentAgents = {};
  if ("listAgents" in agent) {
    const agents = await agent.listAgents({ runtimeContext });
    serializedAgentAgents = Object.entries(agents || {}).reduce(
      (acc, [key, agent2]) => {
        return {
          ...acc,
          [key]: { id: agent2.id, name: agent2.name }
        };
      },
      {}
    );
  }
  return serializedAgentAgents;
}
async function formatAgentList({
  id,
  mastra,
  agent,
  runtimeContext
}) {
  const instructions = await agent.getInstructions({ runtimeContext });
  const tools = await agent.getTools({ runtimeContext });
  const llm = await agent.getLLM({ runtimeContext });
  const defaultGenerateOptions = await agent.getDefaultGenerateOptions({ runtimeContext });
  const defaultStreamOptions = await agent.getDefaultStreamOptions({ runtimeContext });
  const serializedAgentTools = await getSerializedAgentTools(tools);
  let serializedAgentWorkflows = {};
  if ("getWorkflows" in agent) {
    const logger = mastra.getLogger();
    try {
      const workflows = await agent.getWorkflows({ runtimeContext });
      serializedAgentWorkflows = Object.entries(workflows || {}).reduce((acc, [key, workflow]) => {
        return {
          ...acc,
          [key]: {
            name: workflow.name || "Unnamed workflow"
          }
        };
      }, {});
    } catch (error) {
      logger.error("Error getting workflows for agent", { agentName: agent.name, error });
    }
  }
  const serializedAgentAgents = await getSerializedAgentDefinition({ agent, runtimeContext });
  const inputProcessors = await agent.getInputProcessors(runtimeContext);
  const outputProcessors = await agent.getOutputProcessors(runtimeContext);
  const serializedInputProcessors = getSerializedProcessors(inputProcessors);
  const serializedOutputProcessors = getSerializedProcessors(outputProcessors);
  const model = llm?.getModel();
  const models = await agent.getModelList(runtimeContext);
  const modelList = models?.map((md) => ({
    ...md,
    model: {
      modelId: md.model.modelId,
      provider: md.model.provider,
      modelVersion: md.model.specificationVersion
    }
  }));
  return {
    id,
    name: agent.name,
    instructions,
    agents: serializedAgentAgents,
    tools: serializedAgentTools,
    workflows: serializedAgentWorkflows,
    inputProcessors: serializedInputProcessors,
    outputProcessors: serializedOutputProcessors,
    provider: llm?.getProvider(),
    modelId: llm?.getModelId(),
    modelVersion: model?.specificationVersion,
    defaultGenerateOptions,
    defaultStreamOptions,
    modelList
  };
}
async function getAgentsHandler({
  mastra,
  runtimeContext
}) {
  try {
    const agents = mastra.getAgents();
    const serializedAgentsMap = await Promise.all(
      Object.entries(agents).map(async ([id, agent]) => {
        return formatAgentList({ id, mastra, agent, runtimeContext });
      })
    );
    const serializedAgents = serializedAgentsMap.reduce((acc, { id, ...rest }) => {
      acc[id] = rest;
      return acc;
    }, {});
    return serializedAgents;
  } catch (error) {
    return handleError(error, "Error getting agents");
  }
}
async function formatAgent({
  mastra,
  agent,
  runtimeContext,
  isPlayground
}) {
  const tools = await agent.getTools({ runtimeContext });
  const serializedAgentTools = await getSerializedAgentTools(tools);
  let serializedAgentWorkflows = {};
  if ("getWorkflows" in agent) {
    const logger = mastra.getLogger();
    try {
      const workflows = await agent.getWorkflows({ runtimeContext });
      serializedAgentWorkflows = Object.entries(workflows || {}).reduce((acc, [key, workflow]) => {
        return {
          ...acc,
          [key]: {
            name: workflow.name || "Unnamed workflow",
            steps: Object.entries(workflow.steps).reduce(
              (acc2, [key2, step]) => {
                return {
                  ...acc2,
                  [key2]: {
                    id: step.id,
                    description: step.description
                  }
                };
              },
              {}
            )
          }
        };
      }, {});
    } catch (error) {
      logger.error("Error getting workflows for agent", { agentName: agent.name, error });
    }
  }
  let proxyRuntimeContext = runtimeContext;
  if (isPlayground) {
    proxyRuntimeContext = new Proxy(runtimeContext, {
      get(target, prop) {
        if (prop === "get") {
          return function(key) {
            const value = target.get(key);
            return value ?? `<${key}>`;
          };
        }
        return Reflect.get(target, prop);
      }
    });
  }
  const instructions = await agent.getInstructions({ runtimeContext: proxyRuntimeContext });
  const llm = await agent.getLLM({ runtimeContext });
  const defaultGenerateOptions = await agent.getDefaultGenerateOptions({ runtimeContext: proxyRuntimeContext });
  const defaultStreamOptions = await agent.getDefaultStreamOptions({ runtimeContext: proxyRuntimeContext });
  const model = llm?.getModel();
  const models = await agent.getModelList(runtimeContext);
  const modelList = models?.map((md) => ({
    ...md,
    model: {
      modelId: md.model.modelId,
      provider: md.model.provider,
      modelVersion: md.model.specificationVersion
    }
  }));
  const serializedAgentAgents = await getSerializedAgentDefinition({ agent, runtimeContext: proxyRuntimeContext });
  const inputProcessors = await agent.getInputProcessors(proxyRuntimeContext);
  const outputProcessors = await agent.getOutputProcessors(proxyRuntimeContext);
  const serializedInputProcessors = getSerializedProcessors(inputProcessors);
  const serializedOutputProcessors = getSerializedProcessors(outputProcessors);
  return {
    name: agent.name,
    instructions,
    tools: serializedAgentTools,
    agents: serializedAgentAgents,
    workflows: serializedAgentWorkflows,
    inputProcessors: serializedInputProcessors,
    outputProcessors: serializedOutputProcessors,
    provider: llm?.getProvider(),
    modelId: llm?.getModelId(),
    modelVersion: model?.specificationVersion,
    modelList,
    defaultGenerateOptions,
    defaultStreamOptions
  };
}
async function getAgentByIdHandler({
  mastra,
  runtimeContext,
  agentId,
  isPlayground = false
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    return formatAgent({ mastra, agent, runtimeContext, isPlayground });
  } catch (error) {
    return handleError(error, "Error getting agent");
  }
}
async function getEvalsByAgentIdHandler({
  mastra,
  runtimeContext,
  agentId
}) {
  try {
    const agent = mastra.getAgent(agentId);
    const evals = await mastra.getStorage()?.getEvalsByAgentName?.(agent.name, "test") || [];
    const instructions = await agent.getInstructions({ runtimeContext });
    return {
      id: agentId,
      name: agent.name,
      instructions,
      evals
    };
  } catch (error) {
    return handleError(error, "Error getting test evals");
  }
}
async function getLiveEvalsByAgentIdHandler({
  mastra,
  runtimeContext,
  agentId
}) {
  try {
    const agent = mastra.getAgent(agentId);
    const evals = await mastra.getStorage()?.getEvalsByAgentName?.(agent.name, "live") || [];
    const instructions = await agent.getInstructions({ runtimeContext });
    return {
      id: agentId,
      name: agent.name,
      instructions,
      evals
    };
  } catch (error) {
    return handleError(error, "Error getting live evals");
  }
}
async function generateLegacyHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { messages, resourceId, resourceid, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalResourceId = resourceId ?? resourceid;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const result = await agent.generateLegacy(messages, {
      ...rest,
      abortSignal,
      // @ts-expect-error TODO fix types
      resourceId: finalResourceId,
      runtimeContext: finalRuntimeContext
    });
    return result;
  } catch (error) {
    return handleError(error, "Error generating from agent");
  }
}
async function generateHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { messages, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const result = await agent.generate(messages, {
      ...rest,
      runtimeContext: finalRuntimeContext,
      format: rest.format || "mastra",
      abortSignal
    });
    return result;
  } catch (error) {
    return handleError(error, "Error generating from agent");
  }
}
async function streamGenerateLegacyHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const { messages, resourceId, resourceid, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalResourceId = resourceId ?? resourceid;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const streamResult = await agent.streamLegacy(messages, {
      ...rest,
      abortSignal,
      // @ts-expect-error TODO fix types
      resourceId: finalResourceId,
      runtimeContext: finalRuntimeContext
    });
    const streamResponse = rest.output ? streamResult.toTextStreamResponse({
      headers: {
        "Transfer-Encoding": "chunked"
      }
    }) : streamResult.toDataStreamResponse({
      sendUsage: true,
      sendReasoning: true,
      getErrorMessage: (error) => {
        return `An error occurred while processing your request. ${error instanceof Error ? error.message : JSON.stringify(error)}`;
      },
      headers: {
        "Transfer-Encoding": "chunked"
      }
    });
    return streamResponse;
  } catch (error) {
    return handleError(error, "error streaming agent response");
  }
}
function streamGenerateHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { messages, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const streamResult = agent.stream(messages, {
      ...rest,
      runtimeContext: finalRuntimeContext,
      abortSignal,
      format: body.format ?? "mastra"
    });
    return streamResult;
  } catch (error) {
    return handleError(error, "error streaming agent response");
  }
}
function approveToolCallHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { runId, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    const streamResult = agent.approveToolCall({
      ...rest,
      runId,
      runtimeContext: finalRuntimeContext,
      abortSignal,
      format: body.format ?? "mastra"
    });
    return streamResult;
  } catch (error) {
    return handleError(error, "error streaming agent response");
  }
}
function declineToolCallHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { runId, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    const streamResult = agent.declineToolCall({
      ...rest,
      runId,
      runtimeContext: finalRuntimeContext,
      abortSignal,
      format: body.format ?? "mastra"
    });
    return streamResult;
  } catch (error) {
    return handleError(error, "error streaming agent response");
  }
}
function streamNetworkHandler({
  mastra,
  runtimeContext,
  agentId,
  body
  // abortSignal,
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { messages, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const streamResult = agent.network(messages, {
      ...rest,
      memory: {
        thread: rest.thread ?? "",
        resource: rest.resourceId ?? ""
      },
      runtimeContext: finalRuntimeContext
    });
    return streamResult;
  } catch (error) {
    return handleError(error, "error streaming agent loop response");
  }
}
async function streamUIMessageHandler({
  mastra,
  runtimeContext,
  agentId,
  body,
  abortSignal
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    sanitizeBody(body, ["tools"]);
    const { messages, runtimeContext: agentRuntimeContext, ...rest } = body;
    const finalRuntimeContext = new RuntimeContext([
      ...Array.from(runtimeContext.entries()),
      ...Array.from(Object.entries(agentRuntimeContext ?? {}))
    ]);
    validateBody({ messages });
    const streamResult = await agent.stream(messages, {
      ...rest,
      runtimeContext: finalRuntimeContext,
      abortSignal,
      format: "aisdk"
    });
    return streamResult.toUIMessageStreamResponse();
  } catch (error) {
    return handleError(error, "error streaming agent response");
  }
}
async function updateAgentModelHandler({
  mastra,
  agentId,
  body
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const { modelId, provider } = body;
    const newModel = `${provider}/${modelId}`;
    agent.__updateModel({ model: newModel });
    return { message: "Agent model updated" };
  } catch (error) {
    return handleError(error, "error updating agent model");
  }
}
async function reorderAgentModelListHandler({
  mastra,
  agentId,
  body
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const modelList = await agent.getModelList();
    if (!modelList || modelList.length === 0) {
      throw new HTTPException(400, { message: "Agent model list is not found or empty" });
    }
    agent.reorderModels(body.reorderedModelIds);
    return { message: "Model list reordered" };
  } catch (error) {
    return handleError(error, "error reordering model list");
  }
}
async function updateAgentModelInModelListHandler({
  mastra,
  agentId,
  modelConfigId,
  body
}) {
  try {
    const agent = mastra.getAgent(agentId);
    if (!agent) {
      throw new HTTPException(404, { message: "Agent not found" });
    }
    const { model: bodyModel, maxRetries, enabled } = body;
    if (!modelConfigId) {
      throw new HTTPException(400, { message: "Model id is required" });
    }
    const modelList = await agent.getModelList();
    if (!modelList || modelList.length === 0) {
      throw new HTTPException(400, { message: "Agent model list is not found or empty" });
    }
    const modelToUpdate = modelList.find((m) => m.id === modelConfigId);
    if (!modelToUpdate) {
      throw new HTTPException(400, { message: "Model to update is not found in agent model list" });
    }
    let model;
    if (bodyModel) {
      const { modelId, provider } = bodyModel;
      model = `${provider}/${modelId}`;
    }
    agent.updateModelInModelList({ id: modelConfigId, model, maxRetries, enabled });
    return { message: "Model list updated" };
  } catch (error) {
    return handleError(error, "error updating model list");
  }
}
async function getProvidersHandler() {
  try {
    const providers = Object.entries(PROVIDER_REGISTRY).map(([id, provider]) => {
      const envVars = Array.isArray(provider.apiKeyEnvVar) ? provider.apiKeyEnvVar : [provider.apiKeyEnvVar];
      const connected = envVars.every((envVar) => !!process.env[envVar]);
      return {
        id,
        name: provider.name,
        envVar: provider.apiKeyEnvVar,
        connected,
        docUrl: provider.docUrl,
        models: [...provider.models]
        // Convert readonly array to regular array
      };
    });
    return { providers };
  } catch (error) {
    return handleError(error, "error fetching providers");
  }
}

export { agents_exports, approveToolCallHandler, declineToolCallHandler, generateHandler, generateLegacyHandler, getAgentByIdHandler, getAgentsHandler, getEvalsByAgentIdHandler, getLiveEvalsByAgentIdHandler, getProvidersHandler, getSerializedAgentTools, getSerializedProcessors, reorderAgentModelListHandler, streamGenerateHandler, streamGenerateLegacyHandler, streamNetworkHandler, streamUIMessageHandler, updateAgentModelHandler, updateAgentModelInModelListHandler };
//# sourceMappingURL=chunk-LV66LYKV.js.map
//# sourceMappingURL=chunk-LV66LYKV.js.map