{"version":3,"sources":["../src/build/plugins/node-modules-extension-resolver.ts","../src/build/watcher.ts","../src/build/babel/remove-all-options-server.ts","../src/build/serverOptions.ts"],"names":["builtinModules","resolveFrom","extname","pathToFileURL","resolved","getPackageName","dirname","getInputOptions","pkg","slash","getWorkspaceInformation","analyzeBundle","posix","noopLogger","tsConfigPaths","aliasHono","watch","removeAllOptionsFromMastraExcept","extractMastraOption"],"mappings":"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","file":"chunk-4JSGBXG4.cjs","sourcesContent":["import { dirname, extname } from 'path';\nimport { pathToFileURL } from 'node:url';\nimport resolveFrom from 'resolve-from';\nimport type { Plugin } from 'rollup';\nimport { builtinModules } from 'node:module';\nimport { getPackageName } from '../utils';\n\n/**\n * Check if a module is a Node.js builtin module\n * @param specifier - Module specifier\n * @returns True if it's a builtin module\n */\nfunction isBuiltinModule(specifier: string): boolean {\n  return (\n    builtinModules.includes(specifier) ||\n    specifier.startsWith('node:') ||\n    builtinModules.includes(specifier.replace(/^node:/, ''))\n  );\n}\n\nfunction safeResolve(id: string, importer: string) {\n  try {\n    return resolveFrom(importer, id);\n  } catch {\n    return null;\n  }\n}\n\n// we only need this for dev, so we can resolve the js extension of the module as we do not use node-resolve\nexport function nodeModulesExtensionResolver(): Plugin {\n  return {\n    name: 'node-modules-extension-resolver',\n    resolveId(id, importer) {\n      // if is relative, skip\n      if (id.startsWith('.') || id.startsWith('/') || !importer) {\n        return null;\n      }\n\n      if (isBuiltinModule(id)) {\n        return null;\n      }\n\n      // if it's a scoped direct import skip\n      if (id.startsWith('@') && id.split('/').length === 2) {\n        return null;\n      }\n\n      // if it's a direct import, skip\n      if (!id.startsWith('@') && id.split('/').length === 1) {\n        return null;\n      }\n\n      const foundExt = extname(id);\n      if (foundExt) {\n        return null;\n      }\n\n      try {\n        // if we cannot resolve it, it means it's a legacy module\n        const resolved = import.meta.resolve(id);\n\n        if (!extname(resolved)) {\n          throw new Error(`Cannot resolve ${id} from ${importer}`);\n        }\n\n        return null;\n      } catch (e) {\n        // try to do a node like resolve first\n        const resolved = safeResolve(id, importer);\n        if (resolved) {\n          return {\n            id: pathToFileURL(resolved).href,\n            external: true,\n          };\n        }\n\n        for (const ext of ['.mjs', '.js', '.cjs']) {\n          const resolved = safeResolve(id + ext, importer);\n          if (resolved) {\n            const pkgName = getPackageName(id);\n            if (!pkgName) {\n              return null;\n            }\n\n            const pkgJsonPath = safeResolve(`${pkgName}/package.json`, importer);\n            if (!pkgJsonPath) {\n              return null;\n            }\n\n            const newImportWithExtension = resolved.replace(dirname(pkgJsonPath), pkgName);\n\n            return {\n              id: pathToFileURL(newImportWithExtension).href,\n              external: true,\n            };\n          }\n        }\n      }\n\n      return null;\n    },\n  } satisfies Plugin;\n}\n","import type { InputOptions, OutputOptions, Plugin } from 'rollup';\nimport { watch } from 'rollup';\nimport { join, dirname, posix } from 'node:path';\nimport * as pkg from 'empathic/package';\nimport { getInputOptions as getBundlerInputOptions } from './bundler';\nimport { aliasHono } from './plugins/hono-alias';\nimport { nodeModulesExtensionResolver } from './plugins/node-modules-extension-resolver';\nimport { tsConfigPaths } from './plugins/tsconfig-paths';\nimport { noopLogger } from '@mastra/core/logger';\nimport { getWorkspaceInformation } from '../bundler/workspaceDependencies';\nimport { analyzeBundle } from './analyze';\nimport { getPackageName, slash } from './utils';\n\nexport async function getInputOptions(\n  entryFile: string,\n  platform: 'node' | 'browser',\n  env?: Record<string, string>,\n  { sourcemap = false }: { sourcemap?: boolean } = {},\n) {\n  const closestPkgJson = pkg.up({ cwd: dirname(entryFile) });\n  const projectRoot = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());\n  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: entryFile });\n\n  const analyzeEntryResult = await analyzeBundle(\n    [entryFile],\n    entryFile,\n    {\n      outputDir: posix.join(process.cwd(), '.mastra', '.build'),\n      projectRoot: workspaceRoot || process.cwd(),\n      platform: 'node',\n      isDev: true,\n    },\n    noopLogger,\n  );\n\n  const deps = /* @__PURE__ */ new Map();\n  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {\n    const pkgName = getPackageName(dep);\n    if (pkgName && workspaceMap.has(pkgName)) {\n      deps.set(dep, metadata);\n    }\n  }\n\n  // In `analyzeBundle` we output this file and we want to use that instead of the original entry file\n  //const analyzedEntryFile = posix.join(process.cwd(), '.mastra', '.build', 'entry-0.mjs');\n\n  const inputOptions = await getBundlerInputOptions(\n    entryFile,\n    {\n      dependencies: deps,\n      externalDependencies: new Set(),\n      invalidChunks: new Set(),\n      workspaceMap,\n    },\n    platform,\n    env,\n    { sourcemap, isDev: true, workspaceRoot, projectRoot },\n  );\n\n  if (Array.isArray(inputOptions.plugins)) {\n    // filter out node-resolve plugin so all node_modules are external\n    // and tsconfig-paths plugin as we are injection a custom one\n    const plugins = [] as Plugin[];\n    inputOptions.plugins.forEach(plugin => {\n      if ((plugin as Plugin | undefined)?.name === 'node-resolve') {\n        return;\n      }\n\n      if ((plugin as Plugin | undefined)?.name === 'tsconfig-paths') {\n        plugins.push(\n          tsConfigPaths({\n            localResolve: true,\n          }),\n        );\n        return;\n      }\n\n      plugins.push(plugin as Plugin);\n    });\n\n    inputOptions.plugins = plugins;\n    inputOptions.plugins.push(aliasHono());\n    // fixes imports like lodash/fp/get\n    inputOptions.plugins.push(nodeModulesExtensionResolver());\n  }\n\n  return inputOptions;\n}\n\nexport async function createWatcher(inputOptions: InputOptions, outputOptions: OutputOptions) {\n  const watcher = await watch({\n    ...inputOptions,\n    output: {\n      ...outputOptions,\n      format: 'esm',\n      entryFileNames: '[name].mjs',\n      chunkFileNames: '[name].mjs',\n    },\n  });\n\n  return watcher;\n}\n","import { removeAllOptionsFromMastraExcept } from './remove-all-options-except';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function removeAllOptionsExceptServer(result: { hasCustomConfig: boolean }, logger?: IMastraLogger) {\n  return removeAllOptionsFromMastraExcept(result, 'server', logger);\n}\n","import { removeAllOptionsExceptServer } from './babel/remove-all-options-server';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\nimport type { IMastraLogger } from '@mastra/core/logger';\n\nexport function getServerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('server', entryFile, removeAllOptionsExceptServer, result);\n}\n\nexport async function getServerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['server'] | null> {\n  const result = await extractMastraOption<Config['server']>(\n    'server',\n    entryFile,\n    removeAllOptionsExceptServer,\n    outputDir,\n    logger,\n  );\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n"]}