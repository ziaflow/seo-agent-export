import { type OutputChunk, type OutputAsset } from 'rollup';
import { type WorkspacePackageInfo } from '../../bundler/workspaceDependencies.js';
import type { DependencyMetadata } from '../types.js';
type VirtualDependency = {
    name: string;
    virtual: string;
};
/**
 * Creates virtual dependency modules for optimized bundling by generating virtual entry points for each dependency with their specific exports and handling workspace package path resolution.
 */
export declare function createVirtualDependencies(depsToOptimize: Map<string, DependencyMetadata>, { projectRoot, workspaceRoot, outputDir }: {
    workspaceRoot: string | null;
    projectRoot: string;
    outputDir: string;
}): {
    optimizedDependencyEntries: Map<string, VirtualDependency>;
    fileNameToDependencyMap: Map<string, string>;
};
/**
 * Bundles vendor dependencies identified in the analysis step.
 * Creates virtual modules for each dependency and bundles them using rollup.
 *
 * @param depsToOptimize - Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)
 * @param outputDir - Directory where bundled files will be written
 * @param logger - Logger instance for debugging
 * @returns Object containing bundle output and reference map for validation
 */
export declare function bundleExternals(depsToOptimize: Map<string, DependencyMetadata>, outputDir: string, options: {
    bundlerOptions?: {
        externals?: string[];
        transpilePackages?: string[];
        isDev?: boolean;
        enableEsmShim?: boolean;
    } | null;
    projectRoot?: string;
    workspaceRoot?: string;
    workspaceMap?: Map<string, WorkspacePackageInfo>;
}): Promise<{
    output: [OutputChunk, ...(OutputAsset | OutputChunk)[]];
    fileNameToDependencyMap: Map<string, string>;
    usedExternals: Record<string, Record<string, string>>;
}>;
export {};
//# sourceMappingURL=bundleExternals.d.ts.map