{"version":3,"sources":["../src/shared/config.ts","../src/vector/filter.ts","../src/vector/sql-builder.ts","../src/vector/index.ts","../src/storage/domains/utils.ts","../src/storage/domains/legacy-evals/index.ts","../src/storage/domains/memory/index.ts","../src/storage/domains/observability/index.ts","../src/storage/domains/operations/index.ts","../src/storage/domains/scores/index.ts","../src/storage/domains/traces/index.ts","../src/storage/domains/workflows/index.ts","../src/storage/index.ts","../src/vector/prompt.ts"],"names":["result","conditions","operatorFn","operatorResult","mastraError","existingSchema","parseSqlIdentifier","MastraError","ErrorDomain","ErrorCategory","TABLE_SCHEMAS","TABLE_AI_SPANS","alterSql","quotedCol","TABLE_THREADS","TABLE_MESSAGES","TABLE_EVALS","TABLE_SCORERS","parseFieldKey","TABLE_TRACES","safelyParseJSON","TABLE_WORKFLOW_SNAPSHOT"],"mappings":"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","file":"index.js","sourcesContent":["import type { ConnectionOptions } from 'tls';\nimport type { ClientConfig } from 'pg';\nimport type * as pg from 'pg';\nimport type { ISSLConfig } from 'pg-promise/typescript/pg-subset';\n\n/**\n * Generic PostgreSQL configuration type.\n * @template SSLType - The SSL configuration type (ISSLConfig for pg-promise, ConnectionOptions for pg)\n */\nexport type PostgresConfig<SSLType = ISSLConfig | ConnectionOptions> = {\n  schemaName?: string;\n  max?: number;\n  idleTimeoutMillis?: number;\n} & (\n  | {\n      host: string;\n      port: number;\n      database: string;\n      user: string;\n      password: string;\n      ssl?: boolean | SSLType;\n    }\n  | {\n      connectionString: string;\n      ssl?: boolean | SSLType;\n    }\n  // Support Cloud SQL Connector & pg ClientConfig\n  | ClientConfig\n);\n\n/**\n * PostgreSQL configuration for PostgresStore (uses pg-promise with ISSLConfig)\n */\nexport type PostgresStoreConfig = PostgresConfig<ISSLConfig>;\n\n/**\n * PostgreSQL configuration for PgVector (uses pg with ConnectionOptions)\n */\nexport type PgVectorConfig = PostgresConfig<ConnectionOptions> & {\n  pgPoolOptions?: Omit<pg.PoolConfig, 'connectionString'>;\n};\n\nexport const isConnectionStringConfig = <SSLType>(\n  cfg: PostgresConfig<SSLType>,\n): cfg is PostgresConfig<SSLType> & { connectionString: string; ssl?: boolean | SSLType } => {\n  return 'connectionString' in cfg;\n};\n\nexport const isHostConfig = <SSLType>(\n  cfg: PostgresConfig<SSLType>,\n): cfg is PostgresConfig<SSLType> & {\n  host: string;\n  port: number;\n  database: string;\n  user: string;\n  password: string;\n  ssl?: boolean | SSLType;\n} => {\n  return 'host' in cfg && 'database' in cfg && 'user' in cfg && 'password' in cfg;\n};\n\nexport const isCloudSqlConfig = <SSLType>(\n  cfg: PostgresConfig<SSLType>,\n): cfg is PostgresConfig<SSLType> & ClientConfig => {\n  return 'stream' in cfg || ('password' in cfg && typeof cfg.password === 'function');\n};\n\nexport const validateConfig = (name: string, config: PostgresConfig<ISSLConfig | ConnectionOptions>) => {\n  if (isConnectionStringConfig(config)) {\n    if (\n      !config.connectionString ||\n      typeof config.connectionString !== 'string' ||\n      config.connectionString.trim() === ''\n    ) {\n      throw new Error(\n        `${name}: connectionString must be provided and cannot be empty. Passing an empty string may cause fallback to local Postgres defaults.`,\n      );\n    }\n  } else if (isCloudSqlConfig(config)) {\n    // valid connector config; no-op\n  } else if (isHostConfig(config)) {\n    const required = ['host', 'database', 'user', 'password'] as const;\n    for (const key of required) {\n      if (!config[key] || typeof config[key] !== 'string' || config[key].trim() === '') {\n        throw new Error(\n          `${name}: ${key} must be provided and cannot be empty. Passing an empty string may cause fallback to local Postgres defaults.`,\n        );\n      }\n    }\n  } else {\n    throw new Error(\n      `${name}: invalid config. Provide either {connectionString}, {host,port,database,user,password}, or a pg ClientConfig (e.g., Cloud SQL connector with \\`stream\\`).`,\n    );\n  }\n};\n","import { BaseFilterTranslator } from '@mastra/core/vector/filter';\nimport type {\n  VectorFilter,\n  OperatorSupport,\n  OperatorValueMap,\n  LogicalOperatorValueMap,\n  BlacklistedRootOperators,\n  VectorFieldValue,\n} from '@mastra/core/vector/filter';\n\ntype PGOperatorValueMap = Omit<OperatorValueMap, '$in' | '$all' | '$nin' | '$eq' | '$ne'> & {\n  $size: number;\n  $contains: VectorFieldValue | Record<string, unknown>;\n  $all: VectorFieldValue;\n  $in: VectorFieldValue;\n  $nin: VectorFieldValue;\n  $eq: VectorFieldValue;\n  $ne: VectorFieldValue;\n};\n\ntype PGBlacklisted = BlacklistedRootOperators | '$contains' | '$size';\n\ntype PGFilterValue = VectorFieldValue | RegExp;\n\nexport type PGVectorFilter = VectorFilter<\n  keyof PGOperatorValueMap,\n  PGOperatorValueMap,\n  LogicalOperatorValueMap,\n  PGBlacklisted,\n  PGFilterValue\n>;\n\n/**\n * Translates MongoDB-style filters to PG compatible filters.\n *\n * Key differences from MongoDB:\n *\n * Logical Operators ($and, $or, $nor):\n * - Can be used at the top level or nested within fields\n * - Can take either a single condition or an array of conditions\n *\n */\nexport class PGFilterTranslator extends BaseFilterTranslator<PGVectorFilter> {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: PGVectorFilter): PGVectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: PGVectorFilter, currentPath: string = ''): any {\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    // Handle regex\n    if (node instanceof RegExp) {\n      return withPath(this.translateRegexPattern(node.source, node.flags));\n    }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    if (node && '$options' in node && !('$regex' in node)) {\n      throw new Error('$options is not valid without $regex');\n    }\n\n    // Handle special regex object format\n    if (node && '$regex' in node) {\n      const options = (node as any).$options || '';\n      return withPath(this.translateRegexPattern((node as any).$regex, options));\n    }\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      // Skip options as they're handled with $regex\n      if (key === '$options') continue;\n\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: VectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  private translateRegexPattern(pattern: string, options: string = ''): any {\n    if (!options) return { $regex: pattern };\n\n    const flags = options\n      .split('')\n      .filter(f => 'imsux'.includes(f))\n      .join('');\n\n    return { $regex: flags ? `(?${flags})${pattern}` : pattern };\n  }\n}\n","import { parseFieldKey } from '@mastra/core/utils';\nimport type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n  RegexOperator,\n  VectorFilter,\n} from '@mastra/core/vector/filter';\nimport type { PGVectorFilter } from './filter';\n\ntype OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | Exclude<RegexOperator, '$options'>\n  | '$size';\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: () => any;\n};\n\ntype OperatorFn = (key: string, paramIndex: number, value?: any) => FilterOperator;\n\nconst createBasicOperator = (symbol: string) => {\n  return (key: string, paramIndex: number) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `CASE \n        WHEN $${paramIndex}::text IS NULL THEN metadata#>>'{${jsonPathKey}}' IS ${symbol === '=' ? '' : 'NOT'} NULL\n        ELSE metadata#>>'{${jsonPathKey}}' ${symbol} $${paramIndex}::text\n      END`,\n      needsValue: true,\n    };\n  };\n};\n\nconst createNumericOperator = (symbol: string) => {\n  return (key: string, paramIndex: number) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `(metadata#>>'{${jsonPathKey}}')::numeric ${symbol} $${paramIndex}`,\n      needsValue: true,\n    };\n  };\n};\n\nfunction buildElemMatchConditions(value: any, paramIndex: number): { sql: string; values: any[] } {\n  if (typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error('$elemMatch requires an object with conditions');\n  }\n\n  const conditions: string[] = [];\n  const values: any[] = [];\n\n  Object.entries(value).forEach(([field, val]) => {\n    const nextParamIndex = paramIndex + values.length;\n\n    let paramOperator;\n    let paramKey;\n    let paramValue;\n\n    if (field.startsWith('$')) {\n      paramOperator = field;\n      paramKey = '';\n      paramValue = val;\n    } else if (typeof val === 'object' && !Array.isArray(val)) {\n      const [op, opValue] = Object.entries(val || {})[0] || [];\n      paramOperator = op;\n      paramKey = field;\n      paramValue = opValue;\n    } else {\n      paramOperator = '$eq';\n      paramKey = field;\n      paramValue = val;\n    }\n\n    const operatorFn = FILTER_OPERATORS[paramOperator as OperatorType];\n    if (!operatorFn) {\n      throw new Error(`Invalid operator: ${paramOperator}`);\n    }\n    const result = operatorFn(paramKey, nextParamIndex, paramValue);\n\n    const sql = result.sql.replaceAll('metadata#>>', 'elem#>>');\n    conditions.push(sql);\n    if (result.needsValue) {\n      values.push(paramValue);\n    }\n  });\n\n  return {\n    sql: conditions.join(' AND '),\n    values,\n  };\n}\n\n// Define all filter operators\nconst FILTER_OPERATORS: Record<OperatorType, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key, paramIndex) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `(\n        CASE\n          WHEN jsonb_typeof(metadata->'${jsonPathKey}') = 'array' THEN\n            EXISTS (\n              SELECT 1 FROM jsonb_array_elements_text(metadata->'${jsonPathKey}') as elem\n              WHERE elem = ANY($${paramIndex}::text[])\n            )\n          ELSE metadata#>>'{${jsonPathKey}}' = ANY($${paramIndex}::text[])\n        END\n      )`,\n      needsValue: true,\n    };\n  },\n  $nin: (key, paramIndex) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `(\n        CASE\n          WHEN jsonb_typeof(metadata->'${jsonPathKey}') = 'array' THEN\n            NOT EXISTS (\n              SELECT 1 FROM jsonb_array_elements_text(metadata->'${jsonPathKey}') as elem\n              WHERE elem = ANY($${paramIndex}::text[])\n            )\n          ELSE metadata#>>'{${jsonPathKey}}' != ALL($${paramIndex}::text[])\n        END\n      )`,\n      needsValue: true,\n    };\n  },\n  $all: (key, paramIndex) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `CASE WHEN array_length($${paramIndex}::text[], 1) IS NULL THEN false \n            ELSE (metadata#>'{${jsonPathKey}}')::jsonb ?& $${paramIndex}::text[] END`,\n      needsValue: true,\n    };\n  },\n  $elemMatch: (key: string, paramIndex: number, value: any): FilterOperator => {\n    const { sql, values } = buildElemMatchConditions(value, paramIndex);\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `(\n        CASE\n          WHEN jsonb_typeof(metadata->'${jsonPathKey}') = 'array' THEN\n            EXISTS (\n              SELECT 1 \n              FROM jsonb_array_elements(metadata->'${jsonPathKey}') as elem\n              WHERE ${sql}\n            )\n          ELSE FALSE\n        END\n      )`,\n      needsValue: true,\n      transformValue: () => values,\n    };\n  },\n  // Element Operators\n  $exists: key => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `metadata ? '${jsonPathKey}'`,\n      needsValue: false,\n    };\n  },\n\n  // Logical Operators\n  $and: key => ({ sql: `(${key})`, needsValue: false }),\n  $or: key => ({ sql: `(${key})`, needsValue: false }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: key => ({ sql: `NOT (${key})`, needsValue: false }),\n\n  // Regex Operators\n  $regex: (key, paramIndex) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `metadata#>>'{${jsonPathKey}}' ~ $${paramIndex}`,\n      needsValue: true,\n    };\n  },\n\n  $contains: (key, paramIndex, value: any) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    let sql;\n    if (Array.isArray(value)) {\n      sql = `(metadata->'${jsonPathKey}') ?& $${paramIndex}`;\n    } else if (typeof value === 'string') {\n      sql = `metadata->>'${jsonPathKey}' ILIKE '%' || $${paramIndex} || '%' ESCAPE '\\\\'`;\n    } else {\n      sql = `metadata->>'${jsonPathKey}' = $${paramIndex}`;\n    }\n    return {\n      sql,\n      needsValue: true,\n      transformValue: () =>\n        Array.isArray(value) ? value.map(String) : typeof value === 'string' ? escapeLikePattern(value) : value,\n    };\n  },\n  /**\n   * $objectContains: Postgres-only operator for true JSONB object containment.\n   * Usage: { field: { $objectContains: { ...subobject } } }\n   */\n  // $objectContains: (key, paramIndex) => ({\n  //   sql: `metadata @> $${paramIndex}::jsonb`,\n  //   needsValue: true,\n  //   transformValue: value => {\n  //     const parts = key.split('.');\n  //     return JSON.stringify(parts.reduceRight((value, key) => ({ [key]: value }), value));\n  //   },\n  // }),\n  $size: (key: string, paramIndex: number) => {\n    const jsonPathKey = parseJsonPathKey(key);\n    return {\n      sql: `(\n      CASE\n        WHEN jsonb_typeof(metadata#>'{${jsonPathKey}}') = 'array' THEN \n          jsonb_array_length(metadata#>'{${jsonPathKey}}') = $${paramIndex}\n        ELSE FALSE\n      END\n    )`,\n      needsValue: true,\n    };\n  },\n};\n\ninterface FilterResult {\n  sql: string;\n  values: any[];\n}\n\nconst parseJsonPathKey = (key: string) => {\n  const parsedKey = key !== '' ? parseFieldKey(key) : '';\n  return parsedKey.replace(/\\./g, ',');\n};\n\nfunction escapeLikePattern(str: string): string {\n  return str.replace(/([%_\\\\])/g, '\\\\$1');\n}\n\nexport function buildFilterQuery(filter: PGVectorFilter, minScore: number, topK: number): FilterResult {\n  const values = [minScore, topK];\n\n  function buildCondition(key: string, value: any, parentPath: string): string {\n    // Handle logical operators ($and/$or)\n    if (['$and', '$or', '$not', '$nor'].includes(key)) {\n      return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n    }\n\n    // If condition is not a FilterCondition object, assume it's an equality check\n    if (!value || typeof value !== 'object') {\n      values.push(value);\n      return `metadata#>>'{${parseJsonPathKey(key)}}' = $${values.length}`;\n    }\n\n    // Handle operator conditions\n    const [[operator, operatorValue] = []] = Object.entries(value);\n\n    // Special handling for nested $not\n    if (operator === '$not') {\n      const entries = Object.entries(operatorValue as Record<string, unknown>);\n      const conditions = entries\n        .map(([nestedOp, nestedValue]) => {\n          if (!FILTER_OPERATORS[nestedOp as OperatorType]) {\n            throw new Error(`Invalid operator in $not condition: ${nestedOp}`);\n          }\n          const operatorFn = FILTER_OPERATORS[nestedOp as OperatorType]!;\n          const operatorResult = operatorFn(key, values.length + 1, nestedValue);\n          if (operatorResult.needsValue) {\n            values.push(nestedValue as number);\n          }\n          return operatorResult.sql;\n        })\n        .join(' AND ');\n\n      return `NOT (${conditions})`;\n    }\n    const operatorFn = FILTER_OPERATORS[operator as OperatorType]!;\n    const operatorResult = operatorFn(key, values.length + 1, operatorValue);\n    if (operatorResult.needsValue) {\n      const transformedValue = operatorResult.transformValue ? operatorResult.transformValue() : operatorValue;\n      if (Array.isArray(transformedValue) && operator === '$elemMatch') {\n        values.push(...transformedValue);\n      } else {\n        values.push(transformedValue);\n      }\n    }\n    return operatorResult.sql;\n  }\n\n  function handleLogicalOperator(\n    key: '$and' | '$or' | '$not' | '$nor',\n    value: VectorFilter[],\n    parentPath: string,\n  ): string {\n    if (key === '$not') {\n      // For top-level $not\n      const entries = Object.entries(value);\n      const conditions = entries\n        .map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key))\n        .join(' AND ');\n      return `NOT (${conditions})`;\n    }\n\n    // Handle empty conditions\n    if (!value || value.length === 0) {\n      switch (key) {\n        case '$and':\n        case '$nor':\n          return 'true'; // Empty $and/$nor match everything\n        case '$or':\n          return 'false'; // Empty $or matches nothing\n        default:\n          return 'true';\n      }\n    }\n\n    const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n    const conditions = value.map((f: VectorFilter) => {\n      const entries = Object.entries(f || {});\n      if (entries.length === 0) return '';\n\n      const [firstKey, firstValue] = entries[0] || [];\n      if (['$and', '$or', '$not', '$nor'].includes(firstKey as string)) {\n        return buildCondition(firstKey as string, firstValue, parentPath);\n      }\n      return entries.map(([k, v]) => buildCondition(k, v, parentPath)).join(` ${joinOperator} `);\n    });\n\n    const joined = conditions.join(` ${joinOperator} `);\n    const operatorFn = FILTER_OPERATORS[key]!;\n    return operatorFn(joined, 0, value).sql;\n  }\n\n  if (!filter) {\n    return { sql: '', values };\n  }\n\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => buildCondition(key, value, ''))\n    .filter(Boolean)\n    .join(' AND ');\n\n  return { sql: conditions ? `WHERE ${conditions}` : '', values };\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport { MastraVector } from '@mastra/core/vector';\nimport type {\n  IndexStats,\n  QueryResult,\n  QueryVectorParams,\n  CreateIndexParams,\n  UpsertVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n  DeleteVectorParams,\n  UpdateVectorParams,\n} from '@mastra/core/vector';\nimport { Mutex } from 'async-mutex';\nimport * as pg from 'pg';\nimport xxhash from 'xxhash-wasm';\n\nimport { validateConfig, isCloudSqlConfig, isConnectionStringConfig, isHostConfig } from '../shared/config';\nimport type { PgVectorConfig } from '../shared/config';\nimport { PGFilterTranslator } from './filter';\nimport type { PGVectorFilter } from './filter';\nimport { buildFilterQuery } from './sql-builder';\nimport type { IndexConfig, IndexType } from './types';\n\nexport interface PGIndexStats extends IndexStats {\n  type: IndexType;\n  config: {\n    m?: number;\n    efConstruction?: number;\n    lists?: number;\n    probes?: number;\n  };\n}\n\ninterface PgQueryVectorParams extends QueryVectorParams<PGVectorFilter> {\n  minScore?: number;\n  /**\n   * HNSW search parameter. Controls the size of the dynamic candidate\n   * list during search. Higher values improve accuracy at the cost of speed.\n   */\n  ef?: number;\n  /**\n   * IVFFlat probe parameter. Number of cells to visit during search.\n   * Higher values improve accuracy at the cost of speed.\n   */\n  probes?: number;\n}\n\ninterface PgCreateIndexParams extends CreateIndexParams {\n  indexConfig?: IndexConfig;\n  buildIndex?: boolean;\n}\n\ninterface PgDefineIndexParams {\n  indexName: string;\n  metric: 'cosine' | 'euclidean' | 'dotproduct';\n  indexConfig: IndexConfig;\n}\n\nexport class PgVector extends MastraVector<PGVectorFilter> {\n  public pool: pg.Pool;\n  private describeIndexCache: Map<string, PGIndexStats> = new Map();\n  private createdIndexes = new Map<string, number>();\n  private mutexesByName = new Map<string, Mutex>();\n  private schema?: string;\n  private setupSchemaPromise: Promise<void> | null = null;\n  private installVectorExtensionPromise: Promise<void> | null = null;\n  private vectorExtensionInstalled: boolean | undefined = undefined;\n  private vectorExtensionSchema: string | null = null;\n  private schemaSetupComplete: boolean | undefined = undefined;\n  private cacheWarmupPromise: Promise<void> | null = null;\n\n  constructor(config: PgVectorConfig) {\n    try {\n      validateConfig('PgVector', config);\n      super();\n\n      this.schema = config.schemaName;\n\n      let poolConfig: pg.PoolConfig;\n\n      if (isConnectionStringConfig(config)) {\n        poolConfig = {\n          connectionString: config.connectionString,\n          ssl: config.ssl,\n          max: config.max ?? 20,\n          idleTimeoutMillis: config.idleTimeoutMillis ?? 30000,\n          connectionTimeoutMillis: 2000,\n          ...config.pgPoolOptions,\n        };\n      } else if (isCloudSqlConfig(config)) {\n        poolConfig = {\n          ...config,\n          max: config.max ?? 20,\n          idleTimeoutMillis: config.idleTimeoutMillis ?? 30000,\n          connectionTimeoutMillis: 2000,\n          ...config.pgPoolOptions,\n        } as pg.PoolConfig;\n      } else if (isHostConfig(config)) {\n        poolConfig = {\n          host: config.host,\n          port: config.port,\n          database: config.database,\n          user: config.user,\n          password: config.password,\n          ssl: config.ssl,\n          max: config.max ?? 20,\n          idleTimeoutMillis: config.idleTimeoutMillis ?? 30000,\n          connectionTimeoutMillis: 2000,\n          ...config.pgPoolOptions,\n        };\n      } else {\n        throw new Error('PgVector: invalid configuration provided');\n      }\n\n      const basePool = new pg.Pool(poolConfig);\n\n      const telemetry = this.__getTelemetry();\n\n      this.pool =\n        telemetry?.traceClass(basePool, {\n          spanNamePrefix: 'pg-vector',\n          attributes: {\n            'vector.type': 'postgres',\n          },\n        }) ?? basePool;\n\n      // Warm the created indexes cache in background so we don't need to check if indexes exist every time\n      // Store the promise so we can wait for it during disconnect to avoid \"pool already closed\" errors\n      this.cacheWarmupPromise = (async () => {\n        try {\n          const existingIndexes = await this.listIndexes();\n          await Promise.all(\n            existingIndexes.map(async indexName => {\n              const info = await this.getIndexInfo({ indexName });\n              const key = await this.getIndexCacheKey({\n                indexName,\n                metric: info.metric,\n                dimension: info.dimension,\n                type: info.type,\n              });\n              this.createdIndexes.set(indexName, key);\n            }),\n          );\n        } catch (error) {\n          // Don't throw - cache warming is optional optimization\n          // If it fails (e.g., pool closed early), just log and continue\n          this.logger?.debug('Cache warming skipped or failed', { error });\n        }\n      })();\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_INITIALIZATION_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            schemaName: 'schemaName' in config ? (config.schemaName ?? '') : '',\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  private getMutexByName(indexName: string) {\n    if (!this.mutexesByName.has(indexName)) this.mutexesByName.set(indexName, new Mutex());\n    return this.mutexesByName.get(indexName)!;\n  }\n\n  /**\n   * Detects which schema contains the vector extension\n   */\n  private async detectVectorExtensionSchema(client: pg.PoolClient): Promise<string | null> {\n    try {\n      const result = await client.query(`\n        SELECT n.nspname as schema_name\n        FROM pg_extension e\n        JOIN pg_namespace n ON e.extnamespace = n.oid\n        WHERE e.extname = 'vector'\n        LIMIT 1;\n      `);\n\n      if (result.rows.length > 0) {\n        this.vectorExtensionSchema = result.rows[0].schema_name;\n        this.logger.debug('Vector extension found in schema', { schema: this.vectorExtensionSchema });\n        return this.vectorExtensionSchema;\n      }\n\n      return null;\n    } catch (error) {\n      this.logger.debug('Could not detect vector extension schema', { error });\n      return null;\n    }\n  }\n\n  /**\n   * Gets the properly qualified vector type name\n   */\n  private getVectorTypeName(): string {\n    // If we know where the extension is, use that\n    if (this.vectorExtensionSchema) {\n      // If it's in pg_catalog, return vector\n      if (this.vectorExtensionSchema === 'pg_catalog') {\n        return 'vector';\n      }\n      // If it's in the current schema, return vector\n      if (this.vectorExtensionSchema === (this.schema || 'public')) {\n        return 'vector';\n      }\n      // Otherwise, qualify it with the schema where vector extension is installed\n      const validatedSchema = parseSqlIdentifier(this.vectorExtensionSchema, 'vector extension schema');\n      return `${validatedSchema}.vector`;\n    }\n\n    // Fallback to unqualified (will use search_path)\n    return 'vector';\n  }\n\n  private getTableName(indexName: string) {\n    const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n    const quotedIndexName = `\"${parsedIndexName}\"`;\n    const quotedSchemaName = this.getSchemaName();\n    const quotedVectorName = `\"${parsedIndexName}_vector_idx\"`;\n    return {\n      tableName: quotedSchemaName ? `${quotedSchemaName}.${quotedIndexName}` : quotedIndexName,\n      vectorIndexName: quotedVectorName,\n    };\n  }\n\n  private getSchemaName() {\n    return this.schema ? `\"${parseSqlIdentifier(this.schema, 'schema name')}\"` : undefined;\n  }\n\n  transformFilter(filter?: PGVectorFilter) {\n    const translator = new PGFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async getIndexInfo({ indexName }: DescribeIndexParams): Promise<PGIndexStats> {\n    if (!this.describeIndexCache.has(indexName)) {\n      this.describeIndexCache.set(indexName, await this.describeIndex({ indexName }));\n    }\n    return this.describeIndexCache.get(indexName)!;\n  }\n\n  async query({\n    indexName,\n    queryVector,\n    topK = 10,\n    filter,\n    includeVector = false,\n    minScore = -1,\n    ef,\n    probes,\n  }: PgQueryVectorParams): Promise<QueryResult[]> {\n    try {\n      if (!Number.isInteger(topK) || topK <= 0) {\n        throw new Error('topK must be a positive integer');\n      }\n      if (!Array.isArray(queryVector) || !queryVector.every(x => typeof x === 'number' && Number.isFinite(x))) {\n        throw new Error('queryVector must be an array of finite numbers');\n      }\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_QUERY_INVALID_INPUT',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.USER,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    }\n\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      const vectorStr = `[${queryVector.join(',')}]`;\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter, minScore, topK);\n\n      // Get index type and configuration\n      const indexInfo = await this.getIndexInfo({ indexName });\n\n      // Set HNSW search parameter if applicable\n      if (indexInfo.type === 'hnsw') {\n        // Calculate ef and clamp between 1 and 1000\n        const calculatedEf = ef ?? Math.max(topK, (indexInfo?.config?.m ?? 16) * topK);\n        const searchEf = Math.min(1000, Math.max(1, calculatedEf));\n        await client.query(`SET LOCAL hnsw.ef_search = ${searchEf}`);\n      }\n\n      if (indexInfo.type === 'ivfflat' && probes) {\n        await client.query(`SET LOCAL ivfflat.probes = ${probes}`);\n      }\n\n      const { tableName } = this.getTableName(indexName);\n\n      // Get the properly qualified vector type\n      const vectorType = this.getVectorTypeName();\n\n      const query = `\n        WITH vector_scores AS (\n          SELECT\n            vector_id as id,\n            1 - (embedding <=> '${vectorStr}'::${vectorType}) as score,\n            metadata\n            ${includeVector ? ', embedding' : ''}\n          FROM ${tableName}\n          ${filterQuery}\n        )\n        SELECT *\n        FROM vector_scores\n        WHERE score > $1\n        ORDER BY score DESC\n        LIMIT $2`;\n      const result = await client.query(query, filterValues);\n      await client.query('COMMIT');\n\n      return result.rows.map(({ id, score, metadata, embedding }) => ({\n        id,\n        score,\n        metadata,\n        ...(includeVector && embedding && { vector: JSON.parse(embedding) }),\n      }));\n    } catch (error) {\n      await client.query('ROLLBACK');\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_QUERY_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  async upsert({ indexName, vectors, metadata, ids }: UpsertVectorParams): Promise<string[]> {\n    const { tableName } = this.getTableName(indexName);\n\n    // Start a transaction\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n      // Get the properly qualified vector type\n      const vectorType = this.getVectorTypeName();\n\n      for (let i = 0; i < vectors.length; i++) {\n        const query = `\n          INSERT INTO ${tableName} (vector_id, embedding, metadata)\n          VALUES ($1, $2::${vectorType}, $3::jsonb)\n          ON CONFLICT (vector_id)\n          DO UPDATE SET\n            embedding = $2::${vectorType},\n            metadata = $3::jsonb\n          RETURNING embedding::text\n        `;\n\n        await client.query(query, [vectorIds[i], `[${vectors[i]?.join(',')}]`, JSON.stringify(metadata?.[i] || {})]);\n      }\n\n      await client.query('COMMIT');\n      return vectorIds;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      if (error instanceof Error && error.message?.includes('expected') && error.message?.includes('dimensions')) {\n        const match = error.message.match(/expected (\\d+) dimensions, not (\\d+)/);\n        if (match) {\n          const [, expected, actual] = match;\n          const mastraError = new MastraError(\n            {\n              id: 'MASTRA_STORAGE_PG_VECTOR_UPSERT_INVALID_INPUT',\n              domain: ErrorDomain.MASTRA_VECTOR,\n              category: ErrorCategory.USER,\n              text:\n                `Vector dimension mismatch: Index \"${indexName}\" expects ${expected} dimensions but got ${actual} dimensions. ` +\n                `Either use a matching embedding model or delete and recreate the index with the new dimension.`,\n              details: {\n                indexName,\n                expected: expected ?? '',\n                actual: actual ?? '',\n              },\n            },\n            error,\n          );\n          this.logger?.trackException(mastraError);\n          throw mastraError;\n        }\n      }\n\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_UPSERT_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  private hasher = xxhash();\n  private async getIndexCacheKey({\n    indexName,\n    dimension,\n    metric,\n    type,\n  }: CreateIndexParams & { type: IndexType | undefined }) {\n    const input = indexName + dimension + metric + (type || 'ivfflat'); // ivfflat is default\n    return (await this.hasher).h32(input);\n  }\n  private cachedIndexExists(indexName: string, newKey: number) {\n    const existingIndexCacheKey = this.createdIndexes.get(indexName);\n    return existingIndexCacheKey && existingIndexCacheKey === newKey;\n  }\n  private async setupSchema(client: pg.PoolClient) {\n    if (!this.schema || this.schemaSetupComplete) {\n      return;\n    }\n\n    if (!this.setupSchemaPromise) {\n      this.setupSchemaPromise = (async () => {\n        try {\n          // First check if schema exists and we have usage permission\n          const schemaCheck = await client.query(\n            `\n            SELECT EXISTS (\n              SELECT 1 FROM information_schema.schemata \n              WHERE schema_name = $1\n            )\n          `,\n            [this.schema],\n          );\n\n          const schemaExists = schemaCheck.rows[0].exists;\n\n          if (!schemaExists) {\n            try {\n              await client.query(`CREATE SCHEMA IF NOT EXISTS ${this.getSchemaName()}`);\n              this.logger.info(`Schema \"${this.schema}\" created successfully`);\n            } catch (error) {\n              this.logger.error(`Failed to create schema \"${this.schema}\"`, { error });\n              throw new Error(\n                `Unable to create schema \"${this.schema}\". This requires CREATE privilege on the database. ` +\n                  `Either create the schema manually or grant CREATE privilege to the user.`,\n              );\n            }\n          }\n\n          // If we got here, schema exists and we can use it\n          this.schemaSetupComplete = true;\n          this.logger.debug(`Schema \"${this.schema}\" is ready for use`);\n        } catch (error) {\n          // Reset flags so we can retry\n          this.schemaSetupComplete = undefined;\n          this.setupSchemaPromise = null;\n          throw error;\n        } finally {\n          this.setupSchemaPromise = null;\n        }\n      })();\n    }\n\n    await this.setupSchemaPromise;\n  }\n\n  async createIndex({\n    indexName,\n    dimension,\n    metric = 'cosine',\n    indexConfig = {},\n    buildIndex = true,\n  }: PgCreateIndexParams): Promise<void> {\n    const { tableName } = this.getTableName(indexName);\n\n    // Validate inputs\n    try {\n      if (!indexName.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {\n        throw new Error('Invalid index name format');\n      }\n      if (!Number.isInteger(dimension) || dimension <= 0) {\n        throw new Error('Dimension must be a positive integer');\n      }\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_CREATE_INDEX_INVALID_INPUT',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.USER,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    }\n\n    const indexCacheKey = await this.getIndexCacheKey({ indexName, dimension, type: indexConfig.type, metric });\n    if (this.cachedIndexExists(indexName, indexCacheKey)) {\n      // we already saw this index get created since the process started, no need to recreate it\n      return;\n    }\n\n    const mutex = this.getMutexByName(`create-${indexName}`);\n    // Use async-mutex instead of advisory lock for perf (over 2x as fast)\n    await mutex\n      .runExclusive(async () => {\n        if (this.cachedIndexExists(indexName, indexCacheKey)) {\n          // this may have been created while we were waiting to acquire a lock\n          return;\n        }\n\n        const client = await this.pool.connect();\n\n        try {\n          // Setup schema if needed\n          await this.setupSchema(client);\n\n          // Install vector extension and detect where it is\n          await this.installVectorExtension(client);\n\n          // Set search path to include both schemas if needed\n          if (\n            this.schema &&\n            this.vectorExtensionSchema &&\n            this.schema !== this.vectorExtensionSchema &&\n            this.vectorExtensionSchema !== 'pg_catalog'\n          ) {\n            await client.query(`SET search_path TO ${this.getSchemaName()}, \"${this.vectorExtensionSchema}\"`);\n          }\n\n          // Use the properly qualified vector type\n          const vectorType = this.getVectorTypeName();\n\n          await client.query(`\n          CREATE TABLE IF NOT EXISTS ${tableName} (\n            id SERIAL PRIMARY KEY,\n            vector_id TEXT UNIQUE NOT NULL,\n            embedding ${vectorType}(${dimension}),\n            metadata JSONB DEFAULT '{}'::jsonb\n          );\n        `);\n          this.createdIndexes.set(indexName, indexCacheKey);\n\n          if (buildIndex) {\n            await this.setupIndex({ indexName, metric, indexConfig }, client);\n          }\n        } catch (error: any) {\n          this.createdIndexes.delete(indexName);\n          throw error;\n        } finally {\n          client.release();\n        }\n      })\n      .catch(error => {\n        const mastraError = new MastraError(\n          {\n            id: 'MASTRA_STORAGE_PG_VECTOR_CREATE_INDEX_FAILED',\n            domain: ErrorDomain.MASTRA_VECTOR,\n            category: ErrorCategory.THIRD_PARTY,\n            details: {\n              indexName,\n            },\n          },\n          error,\n        );\n        this.logger?.trackException(mastraError);\n        throw mastraError;\n      });\n  }\n\n  async buildIndex({ indexName, metric = 'cosine', indexConfig }: PgDefineIndexParams): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await this.setupIndex({ indexName, metric, indexConfig }, client);\n    } catch (error: any) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_BUILD_INDEX_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  private async setupIndex({ indexName, metric, indexConfig }: PgDefineIndexParams, client: pg.PoolClient) {\n    const mutex = this.getMutexByName(`build-${indexName}`);\n    // Use async-mutex instead of advisory lock for perf (over 2x as fast)\n    await mutex.runExclusive(async () => {\n      // Check if the index config is empty\n      const isConfigEmpty =\n        !indexConfig ||\n        Object.keys(indexConfig).length === 0 ||\n        (!indexConfig.type && !indexConfig.ivf && !indexConfig.hnsw);\n      // Determine index type - use defaults if no config provided\n      const indexType = isConfigEmpty ? 'ivfflat' : indexConfig.type || 'ivfflat';\n\n      const { tableName, vectorIndexName } = this.getTableName(indexName);\n\n      // Try to get existing index info to check if configuration has changed\n      let existingIndexInfo: PGIndexStats | null = null;\n      let dimension = 0;\n      try {\n        existingIndexInfo = await this.getIndexInfo({ indexName });\n        dimension = existingIndexInfo.dimension;\n\n        if (isConfigEmpty && existingIndexInfo.metric === metric) {\n          if (existingIndexInfo.type === 'flat') {\n            // No index exists - create the default ivfflat\n            this.logger?.debug(`No index exists for ${vectorIndexName}, will create default ivfflat index`);\n          } else {\n            // Preserve existing non-flat index\n            this.logger?.debug(\n              `Index ${vectorIndexName} already exists (type: ${existingIndexInfo.type}, metric: ${existingIndexInfo.metric}), preserving existing configuration`,\n            );\n            const cacheKey = await this.getIndexCacheKey({\n              indexName,\n              dimension,\n              type: existingIndexInfo.type,\n              metric: existingIndexInfo.metric,\n            });\n            this.createdIndexes.set(indexName, cacheKey);\n            return;\n          }\n        }\n\n        // If config was empty but metric didn't match, OR config was provided, check for changes\n        let configMatches = existingIndexInfo.metric === metric && existingIndexInfo.type === indexType;\n        if (indexType === 'hnsw') {\n          configMatches =\n            configMatches &&\n            existingIndexInfo.config.m === (indexConfig.hnsw?.m ?? 8) &&\n            existingIndexInfo.config.efConstruction === (indexConfig.hnsw?.efConstruction ?? 32);\n        } else if (indexType === 'flat') {\n          configMatches = configMatches && existingIndexInfo.type === 'flat';\n        } else if (indexType === 'ivfflat' && indexConfig.ivf?.lists) {\n          configMatches = configMatches && existingIndexInfo.config.lists === indexConfig.ivf?.lists;\n        }\n\n        if (configMatches) {\n          this.logger?.debug(`Index ${vectorIndexName} already exists with same configuration, skipping recreation`);\n          // Update cache with the existing configuration\n          const cacheKey = await this.getIndexCacheKey({\n            indexName,\n            dimension,\n            type: existingIndexInfo.type,\n            metric: existingIndexInfo.metric,\n          });\n          this.createdIndexes.set(indexName, cacheKey);\n          return;\n        }\n\n        // Configuration changed, need to rebuild\n        this.logger?.info(`Index ${vectorIndexName} configuration changed, rebuilding index`);\n        await client.query(`DROP INDEX IF EXISTS ${vectorIndexName}`);\n        this.describeIndexCache.delete(indexName);\n      } catch {\n        this.logger?.debug(`Index ${indexName} doesn't exist yet, will create it`);\n      }\n\n      if (indexType === 'flat') {\n        this.describeIndexCache.delete(indexName);\n        return;\n      }\n\n      const metricOp =\n        metric === 'cosine' ? 'vector_cosine_ops' : metric === 'euclidean' ? 'vector_l2_ops' : 'vector_ip_ops';\n\n      let indexSQL: string;\n      if (indexType === 'hnsw') {\n        const m = indexConfig.hnsw?.m ?? 8;\n        const efConstruction = indexConfig.hnsw?.efConstruction ?? 32;\n\n        indexSQL = `\n          CREATE INDEX IF NOT EXISTS ${vectorIndexName} \n          ON ${tableName} \n          USING hnsw (embedding ${metricOp})\n          WITH (\n            m = ${m},\n            ef_construction = ${efConstruction}\n          )\n        `;\n      } else {\n        let lists: number;\n        if (indexConfig.ivf?.lists) {\n          lists = indexConfig.ivf.lists;\n        } else {\n          const size = (await client.query(`SELECT COUNT(*) FROM ${tableName}`)).rows[0].count;\n          lists = Math.max(100, Math.min(4000, Math.floor(Math.sqrt(size) * 2)));\n        }\n        indexSQL = `\n          CREATE INDEX IF NOT EXISTS ${vectorIndexName}\n          ON ${tableName}\n          USING ivfflat (embedding ${metricOp})\n          WITH (lists = ${lists});\n        `;\n      }\n\n      await client.query(indexSQL);\n    });\n  }\n\n  private async installVectorExtension(client: pg.PoolClient) {\n    // If we've already successfully installed, no need to do anything\n    if (this.vectorExtensionInstalled) {\n      return;\n    }\n\n    // If there's no existing installation attempt or the previous one failed\n    if (!this.installVectorExtensionPromise) {\n      this.installVectorExtensionPromise = (async () => {\n        try {\n          // First, detect if and where the extension is already installed\n          const existingSchema = await this.detectVectorExtensionSchema(client);\n\n          if (existingSchema) {\n            this.vectorExtensionInstalled = true;\n            this.vectorExtensionSchema = existingSchema;\n            this.logger.info(`Vector extension already installed in schema: ${existingSchema}`);\n            return;\n          }\n\n          // Try to install the extension\n          try {\n            // First try to install in the custom schema if provided\n            if (this.schema && this.schema !== 'public') {\n              try {\n                await client.query(`CREATE EXTENSION IF NOT EXISTS vector SCHEMA ${this.getSchemaName()}`);\n                this.vectorExtensionInstalled = true;\n                this.vectorExtensionSchema = this.schema;\n                this.logger.info(`Vector extension installed in schema: ${this.schema}`);\n                return;\n              } catch (schemaError) {\n                this.logger.debug(`Could not install vector extension in schema ${this.schema}, trying public schema`, {\n                  error: schemaError,\n                });\n              }\n            }\n\n            // Fall back to installing in public schema (or default)\n            await client.query('CREATE EXTENSION IF NOT EXISTS vector');\n\n            // Detect where it was actually installed\n            const installedSchema = await this.detectVectorExtensionSchema(client);\n            if (installedSchema) {\n              this.vectorExtensionInstalled = true;\n              this.vectorExtensionSchema = installedSchema;\n              this.logger.info(`Vector extension installed in schema: ${installedSchema}`);\n            }\n          } catch (error) {\n            this.logger.warn(\n              'Could not install vector extension. This requires superuser privileges. ' +\n                'If the extension is already installed, you can ignore this warning.',\n              { error },\n            );\n\n            // Even if installation failed, check if it exists somewhere\n            const existingSchema = await this.detectVectorExtensionSchema(client);\n            if (existingSchema) {\n              this.vectorExtensionInstalled = true;\n              this.vectorExtensionSchema = existingSchema;\n              this.logger.info(`Vector extension found in schema: ${existingSchema}`);\n            }\n          }\n        } catch (error) {\n          this.logger.error('Error setting up vector extension', { error });\n          this.vectorExtensionInstalled = undefined;\n          this.installVectorExtensionPromise = null;\n          throw error;\n        } finally {\n          this.installVectorExtensionPromise = null;\n        }\n      })();\n    }\n\n    await this.installVectorExtensionPromise;\n  }\n\n  async listIndexes(): Promise<string[]> {\n    const client = await this.pool.connect();\n    try {\n      // Query for tables that match the exact Mastra PgVector table structure:\n      // Must have: vector_id (TEXT), embedding (vector), metadata (JSONB)\n      const mastraTablesQuery = `\n        SELECT DISTINCT t.table_name\n        FROM information_schema.tables t\n        WHERE t.table_schema = $1\n        AND EXISTS (\n          SELECT 1\n          FROM information_schema.columns c\n          WHERE c.table_schema = t.table_schema\n          AND c.table_name = t.table_name\n          AND c.column_name = 'vector_id'\n          AND c.data_type = 'text'\n        )\n        AND EXISTS (\n          SELECT 1\n          FROM information_schema.columns c\n          WHERE c.table_schema = t.table_schema\n          AND c.table_name = t.table_name\n          AND c.column_name = 'embedding'\n          AND c.udt_name = 'vector'\n        )\n        AND EXISTS (\n          SELECT 1\n          FROM information_schema.columns c\n          WHERE c.table_schema = t.table_schema\n          AND c.table_name = t.table_name\n          AND c.column_name = 'metadata'\n          AND c.data_type = 'jsonb'\n        );\n      `;\n      const mastraTables = await client.query(mastraTablesQuery, [this.schema || 'public']);\n      return mastraTables.rows.map(row => row.table_name);\n    } catch (e) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_LIST_INDEXES_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        e,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  /**\n   * Retrieves statistics about a vector index.\n   *\n   * @param {string} indexName - The name of the index to describe\n   * @returns A promise that resolves to the index statistics including dimension, count and metric\n   */\n  async describeIndex({ indexName }: DescribeIndexParams): Promise<PGIndexStats> {\n    const client = await this.pool.connect();\n    try {\n      const { tableName } = this.getTableName(indexName);\n\n      // Check if table exists with a vector column\n      const tableExistsQuery = `\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_schema = $1\n          AND table_name = $2\n          AND udt_name = 'vector'\n        LIMIT 1;\n      `;\n      const tableExists = await client.query(tableExistsQuery, [this.schema || 'public', indexName]);\n\n      if (tableExists.rows.length === 0) {\n        throw new Error(`Vector table ${tableName} does not exist`);\n      }\n\n      // Get vector dimension\n      const dimensionQuery = `\n                SELECT atttypmod as dimension\n                FROM pg_attribute\n                WHERE attrelid = $1::regclass\n                AND attname = 'embedding';\n            `;\n\n      // Get row count\n      const countQuery = `\n                SELECT COUNT(*) as count\n                FROM ${tableName};\n            `;\n\n      // Get index metric type\n      const indexQuery = `\n            SELECT\n                am.amname as index_method,\n                pg_get_indexdef(i.indexrelid) as index_def,\n                opclass.opcname as operator_class\n            FROM pg_index i\n            JOIN pg_class c ON i.indexrelid = c.oid\n            JOIN pg_am am ON c.relam = am.oid\n            JOIN pg_opclass opclass ON i.indclass[0] = opclass.oid\n            JOIN pg_namespace n ON c.relnamespace = n.oid\n            WHERE c.relname = $1\n            AND n.nspname = $2;\n            `;\n\n      const [dimResult, countResult, indexResult] = await Promise.all([\n        client.query(dimensionQuery, [tableName]),\n        client.query(countQuery),\n        client.query(indexQuery, [`${indexName}_vector_idx`, this.schema || 'public']),\n      ]);\n\n      const { index_method, index_def, operator_class } = indexResult.rows[0] || {\n        index_method: 'flat',\n        index_def: '',\n        operator_class: 'cosine',\n      };\n\n      // Convert pg_vector index method to our metric type\n      const metric = operator_class.includes('l2')\n        ? 'euclidean'\n        : operator_class.includes('ip')\n          ? 'dotproduct'\n          : 'cosine';\n\n      // Parse index configuration\n      const config: { m?: number; efConstruction?: number; lists?: number } = {};\n\n      if (index_method === 'hnsw') {\n        const m = index_def.match(/m\\s*=\\s*'?(\\d+)'?/)?.[1];\n        const efConstruction = index_def.match(/ef_construction\\s*=\\s*'?(\\d+)'?/)?.[1];\n        if (m) config.m = parseInt(m);\n        if (efConstruction) config.efConstruction = parseInt(efConstruction);\n      } else if (index_method === 'ivfflat') {\n        const lists = index_def.match(/lists\\s*=\\s*'?(\\d+)'?/)?.[1];\n        if (lists) config.lists = parseInt(lists);\n      }\n\n      return {\n        dimension: dimResult.rows[0].dimension,\n        count: parseInt(countResult.rows[0].count),\n        metric,\n        type: index_method as 'flat' | 'hnsw' | 'ivfflat',\n        config,\n      };\n    } catch (e: any) {\n      await client.query('ROLLBACK');\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_DESCRIBE_INDEX_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        e,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  async deleteIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      const { tableName } = this.getTableName(indexName);\n      // Drop the table\n      await client.query(`DROP TABLE IF EXISTS ${tableName} CASCADE`);\n      this.createdIndexes.delete(indexName);\n    } catch (error: any) {\n      await client.query('ROLLBACK');\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_DELETE_INDEX_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  async truncateIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      const { tableName } = this.getTableName(indexName);\n      await client.query(`TRUNCATE ${tableName}`);\n    } catch (e: any) {\n      await client.query('ROLLBACK');\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_TRUNCATE_INDEX_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        e,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client.release();\n    }\n  }\n\n  async disconnect() {\n    // Wait for cache warmup to complete before closing pool\n    // This prevents \"Cannot use a pool after calling end on the pool\" errors\n    if (this.cacheWarmupPromise) {\n      try {\n        await this.cacheWarmupPromise;\n      } catch {\n        // Ignore errors - we're shutting down anyway\n      }\n    }\n\n    await this.pool.end();\n  }\n\n  /**\n   * Updates a vector by its ID with the provided vector and/or metadata.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  async updateVector({ indexName, id, update }: UpdateVectorParams): Promise<void> {\n    let client;\n    try {\n      if (!update.vector && !update.metadata) {\n        throw new Error('No updates provided');\n      }\n\n      client = await this.pool.connect();\n      let updateParts = [];\n      let values = [id];\n      let valueIndex = 2;\n\n      // Get the properly qualified vector type\n      const vectorType = this.getVectorTypeName();\n\n      if (update.vector) {\n        updateParts.push(`embedding = $${valueIndex}::${vectorType}`);\n        values.push(`[${update.vector.join(',')}]`);\n        valueIndex++;\n      }\n\n      if (update.metadata) {\n        updateParts.push(`metadata = $${valueIndex}::jsonb`);\n        values.push(JSON.stringify(update.metadata));\n      }\n\n      if (updateParts.length === 0) {\n        return;\n      }\n\n      const { tableName } = this.getTableName(indexName);\n\n      // query looks like this:\n      // UPDATE table SET embedding = $2::vector, metadata = $3::jsonb WHERE id = $1\n      const query = `\n        UPDATE ${tableName}\n        SET ${updateParts.join(', ')}\n        WHERE vector_id = $1\n      `;\n\n      await client.query(query, values);\n    } catch (error: any) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_UPDATE_VECTOR_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n            id,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client?.release();\n    }\n  }\n\n  /**\n   * Deletes a vector by its ID.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to delete.\n   * @returns A promise that resolves when the deletion is complete.\n   * @throws Will throw an error if the deletion operation fails.\n   */\n  async deleteVector({ indexName, id }: DeleteVectorParams): Promise<void> {\n    let client;\n    try {\n      client = await this.pool.connect();\n      const { tableName } = this.getTableName(indexName);\n      const query = `\n        DELETE FROM ${tableName}\n        WHERE vector_id = $1\n      `;\n      await client.query(query, [id]);\n    } catch (error: any) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_VECTOR_DELETE_VECTOR_FAILED',\n          domain: ErrorDomain.MASTRA_VECTOR,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n            id,\n          },\n        },\n        error,\n      );\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    } finally {\n      client?.release();\n    }\n  }\n}\n","import type { PaginationArgs, StorageColumn, TABLE_NAMES } from '@mastra/core/storage';\nimport { TABLE_SCHEMAS } from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\n\nexport function getSchemaName(schema?: string) {\n  return schema ? `\"${parseSqlIdentifier(schema, 'schema name')}\"` : undefined;\n}\n\nexport function getTableName({ indexName, schemaName }: { indexName: string; schemaName?: string }) {\n  const parsedIndexName = parseSqlIdentifier(indexName, 'index name');\n  const quotedIndexName = `\"${parsedIndexName}\"`;\n  const quotedSchemaName = schemaName;\n  return quotedSchemaName ? `${quotedSchemaName}.${quotedIndexName}` : quotedIndexName;\n}\n\n/**\n * Build date range filter for queries\n */\nexport function buildDateRangeFilter(dateRange: PaginationArgs['dateRange'], fieldName: string): Record<string, any> {\n  const filters: Record<string, any> = {};\n  if (dateRange?.start) {\n    filters[`${fieldName}_gte`] = dateRange.start;\n  }\n  if (dateRange?.end) {\n    filters[`${fieldName}_lte`] = dateRange.end;\n  }\n  return filters;\n}\n\n/**\n * Prepare WHERE clause for PostgreSQL queries\n */\nexport function prepareWhereClause(\n  filters: Record<string, any>,\n  _schema?: Record<string, StorageColumn>,\n): { sql: string; args: any[] } {\n  const conditions: string[] = [];\n  const args: any[] = [];\n  let paramIndex = 1;\n\n  Object.entries(filters).forEach(([key, value]) => {\n    if (value === undefined) return;\n\n    // Handle special operators\n    if (key.endsWith('_gte')) {\n      const fieldName = key.slice(0, -4);\n      conditions.push(`\"${parseSqlIdentifier(fieldName, 'field name')}\" >= $${paramIndex++}`);\n      args.push(value instanceof Date ? value.toISOString() : value);\n    } else if (key.endsWith('_lte')) {\n      const fieldName = key.slice(0, -4);\n      conditions.push(`\"${parseSqlIdentifier(fieldName, 'field name')}\" <= $${paramIndex++}`);\n      args.push(value instanceof Date ? value.toISOString() : value);\n    } else if (value === null) {\n      conditions.push(`\"${parseSqlIdentifier(key, 'field name')}\" IS NULL`);\n    } else {\n      conditions.push(`\"${parseSqlIdentifier(key, 'field name')}\" = $${paramIndex++}`);\n      args.push(value instanceof Date ? value.toISOString() : value);\n    }\n  });\n\n  return {\n    sql: conditions.length > 0 ? ` WHERE ${conditions.join(' AND ')}` : '',\n    args,\n  };\n}\n\n/**\n * Transform SQL row to record format, handling JSON columns\n */\nexport function transformFromSqlRow<T>({\n  tableName,\n  sqlRow,\n}: {\n  tableName: TABLE_NAMES;\n  sqlRow: Record<string, any>;\n}): T {\n  const schema = TABLE_SCHEMAS[tableName];\n  const result: Record<string, any> = {};\n\n  Object.entries(sqlRow).forEach(([key, value]) => {\n    const columnSchema = schema?.[key];\n\n    // Handle JSON columns\n    if (columnSchema?.type === 'jsonb' && typeof value === 'string') {\n      try {\n        result[key] = JSON.parse(value);\n      } catch {\n        result[key] = value;\n      }\n    }\n    // Handle Date columns\n    // Handle Date columns - convert to Date objects for timestamp columns\n    else if (columnSchema?.type === 'timestamp' && value && typeof value === 'string') {\n      result[key] = new Date(value);\n    } else if (columnSchema?.type === 'timestamp' && value instanceof Date) {\n      result[key] = value;\n    }\n    // Handle boolean columns\n    else if (columnSchema?.type === 'boolean') {\n      result[key] = Boolean(value);\n    } else {\n      result[key] = value;\n    }\n  });\n\n  return result as T;\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MetricResult } from '@mastra/core/eval';\nimport { LegacyEvalsStorage, TABLE_EVALS } from '@mastra/core/storage';\nimport type { PaginationArgs, PaginationInfo, EvalRow } from '@mastra/core/storage';\nimport type { IDatabase } from 'pg-promise';\nimport { getSchemaName, getTableName } from '../utils';\n\nfunction transformEvalRow(row: Record<string, any>): EvalRow {\n  let testInfoValue = null;\n  if (row.test_info) {\n    try {\n      testInfoValue = typeof row.test_info === 'string' ? JSON.parse(row.test_info) : row.test_info;\n    } catch (e) {\n      console.warn('Failed to parse test_info:', e);\n    }\n  }\n\n  return {\n    agentName: row.agent_name as string,\n    input: row.input as string,\n    output: row.output as string,\n    result: row.result as MetricResult,\n    metricName: row.metric_name as string,\n    instructions: row.instructions as string,\n    testInfo: testInfoValue,\n    globalRunId: row.global_run_id as string,\n    runId: row.run_id as string,\n    createdAt: row.created_atZ || (row.created_at as string),\n  };\n}\n\nexport class LegacyEvalsPG extends LegacyEvalsStorage {\n  private client: IDatabase<{}>;\n  private schema: string;\n  constructor({ client, schema }: { client: IDatabase<{}>; schema: string }) {\n    super();\n    this.client = client;\n    this.schema = schema;\n  }\n\n  /** @deprecated use getEvals instead */\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    try {\n      const baseQuery = `SELECT * FROM ${getTableName({ indexName: TABLE_EVALS, schemaName: getSchemaName(this.schema) })} WHERE agent_name = $1`;\n      const typeCondition =\n        type === 'test'\n          ? \" AND test_info IS NOT NULL AND test_info->>'testPath' IS NOT NULL\"\n          : type === 'live'\n            ? \" AND (test_info IS NULL OR test_info->>'testPath' IS NULL)\"\n            : '';\n\n      const query = `${baseQuery}${typeCondition} ORDER BY created_at DESC`;\n\n      const rows = await this.client.manyOrNone(query, [agentName]);\n      return rows?.map(row => transformEvalRow(row)) ?? [];\n    } catch (error) {\n      // Handle case where table doesn't exist yet\n      if (error instanceof Error && error.message.includes('relation') && error.message.includes('does not exist')) {\n        return [];\n      }\n      console.error('Failed to get evals for the specified agent: ' + (error as any)?.message);\n      throw error;\n    }\n  }\n\n  async getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs = {},\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    const tableName = getTableName({ indexName: TABLE_EVALS, schemaName: getSchemaName(this.schema) });\n\n    const { agentName, type, page = 0, perPage = 100, dateRange } = options;\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n\n    const conditions: string[] = [];\n    const queryParams: any[] = [];\n    let paramIndex = 1;\n\n    if (agentName) {\n      conditions.push(`agent_name = $${paramIndex++}`);\n      queryParams.push(agentName);\n    }\n\n    if (type === 'test') {\n      conditions.push(`(test_info IS NOT NULL AND test_info->>'testPath' IS NOT NULL)`);\n    } else if (type === 'live') {\n      conditions.push(`(test_info IS NULL OR test_info->>'testPath' IS NULL)`);\n    }\n\n    if (fromDate) {\n      conditions.push(`created_at >= $${paramIndex++}`);\n      queryParams.push(fromDate);\n    }\n\n    if (toDate) {\n      conditions.push(`created_at <= $${paramIndex++}`);\n      queryParams.push(toDate);\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    const countQuery = `SELECT COUNT(*) FROM ${tableName} ${whereClause}`;\n    try {\n      const countResult = await this.client.one(countQuery, queryParams);\n      const total = parseInt(countResult.count, 10);\n      const currentOffset = page * perPage;\n\n      if (total === 0) {\n        return {\n          evals: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataQuery = `SELECT * FROM ${tableName} ${whereClause} ORDER BY created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n      const rows = await this.client.manyOrNone(dataQuery, [...queryParams, perPage, currentOffset]);\n\n      return {\n        evals: rows?.map(row => transformEvalRow(row)) ?? [],\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + (rows?.length ?? 0) < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_EVALS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            agentName: agentName || 'all',\n            type: type || 'all',\n            page,\n            perPage,\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException(mastraError);\n      throw mastraError;\n    }\n  }\n}\n","import { MessageList } from '@mastra/core/agent';\nimport type { MastraMessageContentV2 } from '@mastra/core/agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MastraMessageV1, MastraMessageV2, StorageThreadType } from '@mastra/core/memory';\nimport {\n  MemoryStorage,\n  resolveMessageLimit,\n  TABLE_MESSAGES,\n  TABLE_RESOURCES,\n  TABLE_THREADS,\n} from '@mastra/core/storage';\nimport type {\n  StorageGetMessagesArg,\n  PaginationInfo,\n  StorageResourceType,\n  ThreadSortOptions,\n} from '@mastra/core/storage';\nimport type { IDatabase } from 'pg-promise';\nimport type { StoreOperationsPG } from '../operations';\nimport { getTableName, getSchemaName } from '../utils';\n\n// Database row type that includes timezone-aware columns\ntype MessageRowFromDB = {\n  id: string;\n  content: string | any;\n  role: string;\n  type?: string;\n  createdAt: Date | string;\n  createdAtZ?: Date | string;\n  threadId: string;\n  resourceId: string;\n};\n\nexport class MemoryPG extends MemoryStorage {\n  private client: IDatabase<{}>;\n  private schema: string;\n  private operations: StoreOperationsPG;\n\n  constructor({\n    client,\n    schema,\n    operations,\n  }: {\n    client: IDatabase<{}>;\n    schema: string;\n    operations: StoreOperationsPG;\n  }) {\n    super();\n    this.client = client;\n    this.schema = schema;\n    this.operations = operations;\n  }\n\n  /**\n   * Normalizes message row from database by applying createdAtZ fallback\n   */\n  private normalizeMessageRow(row: MessageRowFromDB): Omit<MessageRowFromDB, 'createdAtZ'> {\n    return {\n      id: row.id,\n      content: row.content,\n      role: row.role,\n      type: row.type,\n      createdAt: row.createdAtZ || row.createdAt,\n      threadId: row.threadId,\n      resourceId: row.resourceId,\n    };\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    try {\n      const tableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n\n      const thread = await this.client.oneOrNone<StorageThreadType & { createdAtZ: Date; updatedAtZ: Date }>(\n        `SELECT * FROM ${tableName} WHERE id = $1`,\n        [threadId],\n      );\n\n      if (!thread) {\n        return null;\n      }\n\n      return {\n        id: thread.id,\n        resourceId: thread.resourceId,\n        title: thread.title,\n        metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n        createdAt: thread.createdAtZ || thread.createdAt,\n        updatedAt: thread.updatedAtZ || thread.updatedAt,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_THREAD_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * @deprecated use getThreadsByResourceIdPaginated instead\n   */\n  public async getThreadsByResourceId(args: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    const resourceId = args.resourceId;\n    const orderBy = this.castThreadOrderBy(args.orderBy);\n    const sortDirection = this.castThreadSortDirection(args.sortDirection);\n\n    try {\n      const tableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n      const baseQuery = `FROM ${tableName} WHERE \"resourceId\" = $1`;\n      const queryParams: any[] = [resourceId];\n\n      const dataQuery = `SELECT id, \"resourceId\", title, metadata, \"createdAt\", \"updatedAt\" ${baseQuery} ORDER BY \"${orderBy}\" ${sortDirection}`;\n      const rows = await this.client.manyOrNone(dataQuery, queryParams);\n      return (rows || []).map(thread => ({\n        ...thread,\n        metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n        createdAt: thread.createdAt,\n        updatedAt: thread.updatedAt,\n      }));\n    } catch (error) {\n      this.logger.error(`Error getting threads for resource ${resourceId}:`, error);\n      return [];\n    }\n  }\n\n  public async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    const { resourceId, page = 0, perPage: perPageInput } = args;\n    const orderBy = this.castThreadOrderBy(args.orderBy);\n    const sortDirection = this.castThreadSortDirection(args.sortDirection);\n    try {\n      const tableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n      const baseQuery = `FROM ${tableName} WHERE \"resourceId\" = $1`;\n      const queryParams: any[] = [resourceId];\n      const perPage = perPageInput !== undefined ? perPageInput : 100;\n      const currentOffset = page * perPage;\n\n      const countQuery = `SELECT COUNT(*) ${baseQuery}`;\n      const countResult = await this.client.one(countQuery, queryParams);\n      const total = parseInt(countResult.count, 10);\n\n      if (total === 0) {\n        return {\n          threads: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataQuery = `SELECT id, \"resourceId\", title, metadata, \"createdAt\", \"updatedAt\" ${baseQuery} ORDER BY \"${orderBy}\" ${sortDirection} LIMIT $2 OFFSET $3`;\n      const rows = await this.client.manyOrNone(dataQuery, [...queryParams, perPage, currentOffset]);\n\n      const threads = (rows || []).map(thread => ({\n        ...thread,\n        metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n        createdAt: thread.createdAt, // Assuming already Date objects or ISO strings\n        updatedAt: thread.updatedAt,\n      }));\n\n      return {\n        threads,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + threads.length < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_THREADS_BY_RESOURCE_ID_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            resourceId,\n            page,\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException(mastraError);\n      return { threads: [], total: 0, page, perPage: perPageInput || 100, hasMore: false };\n    }\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    try {\n      const tableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n      await this.client.none(\n        `INSERT INTO ${tableName} (\n          id,\n          \"resourceId\",\n          title,\n          metadata,\n          \"createdAt\",\n          \"createdAtZ\",\n          \"updatedAt\",\n          \"updatedAtZ\"\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n        ON CONFLICT (id) DO UPDATE SET\n          \"resourceId\" = EXCLUDED.\"resourceId\",\n          title = EXCLUDED.title,\n          metadata = EXCLUDED.metadata,\n          \"createdAt\" = EXCLUDED.\"createdAt\",\n          \"createdAtZ\" = EXCLUDED.\"createdAtZ\",\n          \"updatedAt\" = EXCLUDED.\"updatedAt\",\n          \"updatedAtZ\" = EXCLUDED.\"updatedAtZ\"`,\n        [\n          thread.id,\n          thread.resourceId,\n          thread.title,\n          thread.metadata ? JSON.stringify(thread.metadata) : null,\n          thread.createdAt,\n          thread.createdAt,\n          thread.updatedAt,\n          thread.updatedAt,\n        ],\n      );\n\n      return thread;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_SAVE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId: thread.id,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const threadTableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n    // First get the existing thread to merge metadata\n    const existingThread = await this.getThreadById({ threadId: id });\n    if (!existingThread) {\n      throw new MastraError({\n        id: 'MASTRA_STORAGE_PG_STORE_UPDATE_THREAD_FAILED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: `Thread ${id} not found`,\n        details: {\n          threadId: id,\n          title,\n        },\n      });\n    }\n\n    // Merge the existing metadata with the new metadata\n    const mergedMetadata = {\n      ...existingThread.metadata,\n      ...metadata,\n    };\n\n    try {\n      const thread = await this.client.one<StorageThreadType & { createdAtZ: Date; updatedAtZ: Date }>(\n        `UPDATE ${threadTableName}\n                    SET \n                        title = $1,\n                        metadata = $2,\n                        \"updatedAt\" = $3,\n                        \"updatedAtZ\" = $3\n                    WHERE id = $4\n                    RETURNING *\n                `,\n        [title, mergedMetadata, new Date().toISOString(), id],\n      );\n\n      return {\n        id: thread.id,\n        resourceId: thread.resourceId,\n        title: thread.title,\n        metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n        createdAt: thread.createdAtZ || thread.createdAt,\n        updatedAt: thread.updatedAtZ || thread.updatedAt,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_UPDATE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId: id,\n            title,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    try {\n      const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      const threadTableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n      await this.client.tx(async t => {\n        // First delete all messages associated with this thread\n        await t.none(`DELETE FROM ${tableName} WHERE thread_id = $1`, [threadId]);\n\n        // Then delete the thread\n        await t.none(`DELETE FROM ${threadTableName} WHERE id = $1`, [threadId]);\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_DELETE_THREAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  private async _getIncludedMessages({\n    threadId,\n    selectBy,\n    orderByStatement,\n  }: {\n    threadId: string;\n    selectBy: StorageGetMessagesArg['selectBy'];\n    orderByStatement: string;\n  }) {\n    if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n    const include = selectBy?.include;\n    if (!include) return null;\n\n    const unionQueries: string[] = [];\n    const params: any[] = [];\n    let paramIdx = 1;\n    const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n\n    for (const inc of include) {\n      const { id, withPreviousMessages = 0, withNextMessages = 0 } = inc;\n      // if threadId is provided, use it, otherwise use threadId from args\n      const searchId = inc.threadId || threadId;\n      unionQueries.push(\n        `\n            SELECT * FROM (\n              WITH ordered_messages AS (\n                SELECT \n                  *,\n                  ROW_NUMBER() OVER (${orderByStatement}) as row_num\n                FROM ${tableName}\n                WHERE thread_id = $${paramIdx}\n              )\n              SELECT\n                m.id,\n                m.content,\n                m.role,\n                m.type,\n                m.\"createdAt\",\n                m.\"createdAtZ\",\n                m.thread_id AS \"threadId\",\n                m.\"resourceId\"\n              FROM ordered_messages m\n              WHERE m.id = $${paramIdx + 1}\n              OR EXISTS (\n                SELECT 1 FROM ordered_messages target\n                WHERE target.id = $${paramIdx + 1}\n                AND (\n                  -- Get previous messages based on the max withPreviousMessages\n                  (m.row_num <= target.row_num + $${paramIdx + 2} AND m.row_num > target.row_num)\n                  OR\n                  -- Get next messages based on the max withNextMessages\n                  (m.row_num >= target.row_num - $${paramIdx + 3} AND m.row_num < target.row_num)\n                )\n              )\n            ) AS query_${paramIdx}\n            `, // Keep ASC for final sorting after fetching context\n      );\n      params.push(searchId, id, withPreviousMessages, withNextMessages);\n      paramIdx += 4;\n    }\n    const finalQuery = unionQueries.join(' UNION ALL ') + ' ORDER BY \"createdAt\" ASC';\n    const includedRows = await this.client.manyOrNone(finalQuery, params);\n    const seen = new Set<string>();\n    const dedupedRows = includedRows.filter(row => {\n      if (seen.has(row.id)) return false;\n      seen.add(row.id);\n      return true;\n    });\n    return dedupedRows;\n  }\n\n  private parseRow(row: MessageRowFromDB): MastraMessageV2 {\n    const normalized = this.normalizeMessageRow(row);\n    let content = normalized.content;\n    try {\n      content = JSON.parse(normalized.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    return {\n      id: normalized.id,\n      content,\n      role: normalized.role as MastraMessageV2['role'],\n      createdAt: new Date(normalized.createdAt as string),\n      threadId: normalized.threadId,\n      resourceId: normalized.resourceId,\n      ...(normalized.type && normalized.type !== 'v2' ? { type: normalized.type } : {}),\n    } satisfies MastraMessageV2;\n  }\n\n  /**\n   * @deprecated use getMessagesPaginated instead\n   */\n  public async getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  public async getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  public async getMessages(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    const { threadId, resourceId, format, selectBy } = args;\n    const selectStatement = `SELECT id, content, role, type, \"createdAt\", \"createdAtZ\", thread_id AS \"threadId\", \"resourceId\"`;\n    const orderByStatement = `ORDER BY \"createdAt\" DESC`;\n    const limit = resolveMessageLimit({ last: selectBy?.last, defaultLimit: 40 });\n\n    try {\n      if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n      let rows: any[] = [];\n      const include = selectBy?.include || [];\n\n      if (include?.length) {\n        const includeMessages = await this._getIncludedMessages({ threadId, selectBy, orderByStatement });\n        if (includeMessages) {\n          rows.push(...includeMessages);\n        }\n      }\n\n      const excludeIds = rows.map(m => m.id);\n      const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      const excludeIdsParam = excludeIds.map((_, idx) => `$${idx + 2}`).join(', ');\n      let query = `${selectStatement} FROM ${tableName} WHERE thread_id = $1 \n        ${excludeIds.length ? `AND id NOT IN (${excludeIdsParam})` : ''}\n        ${orderByStatement}\n        LIMIT $${excludeIds.length + 2}\n        `;\n      const queryParams: any[] = [threadId, ...excludeIds, limit];\n      const remainingRows = await this.client.manyOrNone(query, queryParams);\n      rows.push(...remainingRows);\n\n      const fetchedMessages = (rows || []).map((row: MessageRowFromDB) => {\n        const message = this.normalizeMessageRow(row);\n        if (typeof message.content === 'string') {\n          try {\n            message.content = JSON.parse(message.content);\n          } catch {\n            /* ignore */\n          }\n        }\n        if (message.type === 'v2') delete message.type;\n        return message as MastraMessageV1;\n      });\n\n      // Sort all messages by creation date\n      const sortedMessages = fetchedMessages.sort(\n        (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime(),\n      );\n\n      return format === 'v2'\n        ? sortedMessages.map(\n            m =>\n              ({ ...m, content: m.content || { format: 2, parts: [{ type: 'text', text: '' }] } }) as MastraMessageV2,\n          )\n        : sortedMessages;\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId,\n            resourceId: resourceId ?? '',\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException(mastraError);\n      return [];\n    }\n  }\n\n  public async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format: 'v1';\n  }): Promise<MastraMessageV1[]>;\n  public async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format?: 'v2';\n  }): Promise<MastraMessageV2[]>;\n  public async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    if (messageIds.length === 0) return [];\n    const selectStatement = `SELECT id, content, role, type, \"createdAt\", \"createdAtZ\", thread_id AS \"threadId\", \"resourceId\"`;\n\n    try {\n      const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      const query = `\n        ${selectStatement} FROM ${tableName} \n        WHERE id IN (${messageIds.map((_, i) => `$${i + 1}`).join(', ')})\n        ORDER BY \"createdAt\" DESC\n      `;\n      const resultRows = await this.client.manyOrNone(query, messageIds);\n\n      const list = new MessageList().add(\n        resultRows.map(row => this.parseRow(row)),\n        'memory',\n      );\n      if (format === `v1`) return list.get.all.v1();\n      return list.get.all.v2();\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_MESSAGES_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            messageIds: JSON.stringify(messageIds),\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException(mastraError);\n      return [];\n    }\n  }\n\n  public async getMessagesPaginated(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }> {\n    const { threadId, resourceId, format, selectBy } = args;\n    const { page = 0, perPage: perPageInput, dateRange } = selectBy?.pagination || {};\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n\n    const selectStatement = `SELECT id, content, role, type, \"createdAt\", \"createdAtZ\", thread_id AS \"threadId\", \"resourceId\"`;\n    const orderByStatement = `ORDER BY \"createdAt\" DESC`;\n\n    const messages: MessageRowFromDB[] = [];\n\n    try {\n      if (!threadId.trim()) throw new Error('threadId must be a non-empty string');\n\n      if (selectBy?.include?.length) {\n        const includeMessages = await this._getIncludedMessages({ threadId, selectBy, orderByStatement });\n        if (includeMessages) {\n          messages.push(...includeMessages);\n        }\n      }\n\n      const perPage =\n        perPageInput !== undefined ? perPageInput : resolveMessageLimit({ last: selectBy?.last, defaultLimit: 40 });\n      const currentOffset = page * perPage;\n\n      const conditions: string[] = [`thread_id = $1`];\n      const queryParams: any[] = [threadId];\n      let paramIndex = 2;\n\n      if (fromDate) {\n        conditions.push(`\"createdAt\" >= $${paramIndex++}`);\n        queryParams.push(fromDate);\n      }\n      if (toDate) {\n        conditions.push(`\"createdAt\" <= $${paramIndex++}`);\n        queryParams.push(toDate);\n      }\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      const countQuery = `SELECT COUNT(*) FROM ${tableName} ${whereClause}`;\n      const countResult = await this.client.one(countQuery, queryParams);\n      const total = parseInt(countResult.count, 10);\n\n      if (total === 0 && messages.length === 0) {\n        return {\n          messages: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const excludeIds = messages.map(m => m.id);\n      const excludeIdsParam = excludeIds.map((_, idx) => `$${idx + paramIndex}`).join(', ');\n      paramIndex += excludeIds.length;\n\n      const dataQuery = `${selectStatement} FROM ${tableName} ${whereClause} ${excludeIds.length ? `AND id NOT IN (${excludeIdsParam})` : ''}${orderByStatement} LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n      const rows = await this.client.manyOrNone(dataQuery, [...queryParams, ...excludeIds, perPage, currentOffset]);\n      messages.push(...(rows || []));\n\n      // Parse content back to objects if they were stringified during storage\n      const messagesWithParsedContent: MastraMessageV2[] = messages.map((row: MessageRowFromDB) => {\n        const message = this.normalizeMessageRow(row);\n        if (typeof message.content === 'string') {\n          try {\n            return { ...message, content: JSON.parse(message.content) } as MastraMessageV2;\n          } catch {\n            // If parsing fails, leave as string (V1 message)\n            return message as MastraMessageV2;\n          }\n        }\n        return message as MastraMessageV2;\n      });\n\n      const list = new MessageList().add(messagesWithParsedContent, 'memory');\n      const messagesToReturn = format === `v2` ? list.get.all.v2() : list.get.all.v1();\n\n      return {\n        messages: messagesToReturn,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + rows.length < total,\n      };\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_MESSAGES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId,\n            resourceId: resourceId ?? '',\n            page,\n          },\n        },\n        error,\n      );\n      this.logger?.error?.(mastraError.toString());\n      this.logger?.trackException(mastraError);\n      return { messages: [], total: 0, page, perPage: perPageInput || 40, hasMore: false };\n    }\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages({\n    messages,\n    format,\n  }:\n    | { messages: MastraMessageV1[]; format?: undefined | 'v1' }\n    | { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    if (messages.length === 0) return messages;\n\n    const threadId = messages[0]?.threadId;\n    if (!threadId) {\n      throw new MastraError({\n        id: 'MASTRA_STORAGE_PG_STORE_SAVE_MESSAGES_FAILED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.THIRD_PARTY,\n        text: `Thread ID is required`,\n      });\n    }\n\n    // Check if thread exists\n    const thread = await this.getThreadById({ threadId });\n    if (!thread) {\n      throw new MastraError({\n        id: 'MASTRA_STORAGE_PG_STORE_SAVE_MESSAGES_FAILED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.THIRD_PARTY,\n        text: `Thread ${threadId} not found`,\n        details: {\n          threadId,\n        },\n      });\n    }\n\n    try {\n      const tableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      await this.client.tx(async t => {\n        // Execute message inserts and thread update in parallel for better performance\n        const messageInserts = messages.map(message => {\n          if (!message.threadId) {\n            throw new Error(\n              `Expected to find a threadId for message, but couldn't find one. An unexpected error has occurred.`,\n            );\n          }\n          if (!message.resourceId) {\n            throw new Error(\n              `Expected to find a resourceId for message, but couldn't find one. An unexpected error has occurred.`,\n            );\n          }\n          return t.none(\n            `INSERT INTO ${tableName} (id, thread_id, content, \"createdAt\", \"createdAtZ\", role, type, \"resourceId\") \n             VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n             ON CONFLICT (id) DO UPDATE SET\n              thread_id = EXCLUDED.thread_id,\n              content = EXCLUDED.content,\n              role = EXCLUDED.role,\n              type = EXCLUDED.type,\n              \"resourceId\" = EXCLUDED.\"resourceId\"`,\n            [\n              message.id,\n              message.threadId,\n              typeof message.content === 'string' ? message.content : JSON.stringify(message.content),\n              message.createdAt || new Date().toISOString(),\n              message.createdAt || new Date().toISOString(),\n              message.role,\n              message.type || 'v2',\n              message.resourceId,\n            ],\n          );\n        });\n\n        const threadTableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n        const threadUpdate = t.none(\n          `UPDATE ${threadTableName} \n                        SET \n                            \"updatedAt\" = $1,\n                            \"updatedAtZ\" = $1\n                        WHERE id = $2\n                    `,\n          [new Date().toISOString(), threadId],\n        );\n\n        await Promise.all([...messageInserts, threadUpdate]);\n      });\n\n      // Parse content back to objects if they were stringified during storage\n      const messagesWithParsedContent = messages.map(message => {\n        if (typeof message.content === 'string') {\n          try {\n            return { ...message, content: JSON.parse(message.content) };\n          } catch {\n            // If parsing fails, leave as string (V1 message)\n            return message;\n          }\n        }\n        return message;\n      });\n\n      const list = new MessageList().add(messagesWithParsedContent, 'memory');\n      if (format === `v2`) return list.get.all.v2();\n      return list.get.all.v1();\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_SAVE_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            threadId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraMessageV2, 'createdAt'>> & {\n      id: string;\n      content?: {\n        metadata?: MastraMessageContentV2['metadata'];\n        content?: MastraMessageContentV2['content'];\n      };\n    })[];\n  }): Promise<MastraMessageV2[]> {\n    if (messages.length === 0) {\n      return [];\n    }\n\n    const messageIds = messages.map(m => m.id);\n\n    const selectQuery = `SELECT id, content, role, type, \"createdAt\", \"createdAtZ\", thread_id AS \"threadId\", \"resourceId\" FROM ${getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) })} WHERE id IN ($1:list)`;\n\n    const existingMessagesDb = await this.client.manyOrNone(selectQuery, [messageIds]);\n\n    if (existingMessagesDb.length === 0) {\n      return [];\n    }\n\n    // Parse content from string to object for merging\n    const existingMessages: MastraMessageV2[] = existingMessagesDb.map(msg => {\n      if (typeof msg.content === 'string') {\n        try {\n          msg.content = JSON.parse(msg.content);\n        } catch {\n          // ignore if not valid json\n        }\n      }\n      return msg as MastraMessageV2;\n    });\n\n    const threadIdsToUpdate = new Set<string>();\n\n    await this.client.tx(async t => {\n      const queries = [];\n      const columnMapping: Record<string, string> = {\n        threadId: 'thread_id',\n      };\n\n      for (const existingMessage of existingMessages) {\n        const updatePayload = messages.find(m => m.id === existingMessage.id);\n        if (!updatePayload) continue;\n\n        const { id, ...fieldsToUpdate } = updatePayload;\n        if (Object.keys(fieldsToUpdate).length === 0) continue;\n\n        threadIdsToUpdate.add(existingMessage.threadId!);\n        if (updatePayload.threadId && updatePayload.threadId !== existingMessage.threadId) {\n          threadIdsToUpdate.add(updatePayload.threadId);\n        }\n\n        const setClauses: string[] = [];\n        const values: any[] = [];\n        let paramIndex = 1;\n\n        const updatableFields = { ...fieldsToUpdate };\n\n        // Special handling for content: merge in code, then update the whole field\n        if (updatableFields.content) {\n          const newContent = {\n            ...existingMessage.content,\n            ...updatableFields.content,\n            // Deep merge metadata if it exists on both\n            ...(existingMessage.content?.metadata && updatableFields.content.metadata\n              ? {\n                  metadata: {\n                    ...existingMessage.content.metadata,\n                    ...updatableFields.content.metadata,\n                  },\n                }\n              : {}),\n          };\n          setClauses.push(`content = $${paramIndex++}`);\n          values.push(newContent);\n          delete updatableFields.content;\n        }\n\n        for (const key in updatableFields) {\n          if (Object.prototype.hasOwnProperty.call(updatableFields, key)) {\n            const dbColumn = columnMapping[key] || key;\n            setClauses.push(`\"${dbColumn}\" = $${paramIndex++}`);\n            values.push(updatableFields[key as keyof typeof updatableFields]);\n          }\n        }\n\n        if (setClauses.length > 0) {\n          values.push(id);\n          const sql = `UPDATE ${getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) })} SET ${setClauses.join(', ')} WHERE id = $${paramIndex}`;\n          queries.push(t.none(sql, values));\n        }\n      }\n\n      if (threadIdsToUpdate.size > 0) {\n        queries.push(\n          t.none(\n            `UPDATE ${getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) })} SET \"updatedAt\" = NOW(), \"updatedAtZ\" = NOW() WHERE id IN ($1:list)`,\n            [Array.from(threadIdsToUpdate)],\n          ),\n        );\n      }\n\n      if (queries.length > 0) {\n        await t.batch(queries);\n      }\n    });\n\n    // Re-fetch to return the fully updated messages\n    const updatedMessages = await this.client.manyOrNone<MessageRowFromDB>(selectQuery, [messageIds]);\n\n    return (updatedMessages || []).map((row: MessageRowFromDB) => {\n      const message = this.normalizeMessageRow(row);\n      if (typeof message.content === 'string') {\n        try {\n          return { ...message, content: JSON.parse(message.content) } as MastraMessageV2;\n        } catch {\n          /* ignore */\n        }\n      }\n      return message as MastraMessageV2;\n    });\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    try {\n      const messageTableName = getTableName({ indexName: TABLE_MESSAGES, schemaName: getSchemaName(this.schema) });\n      const threadTableName = getTableName({ indexName: TABLE_THREADS, schemaName: getSchemaName(this.schema) });\n\n      await this.client.tx(async t => {\n        // Get thread IDs for all messages\n        const placeholders = messageIds.map((_, idx) => `$${idx + 1}`).join(',');\n        const messages = await t.manyOrNone(\n          `SELECT DISTINCT thread_id FROM ${messageTableName} WHERE id IN (${placeholders})`,\n          messageIds,\n        );\n\n        const threadIds = messages?.map(msg => msg.thread_id).filter(Boolean) || [];\n\n        // Delete all messages\n        await t.none(`DELETE FROM ${messageTableName} WHERE id IN (${placeholders})`, messageIds);\n\n        // Update thread timestamps\n        if (threadIds.length > 0) {\n          const updatePromises = threadIds.map(threadId =>\n            t.none(`UPDATE ${threadTableName} SET \"updatedAt\" = NOW(), \"updatedAtZ\" = NOW() WHERE id = $1`, [threadId]),\n          );\n          await Promise.all(updatePromises);\n        }\n      });\n\n      // TODO: Delete from vector store if semantic recall is enabled\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_DELETE_MESSAGES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { messageIds: messageIds.join(', ') },\n        },\n        error,\n      );\n    }\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    const tableName = getTableName({ indexName: TABLE_RESOURCES, schemaName: getSchemaName(this.schema) });\n    const result = await this.client.oneOrNone<StorageResourceType & { createdAtZ: Date; updatedAtZ: Date }>(\n      `SELECT * FROM ${tableName} WHERE id = $1`,\n      [resourceId],\n    );\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      id: result.id,\n      createdAt: result.createdAtZ || result.createdAt,\n      updatedAt: result.updatedAtZ || result.updatedAt,\n      workingMemory: result.workingMemory,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n    };\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    await this.operations.insert({\n      tableName: TABLE_RESOURCES,\n      record: {\n        ...resource,\n        metadata: JSON.stringify(resource.metadata),\n      },\n    });\n\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    const existingResource = await this.getResourceById({ resourceId });\n\n    if (!existingResource) {\n      // Create new resource if it doesn't exist\n      const newResource: StorageResourceType = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n      return this.saveResource({ resource: newResource });\n    }\n\n    const updatedResource = {\n      ...existingResource,\n      workingMemory: workingMemory !== undefined ? workingMemory : existingResource.workingMemory,\n      metadata: {\n        ...existingResource.metadata,\n        ...metadata,\n      },\n      updatedAt: new Date(),\n    };\n\n    const tableName = getTableName({ indexName: TABLE_RESOURCES, schemaName: getSchemaName(this.schema) });\n\n    const updates: string[] = [];\n    const values: any[] = [];\n    let paramIndex = 1;\n\n    if (workingMemory !== undefined) {\n      updates.push(`\"workingMemory\" = $${paramIndex}`);\n      values.push(workingMemory);\n      paramIndex++;\n    }\n\n    if (metadata) {\n      updates.push(`metadata = $${paramIndex}`);\n      values.push(JSON.stringify(updatedResource.metadata));\n      paramIndex++;\n    }\n\n    updates.push(`\"updatedAt\" = $${paramIndex}`);\n    values.push(updatedResource.updatedAt.toISOString());\n    updates.push(`\"updatedAtZ\" = $${paramIndex++}`);\n    values.push(updatedResource.updatedAt.toISOString());\n\n    paramIndex++;\n\n    values.push(resourceId);\n\n    await this.client.none(`UPDATE ${tableName} SET ${updates.join(', ')} WHERE id = $${paramIndex}`, values);\n\n    return updatedResource;\n  }\n}\n","import type { TracingStrategy } from '@mastra/core/ai-tracing';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { AI_SPAN_SCHEMA, ObservabilityStorage, TABLE_AI_SPANS } from '@mastra/core/storage';\nimport type {\n  AISpanRecord,\n  AITraceRecord,\n  AITracesPaginatedArg,\n  CreateAISpanRecord,\n  PaginationInfo,\n  UpdateAISpanRecord,\n} from '@mastra/core/storage';\nimport type { IDatabase } from 'pg-promise';\nimport type { StoreOperationsPG } from '../operations';\nimport { buildDateRangeFilter, prepareWhereClause, transformFromSqlRow, getTableName, getSchemaName } from '../utils';\n\nexport class ObservabilityPG extends ObservabilityStorage {\n  public client: IDatabase<{}>;\n  private operations: StoreOperationsPG;\n  private schema?: string;\n\n  constructor({\n    client,\n    operations,\n    schema,\n  }: {\n    client: IDatabase<{}>;\n    operations: StoreOperationsPG;\n    schema?: string;\n  }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n    this.schema = schema;\n  }\n\n  public override get aiTracingStrategy(): {\n    preferred: TracingStrategy;\n    supported: TracingStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates',\n      supported: ['batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createAISpan(span: CreateAISpanRecord): Promise<void> {\n    try {\n      const startedAt = span.startedAt instanceof Date ? span.startedAt.toISOString() : span.startedAt;\n      const endedAt = span.endedAt instanceof Date ? span.endedAt.toISOString() : span.endedAt;\n\n      const record = {\n        ...span,\n        startedAt,\n        endedAt,\n        startedAtZ: startedAt,\n        endedAtZ: endedAt,\n        // Note: createdAt/updatedAt will be set by database triggers\n      };\n\n      return this.operations.insert({ tableName: TABLE_AI_SPANS, record });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_CREATE_AI_SPAN_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId: span.spanId,\n            traceId: span.traceId,\n            spanType: span.spanType,\n            spanName: span.name,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async getAITrace(traceId: string): Promise<AITraceRecord | null> {\n    try {\n      const tableName = getTableName({\n        indexName: TABLE_AI_SPANS,\n        schemaName: getSchemaName(this.schema),\n      });\n\n      const spans = await this.client.manyOrNone<AISpanRecord>(\n        `SELECT\n          \"traceId\", \"spanId\", \"parentSpanId\", \"name\", \"scope\", \"spanType\",\n          \"attributes\", \"metadata\", \"links\", \"input\", \"output\", \"error\", \"isEvent\",\n          \"startedAtZ\" as \"startedAt\", \"endedAtZ\" as \"endedAt\",\n          \"createdAtZ\" as \"createdAt\", \"updatedAtZ\" as \"updatedAt\"\n        FROM ${tableName}\n        WHERE \"traceId\" = $1\n        ORDER BY \"startedAtZ\" DESC`,\n        [traceId],\n      );\n\n      if (!spans || spans.length === 0) {\n        return null;\n      }\n\n      return {\n        traceId,\n        spans: spans.map(span =>\n          transformFromSqlRow<AISpanRecord>({\n            tableName: TABLE_AI_SPANS,\n            sqlRow: span,\n          }),\n        ),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_GET_AI_TRACE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async updateAISpan({\n    spanId,\n    traceId,\n    updates,\n  }: {\n    spanId: string;\n    traceId: string;\n    updates: Partial<UpdateAISpanRecord>;\n  }): Promise<void> {\n    try {\n      const data = { ...updates };\n      if (data.endedAt instanceof Date) {\n        data.endedAt = data.endedAt.toISOString() as any;\n      }\n      if (data.startedAt instanceof Date) {\n        data.startedAt = data.startedAt.toISOString() as any;\n      }\n      // Note: updatedAt will be set by database trigger automatically\n\n      await this.operations.update({\n        tableName: TABLE_AI_SPANS,\n        keys: { spanId, traceId },\n        data,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_UPDATE_AI_SPAN_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            spanId,\n            traceId,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async getAITracesPaginated({\n    filters,\n    pagination,\n  }: AITracesPaginatedArg): Promise<{ pagination: PaginationInfo; spans: AISpanRecord[] }> {\n    const page = pagination?.page ?? 0;\n    const perPage = pagination?.perPage ?? 10;\n    const { entityId, entityType, ...actualFilters } = filters || {};\n\n    const filtersWithDateRange: Record<string, any> = {\n      ...actualFilters,\n      ...buildDateRangeFilter(pagination?.dateRange, 'startedAtZ'),\n      parentSpanId: null, // Only get root spans for traces\n    };\n\n    const whereClause = prepareWhereClause(filtersWithDateRange, AI_SPAN_SCHEMA);\n\n    let actualWhereClause = whereClause.sql;\n    let currentParamIndex = whereClause.args.length + 1;\n\n    // Handle entity filtering\n    if (entityId && entityType) {\n      let name = '';\n      if (entityType === 'workflow') {\n        name = `workflow run: '${entityId}'`;\n      } else if (entityType === 'agent') {\n        name = `agent run: '${entityId}'`;\n      } else {\n        const error = new MastraError({\n          id: 'PG_STORE_GET_AI_TRACES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            entityType,\n          },\n          text: `Cannot filter by entity type: ${entityType}`,\n        });\n        this.logger?.trackException(error);\n        throw error;\n      }\n\n      whereClause.args.push(name);\n      const statement = `\"name\" = $${currentParamIndex++}`;\n\n      if (actualWhereClause) {\n        actualWhereClause += ` AND ${statement}`;\n      } else {\n        actualWhereClause = ` WHERE ${statement}`;\n      }\n    }\n\n    const tableName = getTableName({\n      indexName: TABLE_AI_SPANS,\n      schemaName: getSchemaName(this.schema),\n    });\n\n    try {\n      // Get total count\n      const countResult = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) FROM ${tableName}${actualWhereClause}`,\n        whereClause.args,\n      );\n      const count = Number(countResult?.count ?? 0);\n\n      if (count === 0) {\n        return {\n          pagination: {\n            total: 0,\n            page,\n            perPage,\n            hasMore: false,\n          },\n          spans: [],\n        };\n      }\n\n      // Get paginated spans\n      const spans = await this.client.manyOrNone<AISpanRecord>(\n        `SELECT\n          \"traceId\", \"spanId\", \"parentSpanId\", \"name\", \"scope\", \"spanType\",\n          \"attributes\", \"metadata\", \"links\", \"input\", \"output\", \"error\", \"isEvent\",\n          \"startedAtZ\" as \"startedAt\", \"endedAtZ\" as \"endedAt\",\n          \"createdAtZ\" as \"createdAt\", \"updatedAtZ\" as \"updatedAt\"\n        FROM ${tableName}${actualWhereClause}\n        ORDER BY \"startedAtZ\" DESC\n        LIMIT $${currentParamIndex} OFFSET $${currentParamIndex + 1}`,\n        [...whereClause.args, perPage, page * perPage],\n      );\n\n      return {\n        pagination: {\n          total: count,\n          page,\n          perPage,\n          hasMore: spans.length === perPage,\n        },\n        spans: spans.map(span =>\n          transformFromSqlRow<AISpanRecord>({\n            tableName: TABLE_AI_SPANS,\n            sqlRow: span,\n          }),\n        ),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_GET_AI_TRACES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchCreateAISpans(args: { records: CreateAISpanRecord[] }): Promise<void> {\n    try {\n      const records = args.records.map(record => {\n        const startedAt = record.startedAt instanceof Date ? record.startedAt.toISOString() : record.startedAt;\n        const endedAt = record.endedAt instanceof Date ? record.endedAt.toISOString() : record.endedAt;\n\n        return {\n          ...record,\n          startedAt,\n          endedAt,\n          startedAtZ: startedAt,\n          endedAtZ: endedAt,\n          // Note: createdAt/updatedAt will be set by database triggers\n        };\n      });\n\n      return this.operations.batchInsert({\n        tableName: TABLE_AI_SPANS,\n        records,\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_BATCH_CREATE_AI_SPANS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchUpdateAISpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<UpdateAISpanRecord>;\n    }[];\n  }): Promise<void> {\n    try {\n      return this.operations.batchUpdate({\n        tableName: TABLE_AI_SPANS,\n        updates: args.records.map(record => {\n          const data: Partial<UpdateAISpanRecord> & {\n            endedAtZ?: string;\n            startedAtZ?: string;\n          } = {\n            ...record.updates,\n          };\n          if (data.endedAt instanceof Date) {\n            const endedAt = data.endedAt.toISOString();\n            data.endedAt = endedAt as any;\n            data.endedAtZ = endedAt;\n          }\n          if (data.startedAt instanceof Date) {\n            const startedAt = data.startedAt.toISOString();\n            data.startedAt = startedAt as any;\n            data.startedAtZ = startedAt;\n          }\n          // Note: updatedAt will be set by database trigger automatically\n\n          return {\n            keys: { spanId: record.spanId, traceId: record.traceId },\n            data,\n          };\n        }),\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_BATCH_UPDATE_AI_SPANS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchDeleteAITraces(args: { traceIds: string[] }): Promise<void> {\n    try {\n      const tableName = getTableName({\n        indexName: TABLE_AI_SPANS,\n        schemaName: getSchemaName(this.schema),\n      });\n\n      const placeholders = args.traceIds.map((_, i) => `$${i + 1}`).join(', ');\n      await this.client.none(`DELETE FROM ${tableName} WHERE \"traceId\" IN (${placeholders})`, args.traceIds);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'PG_STORE_BATCH_DELETE_AI_TRACES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        error,\n      );\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport {\n  StoreOperations,\n  TABLE_WORKFLOW_SNAPSHOT,\n  TABLE_THREADS,\n  TABLE_MESSAGES,\n  TABLE_TRACES,\n  TABLE_EVALS,\n  TABLE_SCORERS,\n  TABLE_AI_SPANS,\n  TABLE_SCHEMAS,\n} from '@mastra/core/storage';\nimport type {\n  StorageColumn,\n  TABLE_NAMES,\n  CreateIndexOptions,\n  IndexInfo,\n  StorageIndexStats,\n} from '@mastra/core/storage';\nimport { parseSqlIdentifier } from '@mastra/core/utils';\nimport type { IDatabase } from 'pg-promise';\nimport { getSchemaName, getTableName } from '../utils';\n\n// Re-export the types for convenience\nexport type { CreateIndexOptions, IndexInfo, StorageIndexStats };\n\nexport class StoreOperationsPG extends StoreOperations {\n  public client: IDatabase<{}>;\n  public schemaName?: string;\n  private setupSchemaPromise: Promise<void> | null = null;\n  private schemaSetupComplete: boolean | undefined = undefined;\n\n  constructor({ client, schemaName }: { client: IDatabase<{}>; schemaName?: string }) {\n    super();\n    this.client = client;\n    this.schemaName = schemaName;\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    // Use this.schema to scope the check\n    const schema = this.schemaName || 'public';\n\n    const result = await this.client.oneOrNone(\n      `SELECT 1 FROM information_schema.columns WHERE table_schema = $1 AND table_name = $2 AND (column_name = $3 OR column_name = $4)`,\n      [schema, table, column, column.toLowerCase()],\n    );\n\n    return !!result;\n  }\n\n  /**\n   * Prepares values for insertion, handling JSONB columns by stringifying them\n   */\n  private prepareValuesForInsert(record: Record<string, any>, tableName: TABLE_NAMES): any[] {\n    return Object.entries(record).map(([key, value]) => {\n      // Get the schema for this table to determine column types\n      const schema = TABLE_SCHEMAS[tableName];\n      const columnSchema = schema?.[key];\n\n      // If the column is JSONB, stringify the value (unless it's null/undefined)\n      // PostgreSQL JSONB columns require valid JSON, so even primitives need to be stringified\n      if (columnSchema?.type === 'jsonb' && value !== null && value !== undefined) {\n        return JSON.stringify(value);\n      }\n      return value;\n    });\n  }\n\n  /**\n   * Adds timestamp Z columns to a record if timestamp columns exist\n   */\n  private addTimestampZColumns(record: Record<string, any>): void {\n    if (record.createdAt) {\n      record.createdAtZ = record.createdAt;\n    }\n    if (record.created_at) {\n      record.created_atZ = record.created_at;\n    }\n    if (record.updatedAt) {\n      record.updatedAtZ = record.updatedAt;\n    }\n  }\n\n  /**\n   * Prepares a value for database operations, handling Date objects and JSON serialization\n   * This is schema-aware and only stringifies objects for JSONB columns\n   */\n  private prepareValue(value: any, columnName: string, tableName: TABLE_NAMES): any {\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    // Get the schema for this table to determine column types\n    const schema = TABLE_SCHEMAS[tableName];\n    const columnSchema = schema?.[columnName];\n\n    // If the column is JSONB, stringify the value\n    // PostgreSQL JSONB columns require valid JSON, so all non-null values need to be stringified\n    if (columnSchema?.type === 'jsonb') {\n      return JSON.stringify(value);\n    }\n\n    // For non-JSONB columns with object values, stringify them (for backwards compatibility)\n    if (typeof value === 'object') {\n      return JSON.stringify(value);\n    }\n\n    return value;\n  }\n\n  private async setupSchema() {\n    if (!this.schemaName || this.schemaSetupComplete) {\n      return;\n    }\n\n    const schemaName = getSchemaName(this.schemaName);\n\n    if (!this.setupSchemaPromise) {\n      this.setupSchemaPromise = (async () => {\n        try {\n          // First check if schema exists and we have usage permission\n          const schemaExists = await this.client.oneOrNone(\n            `\n                SELECT EXISTS (\n                  SELECT 1 FROM information_schema.schemata\n                  WHERE schema_name = $1\n                )\n              `,\n            [this.schemaName],\n          );\n\n          if (!schemaExists?.exists) {\n            try {\n              await this.client.none(`CREATE SCHEMA IF NOT EXISTS ${schemaName}`);\n              this.logger.info(`Schema \"${this.schemaName}\" created successfully`);\n            } catch (error) {\n              this.logger.error(`Failed to create schema \"${this.schemaName}\"`, { error });\n              throw new Error(\n                `Unable to create schema \"${this.schemaName}\". This requires CREATE privilege on the database. ` +\n                  `Either create the schema manually or grant CREATE privilege to the user.`,\n              );\n            }\n          }\n\n          // If we got here, schema exists and we can use it\n          this.schemaSetupComplete = true;\n          this.logger.debug(`Schema \"${schemaName}\" is ready for use`);\n        } catch (error) {\n          // Reset flags so we can retry\n          this.schemaSetupComplete = undefined;\n          this.setupSchemaPromise = null;\n          throw error;\n        } finally {\n          this.setupSchemaPromise = null;\n        }\n      })();\n    }\n\n    await this.setupSchemaPromise;\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    try {\n      this.addTimestampZColumns(record);\n\n      const schemaName = getSchemaName(this.schemaName);\n      const columns = Object.keys(record).map(col => parseSqlIdentifier(col, 'column name'));\n      const values = this.prepareValuesForInsert(record, tableName);\n      const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');\n\n      await this.client.none(\n        `INSERT INTO ${getTableName({ indexName: tableName, schemaName })} (${columns.map(c => `\"${c}\"`).join(', ')}) VALUES (${placeholders})`,\n        values,\n      );\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_INSERT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    try {\n      const schemaName = getSchemaName(this.schemaName);\n      const tableNameWithSchema = getTableName({ indexName: tableName, schemaName });\n      await this.client.none(`TRUNCATE TABLE ${tableNameWithSchema} CASCADE`);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_CLEAR_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'timestamp':\n        return 'DEFAULT NOW()';\n      case 'jsonb':\n        return \"DEFAULT '{}'::jsonb\";\n      default:\n        return super.getDefaultValue(type);\n    }\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      const timeZColumnNames = Object.entries(schema)\n        .filter(([_, def]) => def.type === 'timestamp')\n        .map(([name]) => name);\n\n      const timeZColumns = Object.entries(schema)\n        .filter(([_, def]) => def.type === 'timestamp')\n        .map(([name]) => {\n          const parsedName = parseSqlIdentifier(name, 'column name');\n          return `\"${parsedName}Z\" TIMESTAMPTZ DEFAULT NOW()`;\n        });\n\n      const columns = Object.entries(schema).map(([name, def]) => {\n        const parsedName = parseSqlIdentifier(name, 'column name');\n        const constraints = [];\n        if (def.primaryKey) constraints.push('PRIMARY KEY');\n        if (!def.nullable) constraints.push('NOT NULL');\n        return `\"${parsedName}\" ${def.type.toUpperCase()} ${constraints.join(' ')}`;\n      });\n\n      // Create schema if it doesn't exist\n      if (this.schemaName) {\n        await this.setupSchema();\n      }\n\n      const finalColumns = [...columns, ...timeZColumns].join(',\\n');\n\n      // Constraints are global to a database, ensure schemas do not conflict with each other\n      const constraintPrefix = this.schemaName ? `${this.schemaName}_` : '';\n      const sql = `\n            CREATE TABLE IF NOT EXISTS ${getTableName({ indexName: tableName, schemaName: getSchemaName(this.schemaName) })} (\n              ${finalColumns}\n            );\n            ${\n              tableName === TABLE_WORKFLOW_SNAPSHOT\n                ? `\n            DO $$ BEGIN\n              IF NOT EXISTS (\n                SELECT 1 FROM pg_constraint WHERE conname = '${constraintPrefix}mastra_workflow_snapshot_workflow_name_run_id_key'\n              ) AND NOT EXISTS (\n                SELECT 1 FROM pg_indexes WHERE indexname = '${constraintPrefix}mastra_workflow_snapshot_workflow_name_run_id_key'\n              ) THEN\n                ALTER TABLE ${getTableName({ indexName: tableName, schemaName: getSchemaName(this.schemaName) })}\n                ADD CONSTRAINT ${constraintPrefix}mastra_workflow_snapshot_workflow_name_run_id_key\n                UNIQUE (workflow_name, run_id);\n              END IF;\n            END $$;\n            `\n                : ''\n            }\n          `;\n\n      await this.client.none(sql);\n\n      await this.alterTable({\n        tableName,\n        schema,\n        ifNotExists: timeZColumnNames,\n      });\n\n      // Set up timestamp triggers for AI spans table\n      if (tableName === TABLE_AI_SPANS) {\n        await this.setupTimestampTriggers(tableName);\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_CREATE_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Set up timestamp triggers for a table to automatically manage createdAt/updatedAt\n   */\n  private async setupTimestampTriggers(tableName: TABLE_NAMES): Promise<void> {\n    const schemaName = getSchemaName(this.schemaName);\n    const fullTableName = getTableName({ indexName: tableName, schemaName });\n    const functionName = `${schemaName}.trigger_set_timestamps`;\n\n    try {\n      const triggerSQL = `\n        -- Create or replace the trigger function in the schema\n        CREATE OR REPLACE FUNCTION ${functionName}()\n        RETURNS TRIGGER AS $$\n        BEGIN\n            IF TG_OP = 'INSERT' THEN\n                NEW.\"createdAt\" = NOW();\n                NEW.\"updatedAt\" = NOW();\n                NEW.\"createdAtZ\" = NOW();\n                NEW.\"updatedAtZ\" = NOW();\n            ELSIF TG_OP = 'UPDATE' THEN\n                NEW.\"updatedAt\" = NOW();\n                NEW.\"updatedAtZ\" = NOW();\n                -- Prevent createdAt from being changed\n                NEW.\"createdAt\" = OLD.\"createdAt\";\n                NEW.\"createdAtZ\" = OLD.\"createdAtZ\";\n            END IF;\n            RETURN NEW;\n        END;\n        $$ LANGUAGE plpgsql;\n\n        -- Drop existing trigger if it exists\n        DROP TRIGGER IF EXISTS ${tableName}_timestamps ON ${fullTableName};\n\n        -- Create the trigger\n        CREATE TRIGGER ${tableName}_timestamps\n            BEFORE INSERT OR UPDATE ON ${fullTableName}\n            FOR EACH ROW\n            EXECUTE FUNCTION ${functionName}();\n      `;\n\n      await this.client.none(triggerSQL);\n      this.logger?.debug?.(`Set up timestamp triggers for table ${fullTableName}`);\n    } catch (error) {\n      // Log warning but don't fail table creation\n      this.logger?.warn?.(`Failed to set up timestamp triggers for ${fullTableName}:`, error);\n    }\n  }\n\n  /**\n   * Alters table schema to add columns if they don't exist\n   * @param tableName Name of the table\n   * @param schema Schema of the table\n   * @param ifNotExists Array of column names to add if they don't exist\n   */\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    const fullTableName = getTableName({ indexName: tableName, schemaName: getSchemaName(this.schemaName) });\n\n    try {\n      for (const columnName of ifNotExists) {\n        if (schema[columnName]) {\n          const columnDef = schema[columnName];\n          const sqlType = this.getSqlType(columnDef.type);\n          const nullable = columnDef.nullable === false ? 'NOT NULL' : '';\n          const defaultValue = columnDef.nullable === false ? this.getDefaultValue(columnDef.type) : '';\n          const parsedColumnName = parseSqlIdentifier(columnName, 'column name');\n          const alterSql =\n            `ALTER TABLE ${fullTableName} ADD COLUMN IF NOT EXISTS \"${parsedColumnName}\" ${sqlType} ${nullable} ${defaultValue}`.trim();\n\n          await this.client.none(alterSql);\n\n          if (sqlType === 'TIMESTAMP') {\n            const alterSql =\n              `ALTER TABLE ${fullTableName} ADD COLUMN IF NOT EXISTS \"${parsedColumnName}Z\" TIMESTAMPTZ DEFAULT NOW()`.trim();\n            await this.client.none(alterSql);\n          }\n\n          this.logger?.debug?.(`Ensured column ${parsedColumnName} exists in table ${fullTableName}`);\n        }\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_ALTER_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    try {\n      const keyEntries = Object.entries(keys).map(([key, value]) => [parseSqlIdentifier(key, 'column name'), value]);\n      const conditions = keyEntries.map(([key], index) => `\"${key}\" = $${index + 1}`).join(' AND ');\n      const values = keyEntries.map(([_, value]) => value);\n\n      const result = await this.client.oneOrNone<R>(\n        `SELECT * FROM ${getTableName({ indexName: tableName, schemaName: getSchemaName(this.schemaName) })} WHERE ${conditions} ORDER BY \"createdAt\" DESC LIMIT 1`,\n        values,\n      );\n\n      if (!result) {\n        return null;\n      }\n\n      // If this is a workflow snapshot, parse the snapshot field\n      if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n        const snapshot = result as any;\n        if (typeof snapshot.snapshot === 'string') {\n          snapshot.snapshot = JSON.parse(snapshot.snapshot);\n        }\n        return snapshot;\n      }\n\n      return result;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_LOAD_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    try {\n      await this.client.query('BEGIN');\n      for (const record of records) {\n        await this.insert({ tableName, record });\n      }\n      await this.client.query('COMMIT');\n    } catch (error) {\n      await this.client.query('ROLLBACK');\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_BATCH_INSERT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n            numberOfRecords: records.length,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    try {\n      const schemaName = getSchemaName(this.schemaName);\n      const tableNameWithSchema = getTableName({ indexName: tableName, schemaName });\n      await this.client.none(`DROP TABLE IF EXISTS ${tableNameWithSchema}`);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_DROP_TABLE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Create a new index on a table\n   */\n  async createIndex(options: CreateIndexOptions): Promise<void> {\n    try {\n      const {\n        name,\n        table,\n        columns,\n        unique = false,\n        concurrent = true,\n        where,\n        method = 'btree',\n        opclass,\n        storage,\n        tablespace,\n      } = options;\n\n      const schemaName = this.schemaName || 'public';\n      const fullTableName = getTableName({\n        indexName: table as TABLE_NAMES,\n        schemaName: getSchemaName(this.schemaName),\n      });\n\n      // Check if index already exists\n      const indexExists = await this.client.oneOrNone(\n        `SELECT 1 FROM pg_indexes\n         WHERE indexname = $1\n         AND schemaname = $2`,\n        [name, schemaName],\n      );\n\n      if (indexExists) {\n        // Index already exists, skip creation\n        return;\n      }\n\n      // Build index creation SQL\n      const uniqueStr = unique ? 'UNIQUE ' : '';\n      const concurrentStr = concurrent ? 'CONCURRENTLY ' : '';\n      const methodStr = method !== 'btree' ? `USING ${method} ` : '';\n\n      // Handle columns with optional operator class\n      const columnsStr = columns\n        .map(col => {\n          // Handle columns with DESC/ASC modifiers\n          if (col.includes(' DESC') || col.includes(' ASC')) {\n            const [colName, ...modifiers] = col.split(' ');\n            if (!colName) {\n              throw new Error(`Invalid column specification: ${col}`);\n            }\n            const quotedCol = `\"${parseSqlIdentifier(colName, 'column name')}\" ${modifiers.join(' ')}`;\n            return opclass ? `${quotedCol} ${opclass}` : quotedCol;\n          }\n          const quotedCol = `\"${parseSqlIdentifier(col, 'column name')}\"`;\n          return opclass ? `${quotedCol} ${opclass}` : quotedCol;\n        })\n        .join(', ');\n\n      const whereStr = where ? ` WHERE ${where}` : '';\n      const tablespaceStr = tablespace ? ` TABLESPACE ${tablespace}` : '';\n\n      // Build storage parameters string\n      let withStr = '';\n      if (storage && Object.keys(storage).length > 0) {\n        const storageParams = Object.entries(storage)\n          .map(([key, value]) => `${key} = ${value}`)\n          .join(', ');\n        withStr = ` WITH (${storageParams})`;\n      }\n\n      const sql = `CREATE ${uniqueStr}INDEX ${concurrentStr}${name} ON ${fullTableName} ${methodStr}(${columnsStr})${withStr}${tablespaceStr}${whereStr}`;\n\n      await this.client.none(sql);\n    } catch (error) {\n      // Check if error is due to concurrent index creation on a table that doesn't support it\n      if (error instanceof Error && error.message.includes('CONCURRENTLY')) {\n        // Retry without CONCURRENTLY\n        const retryOptions = { ...options, concurrent: false };\n        return this.createIndex(retryOptions);\n      }\n\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_INDEX_CREATE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName: options.name,\n            tableName: options.table,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Drop an existing index\n   */\n  async dropIndex(indexName: string): Promise<void> {\n    try {\n      // Check if index exists first\n      const schemaName = this.schemaName || 'public';\n      const indexExists = await this.client.oneOrNone(\n        `SELECT 1 FROM pg_indexes\n         WHERE indexname = $1\n         AND schemaname = $2`,\n        [indexName, schemaName],\n      );\n\n      if (!indexExists) {\n        // Index doesn't exist, nothing to drop\n        return;\n      }\n\n      const sql = `DROP INDEX IF EXISTS ${getSchemaName(this.schemaName)}.${indexName}`;\n      await this.client.none(sql);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_INDEX_DROP_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * List indexes for a specific table or all tables\n   */\n  async listIndexes(tableName?: string): Promise<IndexInfo[]> {\n    try {\n      const schemaName = this.schemaName || 'public';\n\n      let query: string;\n      let params: any[];\n\n      if (tableName) {\n        query = `\n          SELECT\n            i.indexname as name,\n            i.tablename as table,\n            i.indexdef as definition,\n            ix.indisunique as is_unique,\n            pg_size_pretty(pg_relation_size(c.oid)) as size,\n            array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) as columns\n          FROM pg_indexes i\n          JOIN pg_class c ON c.relname = i.indexname AND c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = i.schemaname)\n          JOIN pg_index ix ON ix.indexrelid = c.oid\n          JOIN pg_attribute a ON a.attrelid = ix.indrelid AND a.attnum = ANY(ix.indkey)\n          WHERE i.schemaname = $1\n          AND i.tablename = $2\n          GROUP BY i.indexname, i.tablename, i.indexdef, ix.indisunique, c.oid\n        `;\n        params = [schemaName, tableName];\n      } else {\n        query = `\n          SELECT\n            i.indexname as name,\n            i.tablename as table,\n            i.indexdef as definition,\n            ix.indisunique as is_unique,\n            pg_size_pretty(pg_relation_size(c.oid)) as size,\n            array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) as columns\n          FROM pg_indexes i\n          JOIN pg_class c ON c.relname = i.indexname AND c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = i.schemaname)\n          JOIN pg_index ix ON ix.indexrelid = c.oid\n          JOIN pg_attribute a ON a.attrelid = ix.indrelid AND a.attnum = ANY(ix.indkey)\n          WHERE i.schemaname = $1\n          GROUP BY i.indexname, i.tablename, i.indexdef, ix.indisunique, c.oid\n        `;\n        params = [schemaName];\n      }\n\n      const results = await this.client.manyOrNone(query, params);\n\n      return results.map(row => {\n        // Parse PostgreSQL array format {col1,col2} to ['col1','col2']\n        let columns: string[] = [];\n        if (typeof row.columns === 'string' && row.columns.startsWith('{') && row.columns.endsWith('}')) {\n          // Remove braces and split by comma, handling empty arrays\n          const arrayContent = row.columns.slice(1, -1);\n          columns = arrayContent ? arrayContent.split(',') : [];\n        } else if (Array.isArray(row.columns)) {\n          columns = row.columns;\n        }\n\n        return {\n          name: row.name,\n          table: row.table,\n          columns,\n          unique: row.is_unique || false,\n          size: row.size || '0',\n          definition: row.definition || '',\n        };\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_INDEX_LIST_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: tableName\n            ? {\n                tableName,\n              }\n            : {},\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Returns definitions for automatic performance indexes\n   * These composite indexes cover both filtering and sorting in single index\n   */\n  protected getAutomaticIndexDefinitions(): CreateIndexOptions[] {\n    const schemaPrefix = this.schemaName ? `${this.schemaName}_` : '';\n    return [\n      // Composite index for threads (filter + sort)\n      {\n        name: `${schemaPrefix}mastra_threads_resourceid_createdat_idx`,\n        table: TABLE_THREADS,\n        columns: ['resourceId', 'createdAt DESC'],\n      },\n      // Composite index for messages (filter + sort)\n      {\n        name: `${schemaPrefix}mastra_messages_thread_id_createdat_idx`,\n        table: TABLE_MESSAGES,\n        columns: ['thread_id', 'createdAt DESC'],\n      },\n      // Composite index for traces (filter + sort)\n      {\n        name: `${schemaPrefix}mastra_traces_name_starttime_idx`,\n        table: TABLE_TRACES,\n        columns: ['name', 'startTime DESC'],\n      },\n      // Composite index for evals (filter + sort)\n      {\n        name: `${schemaPrefix}mastra_evals_agent_name_created_at_idx`,\n        table: TABLE_EVALS,\n        columns: ['agent_name', 'created_at DESC'],\n      },\n      // Composite index for scores (filter + sort)\n      {\n        name: `${schemaPrefix}mastra_scores_trace_id_span_id_created_at_idx`,\n        table: TABLE_SCORERS,\n        columns: ['traceId', 'spanId', 'createdAt DESC'],\n      },\n      // AI Spans indexes for optimal trace querying\n      {\n        name: `${schemaPrefix}mastra_ai_spans_traceid_startedat_idx`,\n        table: TABLE_AI_SPANS,\n        columns: ['traceId', 'startedAt DESC'],\n      },\n      {\n        name: `${schemaPrefix}mastra_ai_spans_parentspanid_startedat_idx`,\n        table: TABLE_AI_SPANS,\n        columns: ['parentSpanId', 'startedAt DESC'],\n      },\n      {\n        name: `${schemaPrefix}mastra_ai_spans_name_idx`,\n        table: TABLE_AI_SPANS,\n        columns: ['name'],\n      },\n      {\n        name: `${schemaPrefix}mastra_ai_spans_spantype_startedat_idx`,\n        table: TABLE_AI_SPANS,\n        columns: ['spanType', 'startedAt DESC'],\n      },\n    ];\n  }\n\n  /**\n   * Creates automatic indexes for optimal query performance\n   * Uses getAutomaticIndexDefinitions() to determine which indexes to create\n   */\n  async createAutomaticIndexes(): Promise<void> {\n    try {\n      const indexes = this.getAutomaticIndexDefinitions();\n\n      for (const indexOptions of indexes) {\n        try {\n          await this.createIndex(indexOptions);\n        } catch (error) {\n          // Log but continue with other indexes\n          this.logger?.warn?.(`Failed to create index ${indexOptions.name}:`, error);\n        }\n      }\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_CREATE_PERFORMANCE_INDEXES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Get detailed statistics for a specific index\n   */\n  async describeIndex(indexName: string): Promise<StorageIndexStats> {\n    try {\n      const schemaName = this.schemaName || 'public';\n\n      // First get basic index info and stats\n      const query = `\n        SELECT\n          i.indexname as name,\n          i.tablename as table,\n          i.indexdef as definition,\n          ix.indisunique as is_unique,\n          pg_size_pretty(pg_relation_size(c.oid)) as size,\n          array_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum)) as columns,\n          am.amname as method,\n          s.idx_scan as scans,\n          s.idx_tup_read as tuples_read,\n          s.idx_tup_fetch as tuples_fetched\n        FROM pg_indexes i\n        JOIN pg_class c ON c.relname = i.indexname AND c.relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = i.schemaname)\n        JOIN pg_index ix ON ix.indexrelid = c.oid\n        JOIN pg_attribute a ON a.attrelid = ix.indrelid AND a.attnum = ANY(ix.indkey)\n        JOIN pg_am am ON c.relam = am.oid\n        LEFT JOIN pg_stat_user_indexes s ON s.indexrelname = i.indexname AND s.schemaname = i.schemaname\n        WHERE i.schemaname = $1\n        AND i.indexname = $2\n        GROUP BY i.indexname, i.tablename, i.indexdef, ix.indisunique, c.oid, am.amname, s.idx_scan, s.idx_tup_read, s.idx_tup_fetch\n      `;\n\n      const result = await this.client.oneOrNone(query, [schemaName, indexName]);\n\n      if (!result) {\n        throw new Error(`Index \"${indexName}\" not found in schema \"${schemaName}\"`);\n      }\n\n      // Parse PostgreSQL array format\n      let columns: string[] = [];\n      if (typeof result.columns === 'string' && result.columns.startsWith('{') && result.columns.endsWith('}')) {\n        const arrayContent = result.columns.slice(1, -1);\n        columns = arrayContent ? arrayContent.split(',') : [];\n      } else if (Array.isArray(result.columns)) {\n        columns = result.columns;\n      }\n\n      return {\n        name: result.name,\n        table: result.table,\n        columns,\n        unique: result.is_unique || false,\n        size: result.size || '0',\n        definition: result.definition || '',\n        method: result.method || 'btree',\n        scans: parseInt(result.scans) || 0,\n        tuples_read: parseInt(result.tuples_read) || 0,\n        tuples_fetched: parseInt(result.tuples_fetched) || 0,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_INDEX_DESCRIBE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            indexName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Update a single record in the database\n   */\n  async update({\n    tableName,\n    keys,\n    data,\n  }: {\n    tableName: TABLE_NAMES;\n    keys: Record<string, any>;\n    data: Record<string, any>;\n  }): Promise<void> {\n    try {\n      const setColumns: string[] = [];\n      const setValues: any[] = [];\n      let paramIndex = 1;\n\n      // Build SET clause\n      Object.entries(data).forEach(([key, value]) => {\n        const parsedKey = parseSqlIdentifier(key, 'column name');\n        setColumns.push(`\"${parsedKey}\" = $${paramIndex++}`);\n        setValues.push(this.prepareValue(value, key, tableName));\n      });\n\n      // Build WHERE clause\n      const whereConditions: string[] = [];\n      const whereValues: any[] = [];\n\n      Object.entries(keys).forEach(([key, value]) => {\n        const parsedKey = parseSqlIdentifier(key, 'column name');\n        whereConditions.push(`\"${parsedKey}\" = $${paramIndex++}`);\n        whereValues.push(this.prepareValue(value, key, tableName));\n      });\n\n      const tableName_ = getTableName({\n        indexName: tableName,\n        schemaName: getSchemaName(this.schemaName),\n      });\n\n      const sql = `UPDATE ${tableName_} SET ${setColumns.join(', ')} WHERE ${whereConditions.join(' AND ')}`;\n      const values = [...setValues, ...whereValues];\n\n      await this.client.none(sql, values);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_UPDATE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Update multiple records in a single batch transaction\n   */\n  async batchUpdate({\n    tableName,\n    updates,\n  }: {\n    tableName: TABLE_NAMES;\n    updates: Array<{\n      keys: Record<string, any>;\n      data: Record<string, any>;\n    }>;\n  }): Promise<void> {\n    try {\n      await this.client.query('BEGIN');\n      for (const { keys, data } of updates) {\n        await this.update({ tableName, keys, data });\n      }\n      await this.client.query('COMMIT');\n    } catch (error) {\n      await this.client.query('ROLLBACK');\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_BATCH_UPDATE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n            numberOfRecords: updates.length,\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Delete multiple records by keys\n   */\n  async batchDelete({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any>[] }): Promise<void> {\n    try {\n      if (keys.length === 0) {\n        return;\n      }\n\n      const tableName_ = getTableName({\n        indexName: tableName,\n        schemaName: getSchemaName(this.schemaName),\n      });\n\n      await this.client.tx(async t => {\n        for (const keySet of keys) {\n          const conditions: string[] = [];\n          const values: any[] = [];\n          let paramIndex = 1;\n\n          Object.entries(keySet).forEach(([key, value]) => {\n            const parsedKey = parseSqlIdentifier(key, 'column name');\n            conditions.push(`\"${parsedKey}\" = $${paramIndex++}`);\n            values.push(value);\n          });\n\n          const sql = `DELETE FROM ${tableName_} WHERE ${conditions.join(' AND ')}`;\n          await t.none(sql, values);\n        }\n      });\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_BATCH_DELETE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            tableName,\n            numberOfRecords: keys.length,\n          },\n        },\n        error,\n      );\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { saveScorePayloadSchema } from '@mastra/core/scores';\nimport type { ScoreRowData, ScoringSource, ValidatedSaveScorePayload } from '@mastra/core/scores';\nimport type { PaginationInfo, StoragePagination } from '@mastra/core/storage';\nimport { safelyParseJSON, ScoresStorage, TABLE_SCORERS } from '@mastra/core/storage';\nimport type { IDatabase } from 'pg-promise';\nimport type { StoreOperationsPG } from '../operations';\nimport { getTableName } from '../utils';\n\nfunction transformScoreRow(row: Record<string, any>): ScoreRowData {\n  return {\n    ...row,\n    input: safelyParseJSON(row.input),\n    scorer: safelyParseJSON(row.scorer),\n    preprocessStepResult: safelyParseJSON(row.preprocessStepResult),\n    analyzeStepResult: safelyParseJSON(row.analyzeStepResult),\n    metadata: safelyParseJSON(row.metadata),\n    output: safelyParseJSON(row.output),\n    additionalContext: safelyParseJSON(row.additionalContext),\n    runtimeContext: safelyParseJSON(row.runtimeContext),\n    entity: safelyParseJSON(row.entity),\n    createdAt: row.createdAtZ || row.createdAt,\n    updatedAt: row.updatedAtZ || row.updatedAt,\n  } as ScoreRowData;\n}\n\nexport class ScoresPG extends ScoresStorage {\n  public client: IDatabase<{}>;\n  private operations: StoreOperationsPG;\n  private schema?: string;\n\n  constructor({\n    client,\n    operations,\n    schema,\n  }: {\n    client: IDatabase<{}>;\n    operations: StoreOperationsPG;\n    schema?: string;\n  }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n    this.schema = schema;\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    try {\n      const result = await this.client.oneOrNone<ScoreRowData>(\n        `SELECT * FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE id = $1`,\n        [id],\n      );\n\n      return result ? transformScoreRow(result) : null;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_SCORE_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const conditions: string[] = [`\"scorerId\" = $1`];\n      const queryParams: any[] = [scorerId];\n      let paramIndex = 2;\n\n      if (entityId) {\n        conditions.push(`\"entityId\" = $${paramIndex++}`);\n        queryParams.push(entityId);\n      }\n\n      if (entityType) {\n        conditions.push(`\"entityType\" = $${paramIndex++}`);\n        queryParams.push(entityType);\n      }\n\n      if (source) {\n        conditions.push(`\"source\" = $${paramIndex++}`);\n        queryParams.push(source);\n      }\n\n      const whereClause = conditions.join(' AND ');\n\n      const total = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE ${whereClause}`,\n        queryParams,\n      );\n      if (total?.count === '0' || !total?.count) {\n        return {\n          pagination: {\n            total: 0,\n            page: pagination.page,\n            perPage: pagination.perPage,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const result = await this.client.manyOrNone<ScoreRowData>(\n        `SELECT * FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE ${whereClause} ORDER BY \"createdAt\" DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,\n        [...queryParams, pagination.perPage, pagination.page * pagination.perPage],\n      );\n\n      return {\n        pagination: {\n          total: Number(total?.count) || 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: Number(total?.count) > (pagination.page + 1) * pagination.perPage,\n        },\n        scores: result.map(transformScoreRow),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_SCORES_BY_SCORER_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async saveScore(score: Omit<ScoreRowData, 'id' | 'createdAt' | 'updatedAt'>): Promise<{ score: ScoreRowData }> {\n    let parsedScore: ValidatedSaveScorePayload;\n    try {\n      parsedScore = saveScorePayloadSchema.parse(score);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_SAVE_SCORE_FAILED_INVALID_SCORE_PAYLOAD',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: {\n            scorer: score.scorer.name,\n            entityId: score.entityId,\n            entityType: score.entityType,\n            traceId: score.traceId || '',\n            spanId: score.spanId || '',\n          },\n        },\n        error,\n      );\n    }\n\n    try {\n      // Generate ID like other storage implementations\n      const id = crypto.randomUUID();\n\n      const {\n        scorer,\n        preprocessStepResult,\n        analyzeStepResult,\n        metadata,\n        input,\n        output,\n        additionalContext,\n        runtimeContext,\n        entity,\n        ...rest\n      } = parsedScore;\n\n      await this.operations.insert({\n        tableName: TABLE_SCORERS,\n        record: {\n          id,\n          ...rest,\n          input: JSON.stringify(input) || '',\n          output: JSON.stringify(output) || '',\n          scorer: scorer ? JSON.stringify(scorer) : null,\n          preprocessStepResult: preprocessStepResult ? JSON.stringify(preprocessStepResult) : null,\n          analyzeStepResult: analyzeStepResult ? JSON.stringify(analyzeStepResult) : null,\n          metadata: metadata ? JSON.stringify(metadata) : null,\n          additionalContext: additionalContext ? JSON.stringify(additionalContext) : null,\n          runtimeContext: runtimeContext ? JSON.stringify(runtimeContext) : null,\n          entity: entity ? JSON.stringify(entity) : null,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n        },\n      });\n\n      const scoreFromDb = await this.getScoreById({ id });\n      return { score: scoreFromDb! };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_SAVE_SCORE_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const total = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE \"runId\" = $1`,\n        [runId],\n      );\n      if (total?.count === '0' || !total?.count) {\n        return {\n          pagination: {\n            total: 0,\n            page: pagination.page,\n            perPage: pagination.perPage,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const result = await this.client.manyOrNone<ScoreRowData>(\n        `SELECT * FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE \"runId\" = $1 LIMIT $2 OFFSET $3`,\n        [runId, pagination.perPage, pagination.page * pagination.perPage],\n      );\n      return {\n        pagination: {\n          total: Number(total?.count) || 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: Number(total?.count) > (pagination.page + 1) * pagination.perPage,\n        },\n        scores: result.map(transformScoreRow),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_SCORES_BY_RUN_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const total = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE \"entityId\" = $1 AND \"entityType\" = $2`,\n        [entityId, entityType],\n      );\n\n      if (total?.count === '0' || !total?.count) {\n        return {\n          pagination: {\n            total: 0,\n            page: pagination.page,\n            perPage: pagination.perPage,\n            hasMore: false,\n          },\n          scores: [],\n        };\n      }\n\n      const result = await this.client.manyOrNone<ScoreRowData>(\n        `SELECT * FROM ${getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema })} WHERE \"entityId\" = $1 AND \"entityType\" = $2 LIMIT $3 OFFSET $4`,\n        [entityId, entityType, pagination.perPage, pagination.page * pagination.perPage],\n      );\n      return {\n        pagination: {\n          total: Number(total?.count) || 0,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore: Number(total?.count) > (pagination.page + 1) * pagination.perPage,\n        },\n        scores: result.map(transformScoreRow),\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_SCORES_BY_ENTITY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    try {\n      const tableName = getTableName({ indexName: TABLE_SCORERS, schemaName: this.schema });\n      const countSQLResult = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) as count FROM ${tableName} WHERE \"traceId\" = $1 AND \"spanId\" = $2`,\n        [traceId, spanId],\n      );\n\n      const total = Number(countSQLResult?.count ?? 0);\n\n      const result = await this.client.manyOrNone<ScoreRowData>(\n        `SELECT * FROM ${tableName} WHERE \"traceId\" = $1 AND \"spanId\" = $2 ORDER BY \"createdAt\" DESC LIMIT $3 OFFSET $4`,\n        [traceId, spanId, pagination.perPage + 1, pagination.page * pagination.perPage],\n      );\n\n      const hasMore = result.length > pagination.perPage;\n      const scores = result.slice(0, pagination.perPage).map(row => transformScoreRow(row)) ?? [];\n\n      return {\n        scores,\n        pagination: {\n          total,\n          page: pagination.page,\n          perPage: pagination.perPage,\n          hasMore,\n        },\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_SCORES_BY_SPAN_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { PaginationInfo, StorageGetTracesArg, StorageGetTracesPaginatedArg } from '@mastra/core/storage';\nimport { TABLE_TRACES, TracesStorage, safelyParseJSON } from '@mastra/core/storage';\nimport type { Trace } from '@mastra/core/telemetry';\nimport { parseFieldKey } from '@mastra/core/utils';\nimport type { IDatabase } from 'pg-promise';\nimport type { StoreOperationsPG } from '../operations';\nimport { getSchemaName, getTableName } from '../utils';\n\nexport class TracesPG extends TracesStorage {\n  public client: IDatabase<{}>;\n  private operations: StoreOperationsPG;\n  private schema?: string;\n\n  constructor({\n    client,\n    operations,\n    schema,\n  }: {\n    client: IDatabase<{}>;\n    operations: StoreOperationsPG;\n    schema?: string;\n  }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n    this.schema = schema;\n  }\n\n  async getTraces(args: StorageGetTracesArg): Promise<Trace[]> {\n    if (args.fromDate || args.toDate) {\n      (args as any).dateRange = {\n        start: args.fromDate,\n        end: args.toDate,\n      };\n    }\n    try {\n      const result = await this.getTracesPaginated(args);\n      return result.traces;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_TRACES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    const { name, scope, page = 0, perPage = 100, attributes, filters, dateRange } = args;\n    const fromDate = dateRange?.start;\n    const toDate = dateRange?.end;\n    const currentOffset = page * perPage;\n\n    const queryParams: any[] = [];\n    const conditions: string[] = [];\n    let paramIndex = 1;\n\n    if (name) {\n      conditions.push(`name LIKE $${paramIndex++}`);\n      queryParams.push(`${name}%`);\n    }\n    if (scope) {\n      conditions.push(`scope = $${paramIndex++}`);\n      queryParams.push(scope);\n    }\n    if (attributes) {\n      Object.entries(attributes).forEach(([key, value]) => {\n        const parsedKey = parseFieldKey(key);\n        conditions.push(`attributes->>'${parsedKey}' = $${paramIndex++}`);\n        queryParams.push(value);\n      });\n    }\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        const parsedKey = parseFieldKey(key);\n        conditions.push(`\"${parsedKey}\" = $${paramIndex++}`);\n        queryParams.push(value);\n      });\n    }\n    if (fromDate) {\n      conditions.push(`\"createdAt\" >= $${paramIndex++}`);\n      queryParams.push(fromDate);\n    }\n    if (toDate) {\n      conditions.push(`\"createdAt\" <= $${paramIndex++}`);\n      queryParams.push(toDate);\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    try {\n      const countResult = await this.client.oneOrNone<{ count: string }>(\n        `SELECT COUNT(*) FROM ${getTableName({ indexName: TABLE_TRACES, schemaName: getSchemaName(this.schema) })} ${whereClause}`,\n        queryParams,\n      );\n      const total = Number(countResult?.count ?? 0);\n\n      if (total === 0) {\n        return {\n          traces: [],\n          total: 0,\n          page,\n          perPage,\n          hasMore: false,\n        };\n      }\n\n      const dataResult = await this.client.manyOrNone<Record<string, any>>(\n        `SELECT * FROM ${getTableName({ indexName: TABLE_TRACES, schemaName: getSchemaName(this.schema) })} ${whereClause} ORDER BY \"startTime\" DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,\n        [...queryParams, perPage, currentOffset],\n      );\n\n      const traces = dataResult.map(row => ({\n        id: row.id,\n        parentSpanId: row.parentSpanId,\n        traceId: row.traceId,\n        name: row.name,\n        scope: row.scope,\n        kind: row.kind,\n        status: safelyParseJSON(row.status),\n        events: safelyParseJSON(row.events),\n        links: safelyParseJSON(row.links),\n        attributes: safelyParseJSON(row.attributes),\n        startTime: row.startTime,\n        endTime: row.endTime,\n        other: safelyParseJSON(row.other),\n        createdAt: row.createdAtZ || row.createdAt,\n      })) as Trace[];\n\n      return {\n        traces,\n        total,\n        page,\n        perPage,\n        hasMore: currentOffset + traces.length < total,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_TRACES_PAGINATED_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async batchTraceInsert({ records }: { records: Record<string, any>[] }): Promise<void> {\n    this.logger.debug('Batch inserting traces', { count: records.length });\n    await this.operations.batchInsert({\n      tableName: TABLE_TRACES,\n      records,\n    });\n  }\n}\n","import type { StepResult, WorkflowRun, WorkflowRuns, WorkflowRunState } from '@mastra/core';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport { TABLE_WORKFLOW_SNAPSHOT, WorkflowsStorage } from '@mastra/core/storage';\nimport type { IDatabase } from 'pg-promise';\nimport type { StoreOperationsPG } from '../operations';\nimport { getTableName } from '../utils';\n\nfunction parseWorkflowRun(row: Record<string, any>): WorkflowRun {\n  let parsedSnapshot: WorkflowRunState | string = row.snapshot as string;\n  if (typeof parsedSnapshot === 'string') {\n    try {\n      parsedSnapshot = JSON.parse(row.snapshot as string) as WorkflowRunState;\n    } catch (e) {\n      // If parsing fails, return the raw snapshot string\n      console.warn(`Failed to parse snapshot for workflow ${row.workflow_name}: ${e}`);\n    }\n  }\n  return {\n    workflowName: row.workflow_name as string,\n    runId: row.run_id as string,\n    snapshot: parsedSnapshot,\n    resourceId: row.resourceId as string,\n    createdAt: new Date(row.createdAtZ || (row.createdAt as string)),\n    updatedAt: new Date(row.updatedAtZ || (row.updatedAt as string)),\n  };\n}\n\nexport class WorkflowsPG extends WorkflowsStorage {\n  public client: IDatabase<{}>;\n  private operations: StoreOperationsPG;\n  private schema: string;\n\n  constructor({\n    client,\n    operations,\n    schema,\n  }: {\n    client: IDatabase<{}>;\n    operations: StoreOperationsPG;\n    schema: string;\n  }) {\n    super();\n    this.client = client;\n    this.operations = operations;\n    this.schema = schema;\n  }\n\n  updateWorkflowResults(\n    {\n      // workflowName,\n      // runId,\n      // stepId,\n      // result,\n      // runtimeContext,\n    }: {\n      workflowName: string;\n      runId: string;\n      stepId: string;\n      result: StepResult<any, any, any, any>;\n      runtimeContext: Record<string, any>;\n    },\n  ): Promise<Record<string, StepResult<any, any, any, any>>> {\n    throw new Error('Method not implemented.');\n  }\n  updateWorkflowState(\n    {\n      // workflowName,\n      // runId,\n      // opts,\n    }: {\n      workflowName: string;\n      runId: string;\n      opts: {\n        status: string;\n        result?: StepResult<any, any, any, any>;\n        error?: string;\n        suspendedPaths?: Record<string, number[]>;\n        waitingPaths?: Record<string, number[]>;\n      };\n    },\n  ): Promise<WorkflowRunState | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    try {\n      const now = new Date().toISOString();\n      await this.client.none(\n        `INSERT INTO ${getTableName({ indexName: TABLE_WORKFLOW_SNAPSHOT, schemaName: this.schema })} (workflow_name, run_id, \"resourceId\", snapshot, \"createdAt\", \"updatedAt\")\n                 VALUES ($1, $2, $3, $4, $5, $6)\n                 ON CONFLICT (workflow_name, run_id) DO UPDATE\n                 SET \"resourceId\" = $3, snapshot = $4, \"updatedAt\" = $6`,\n        [workflowName, runId, resourceId, JSON.stringify(snapshot), now, now],\n      );\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_PERSIST_WORKFLOW_SNAPSHOT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    try {\n      const result = await this.operations.load<{ snapshot: WorkflowRunState }>({\n        tableName: TABLE_WORKFLOW_SNAPSHOT,\n        keys: { workflow_name: workflowName, run_id: runId },\n      });\n\n      return result ? result.snapshot : null;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_LOAD_WORKFLOW_SNAPSHOT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    try {\n      const conditions: string[] = [];\n      const values: any[] = [];\n      let paramIndex = 1;\n\n      if (runId) {\n        conditions.push(`run_id = $${paramIndex}`);\n        values.push(runId);\n        paramIndex++;\n      }\n\n      if (workflowName) {\n        conditions.push(`workflow_name = $${paramIndex}`);\n        values.push(workflowName);\n        paramIndex++;\n      }\n\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      // Get results\n      const query = `\n          SELECT * FROM ${getTableName({ indexName: TABLE_WORKFLOW_SNAPSHOT, schemaName: this.schema })}\n          ${whereClause}\n          ORDER BY \"createdAt\" DESC LIMIT 1\n        `;\n\n      const queryValues = values;\n\n      const result = await this.client.oneOrNone(query, queryValues);\n\n      if (!result) {\n        return null;\n      }\n\n      return parseWorkflowRun(result);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_WORKFLOW_RUN_BY_ID_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            runId,\n            workflowName: workflowName || '',\n          },\n        },\n        error,\n      );\n    }\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    try {\n      const conditions: string[] = [];\n      const values: any[] = [];\n      let paramIndex = 1;\n\n      if (workflowName) {\n        conditions.push(`workflow_name = $${paramIndex}`);\n        values.push(workflowName);\n        paramIndex++;\n      }\n\n      if (resourceId) {\n        const hasResourceId = await this.operations.hasColumn(TABLE_WORKFLOW_SNAPSHOT, 'resourceId');\n        if (hasResourceId) {\n          conditions.push(`\"resourceId\" = $${paramIndex}`);\n          values.push(resourceId);\n          paramIndex++;\n        } else {\n          console.warn(`[${TABLE_WORKFLOW_SNAPSHOT}] resourceId column not found. Skipping resourceId filter.`);\n        }\n      }\n\n      if (fromDate) {\n        conditions.push(`\"createdAt\" >= $${paramIndex}`);\n        values.push(fromDate);\n        paramIndex++;\n      }\n\n      if (toDate) {\n        conditions.push(`\"createdAt\" <= $${paramIndex}`);\n        values.push(toDate);\n        paramIndex++;\n      }\n      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n      let total = 0;\n      // Only get total count when using pagination\n      if (limit !== undefined && offset !== undefined) {\n        const countResult = await this.client.one(\n          `SELECT COUNT(*) as count FROM ${getTableName({ indexName: TABLE_WORKFLOW_SNAPSHOT, schemaName: this.schema })} ${whereClause}`,\n          values,\n        );\n        total = Number(countResult.count);\n      }\n\n      // Get results\n      const query = `\n          SELECT * FROM ${getTableName({ indexName: TABLE_WORKFLOW_SNAPSHOT, schemaName: this.schema })}\n          ${whereClause}\n          ORDER BY \"createdAt\" DESC\n          ${limit !== undefined && offset !== undefined ? ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}` : ''}\n        `;\n\n      const queryValues = limit !== undefined && offset !== undefined ? [...values, limit, offset] : values;\n\n      const result = await this.client.manyOrNone(query, queryValues);\n\n      const runs = (result || []).map(row => {\n        return parseWorkflowRun(row);\n      });\n\n      // Use runs.length as total when not paginating\n      return { runs, total: total || runs.length };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_GET_WORKFLOW_RUNS_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: {\n            workflowName: workflowName || 'all',\n          },\n        },\n        error,\n      );\n    }\n  }\n}\n","import type { MastraMessageContentV2, MastraMessageV2 } from '@mastra/core/agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { MastraMessageV1, StorageThreadType } from '@mastra/core/memory';\nimport type { ScoreRowData, ScoringSource } from '@mastra/core/scores';\nimport { MastraStorage } from '@mastra/core/storage';\nimport type {\n  EvalRow,\n  PaginationInfo,\n  StorageColumn,\n  StorageGetMessagesArg,\n  StorageGetTracesArg,\n  StorageGetTracesPaginatedArg,\n  StorageResourceType,\n  TABLE_NAMES,\n  WorkflowRun,\n  WorkflowRuns,\n  PaginationArgs,\n  StoragePagination,\n  StorageDomains,\n  ThreadSortOptions,\n  AISpanRecord,\n  AITraceRecord,\n  AITracesPaginatedArg,\n} from '@mastra/core/storage';\nimport type { Trace } from '@mastra/core/telemetry';\nimport type { StepResult, WorkflowRunState } from '@mastra/core/workflows';\nimport pgPromise from 'pg-promise';\nimport { validateConfig, isCloudSqlConfig, isConnectionStringConfig, isHostConfig } from '../shared/config';\nimport type { PostgresStoreConfig } from '../shared/config';\nimport { LegacyEvalsPG } from './domains/legacy-evals';\nimport { MemoryPG } from './domains/memory';\nimport { ObservabilityPG } from './domains/observability';\nimport { StoreOperationsPG } from './domains/operations';\nimport { ScoresPG } from './domains/scores';\nimport { TracesPG } from './domains/traces';\nimport { WorkflowsPG } from './domains/workflows';\n\nexport type { CreateIndexOptions, IndexInfo } from '@mastra/core/storage';\n\nexport class PostgresStore extends MastraStorage {\n  #db?: pgPromise.IDatabase<{}>;\n  #pgp?: pgPromise.IMain;\n  #config: PostgresStoreConfig;\n  private schema: string;\n  private isConnected: boolean = false;\n\n  stores: StorageDomains;\n\n  constructor(config: PostgresStoreConfig) {\n    // Validation: connectionString or host/database/user/password must not be empty\n    try {\n      validateConfig('PostgresStore', config);\n      super({ name: 'PostgresStore' });\n      this.schema = config.schemaName || 'public';\n      if (isConnectionStringConfig(config)) {\n        this.#config = {\n          connectionString: config.connectionString,\n          max: config.max,\n          idleTimeoutMillis: config.idleTimeoutMillis,\n          ssl: config.ssl,\n        };\n      } else if (isCloudSqlConfig(config)) {\n        // Cloud SQL connector config\n        this.#config = {\n          ...config,\n          max: config.max,\n          idleTimeoutMillis: config.idleTimeoutMillis,\n        };\n      } else if (isHostConfig(config)) {\n        this.#config = {\n          host: config.host,\n          port: config.port,\n          database: config.database,\n          user: config.user,\n          password: config.password,\n          ssl: config.ssl,\n          max: config.max,\n          idleTimeoutMillis: config.idleTimeoutMillis,\n        };\n      } else {\n        // This should never happen due to validation above, but included for completeness\n        throw new Error(\n          'PostgresStore: invalid config. Provide either {connectionString}, {host,port,database,user,password}, or a pg ClientConfig (e.g., Cloud SQL connector with `stream`).',\n        );\n      }\n      this.stores = {} as StorageDomains;\n    } catch (e) {\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_PG_STORE_INITIALIZATION_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n        },\n        e,\n      );\n    }\n  }\n\n  async init(): Promise<void> {\n    if (this.isConnected) {\n      return;\n    }\n\n    try {\n      this.isConnected = true;\n      this.#pgp = pgPromise();\n      this.#db = this.#pgp(this.#config as any);\n\n      const operations = new StoreOperationsPG({ client: this.#db, schemaName: this.schema });\n      const scores = new ScoresPG({ client: this.#db, operations, schema: this.schema });\n      const traces = new TracesPG({ client: this.#db, operations, schema: this.schema });\n      const workflows = new WorkflowsPG({ client: this.#db, operations, schema: this.schema });\n      const legacyEvals = new LegacyEvalsPG({ client: this.#db, schema: this.schema });\n      const memory = new MemoryPG({ client: this.#db, schema: this.schema, operations });\n      const observability = new ObservabilityPG({ client: this.#db, operations, schema: this.schema });\n\n      this.stores = {\n        operations,\n        scores,\n        traces,\n        workflows,\n        legacyEvals,\n        memory,\n        observability,\n      };\n\n      await super.init();\n\n      // Create automatic performance indexes by default\n      // This is done after table creation and is safe to run multiple times\n      try {\n        await operations.createAutomaticIndexes();\n      } catch (indexError) {\n        // Log the error but don't fail initialization\n        // Indexes are performance optimizations, not critical for functionality\n        console.warn('Failed to create indexes:', indexError);\n      }\n    } catch (error) {\n      this.isConnected = false;\n      throw new MastraError(\n        {\n          id: 'MASTRA_STORAGE_POSTGRES_STORE_INIT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  public get db() {\n    if (!this.#db) {\n      throw new Error(`PostgresStore: Store is not initialized, please call \"init()\" first.`);\n    }\n    return this.#db;\n  }\n\n  public get pgp() {\n    if (!this.#pgp) {\n      throw new Error(`PostgresStore: Store is not initialized, please call \"init()\" first.`);\n    }\n    return this.#pgp;\n  }\n\n  public get supports() {\n    return {\n      selectByIncludeResourceScope: true,\n      resourceWorkingMemory: true,\n      hasColumn: true,\n      createTable: true,\n      deleteMessages: true,\n      aiTracing: true,\n      indexManagement: true,\n      getScoresBySpan: true,\n    };\n  }\n\n  /** @deprecated use getEvals instead */\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    return this.stores.legacyEvals.getEvalsByAgentName(agentName, type);\n  }\n\n  async getEvals(\n    options: {\n      agentName?: string;\n      type?: 'test' | 'live';\n    } & PaginationArgs = {},\n  ): Promise<PaginationInfo & { evals: EvalRow[] }> {\n    return this.stores.legacyEvals.getEvals(options);\n  }\n\n  /**\n   * @deprecated use getTracesPaginated instead\n   */\n  public async getTraces(args: StorageGetTracesArg): Promise<Trace[]> {\n    return this.stores.traces.getTraces(args);\n  }\n\n  public async getTracesPaginated(args: StorageGetTracesPaginatedArg): Promise<PaginationInfo & { traces: Trace[] }> {\n    return this.stores.traces.getTracesPaginated(args);\n  }\n\n  async batchTraceInsert({ records }: { records: Record<string, any>[] }): Promise<void> {\n    return this.stores.traces.batchTraceInsert({ records });\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    return this.stores.operations.createTable({ tableName, schema });\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n    ifNotExists,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    return this.stores.operations.alterTable({ tableName, schema, ifNotExists });\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    return this.stores.operations.clearTable({ tableName });\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    return this.stores.operations.dropTable({ tableName });\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    return this.stores.operations.insert({ tableName, record });\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    return this.stores.operations.batchInsert({ tableName, records });\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    return this.stores.operations.load({ tableName, keys });\n  }\n\n  /**\n   * Memory\n   */\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.stores.memory.getThreadById({ threadId });\n  }\n\n  /**\n   * @deprecated use getThreadsByResourceIdPaginated instead\n   */\n  public async getThreadsByResourceId(args: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    return this.stores.memory.getThreadsByResourceId(args);\n  }\n\n  public async getThreadsByResourceIdPaginated(\n    args: {\n      resourceId: string;\n      page: number;\n      perPage: number;\n    } & ThreadSortOptions,\n  ): Promise<PaginationInfo & { threads: StorageThreadType[] }> {\n    return this.stores.memory.getThreadsByResourceIdPaginated(args);\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    return this.stores.memory.saveThread({ thread });\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    return this.stores.memory.updateThread({ id, title, metadata });\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    return this.stores.memory.deleteThread({ threadId });\n  }\n\n  /**\n   * @deprecated use getMessagesPaginated instead\n   */\n  public async getMessages(args: StorageGetMessagesArg & { format?: 'v1' }): Promise<MastraMessageV1[]>;\n  public async getMessages(args: StorageGetMessagesArg & { format: 'v2' }): Promise<MastraMessageV2[]>;\n  public async getMessages(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    return this.stores.memory.getMessages(args);\n  }\n\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format: 'v1' }): Promise<MastraMessageV1[]>;\n  async getMessagesById({ messageIds, format }: { messageIds: string[]; format?: 'v2' }): Promise<MastraMessageV2[]>;\n  async getMessagesById({\n    messageIds,\n    format,\n  }: {\n    messageIds: string[];\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV1[] | MastraMessageV2[]> {\n    return this.stores.memory.getMessagesById({ messageIds, format });\n  }\n\n  public async getMessagesPaginated(\n    args: StorageGetMessagesArg & {\n      format?: 'v1' | 'v2';\n    },\n  ): Promise<PaginationInfo & { messages: MastraMessageV1[] | MastraMessageV2[] }> {\n    return this.stores.memory.getMessagesPaginated(args);\n  }\n\n  async saveMessages(args: { messages: MastraMessageV1[]; format?: undefined | 'v1' }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: { messages: MastraMessageV2[]; format: 'v2' }): Promise<MastraMessageV2[]>;\n  async saveMessages(\n    args: { messages: MastraMessageV1[]; format?: undefined | 'v1' } | { messages: MastraMessageV2[]; format: 'v2' },\n  ): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    return this.stores.memory.saveMessages(args);\n  }\n\n  async updateMessages({\n    messages,\n  }: {\n    messages: (Partial<Omit<MastraMessageV2, 'createdAt'>> & {\n      id: string;\n      content?: {\n        metadata?: MastraMessageContentV2['metadata'];\n        content?: MastraMessageContentV2['content'];\n      };\n    })[];\n  }): Promise<MastraMessageV2[]> {\n    return this.stores.memory.updateMessages({ messages });\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    return this.stores.memory.deleteMessages(messageIds);\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    return this.stores.memory.getResourceById({ resourceId });\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    return this.stores.memory.saveResource({ resource });\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    return this.stores.memory.updateResource({ resourceId, workingMemory, metadata });\n  }\n\n  /**\n   * Workflows\n   */\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    runtimeContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    runtimeContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    return this.stores.workflows.updateWorkflowResults({ workflowName, runId, stepId, result, runtimeContext });\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: {\n      status: string;\n      result?: StepResult<any, any, any, any>;\n      error?: string;\n      suspendedPaths?: Record<string, number[]>;\n      waitingPaths?: Record<string, number[]>;\n    };\n  }): Promise<WorkflowRunState | undefined> {\n    return this.stores.workflows.updateWorkflowState({ workflowName, runId, opts });\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n  }): Promise<void> {\n    return this.stores.workflows.persistWorkflowSnapshot({ workflowName, runId, resourceId, snapshot });\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    return this.stores.workflows.loadWorkflowSnapshot({ workflowName, runId });\n  }\n\n  async getWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    limit,\n    offset,\n    resourceId,\n  }: {\n    workflowName?: string;\n    fromDate?: Date;\n    toDate?: Date;\n    limit?: number;\n    offset?: number;\n    resourceId?: string;\n  } = {}): Promise<WorkflowRuns> {\n    return this.stores.workflows.getWorkflowRuns({ workflowName, fromDate, toDate, limit, offset, resourceId });\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    return this.stores.workflows.getWorkflowRunById({ runId, workflowName });\n  }\n\n  async close(): Promise<void> {\n    this.pgp.end();\n  }\n\n  /**\n   * AI Tracing / Observability\n   */\n  async createAISpan(span: AISpanRecord): Promise<void> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.createAISpan(span);\n  }\n\n  async updateAISpan({\n    spanId,\n    traceId,\n    updates,\n  }: {\n    spanId: string;\n    traceId: string;\n    updates: Partial<Omit<AISpanRecord, 'spanId' | 'traceId'>>;\n  }): Promise<void> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.updateAISpan({ spanId, traceId, updates });\n  }\n\n  async getAITrace(traceId: string): Promise<AITraceRecord | null> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.getAITrace(traceId);\n  }\n\n  async getAITracesPaginated(\n    args: AITracesPaginatedArg,\n  ): Promise<{ pagination: PaginationInfo; spans: AISpanRecord[] }> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.getAITracesPaginated(args);\n  }\n\n  async batchCreateAISpans(args: { records: AISpanRecord[] }): Promise<void> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.batchCreateAISpans(args);\n  }\n\n  async batchUpdateAISpans(args: {\n    records: {\n      traceId: string;\n      spanId: string;\n      updates: Partial<Omit<AISpanRecord, 'spanId' | 'traceId'>>;\n    }[];\n  }): Promise<void> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.batchUpdateAISpans(args);\n  }\n\n  async batchDeleteAITraces(args: { traceIds: string[] }): Promise<void> {\n    if (!this.stores.observability) {\n      throw new MastraError({\n        id: 'PG_STORE_OBSERVABILITY_NOT_INITIALIZED',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Observability storage is not initialized',\n      });\n    }\n    return this.stores.observability.batchDeleteAITraces(args);\n  }\n\n  /**\n   * Scorers\n   */\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.stores.scores.getScoreById({ id });\n  }\n\n  async getScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByScorerId({ scorerId, pagination, entityId, entityType, source });\n  }\n\n  async saveScore(score: ScoreRowData): Promise<{ score: ScoreRowData }> {\n    return this.stores.scores.saveScore(score);\n  }\n\n  async getScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByRunId({ runId, pagination });\n  }\n\n  async getScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresByEntityId({\n      entityId,\n      entityType,\n      pagination,\n    });\n  }\n\n  async getScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<{ pagination: PaginationInfo; scores: ScoreRowData[] }> {\n    return this.stores.scores.getScoresBySpan({ traceId, spanId, pagination });\n  }\n}\n","/**\n * Vector store specific prompt that details supported operators and examples.\n * This prompt helps users construct valid filters for PG Vector.\n */\nexport const PGVECTOR_PROMPT = `When querying PG Vector, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n- $elemMatch: Match array elements that meet all specified conditions\n  Example: { \"items\": { \"$elemMatch\": { \"price\": { \"$gt\": 100 } } } }\n- $contains: Check if array contains value\n  Example: { \"tags\": { \"$contains\": \"premium\" } }\n\nLogical Operators:\n- $and: Logical AND (implicit when using multiple conditions)\n  Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n- $not: Logical NOT\n  Example: { \"$not\": { \"category\": \"electronics\" } }\n- $nor: Logical NOR\n  Example: { \"$nor\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nSpecial Operators:\n- $size: Array length check\n  Example: { \"tags\": { \"$size\": 2 } }\n\nRestrictions:\n- Regex patterns are not supported\n- Direct RegExp patterns will throw an error\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- Array operations work on array fields only\n- Basic operators handle array values as JSON strings\n- Empty arrays in conditions are handled gracefully\n- Only logical operators ($and, $or, $not, $nor) can be used at the top level\n- All other operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n  Invalid: { \"$contains\": \"value\" }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- $not operator:\n  - Must be an object\n  - Cannot be empty\n  - Can be used at field level or top level\n  - Valid: { \"$not\": { \"field\": \"value\" } }\n  - Valid: { \"field\": { \"$not\": { \"$eq\": \"value\" } } }\n- Other logical operators ($and, $or, $nor):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n- $elemMatch requires an object with conditions\n  Valid: { \"array\": { \"$elemMatch\": { \"field\": \"value\" } } }\n  Invalid: { \"array\": { \"$elemMatch\": \"value\" } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\"] } },\n    { \"rating\": { \"$exists\": true, \"$gt\": 4 } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n"]}