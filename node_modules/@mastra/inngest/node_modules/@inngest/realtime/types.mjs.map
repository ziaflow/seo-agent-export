{"version":3,"file":"types.mjs","names":[],"sources":["../src/types.ts"],"sourcesContent":["import { type StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { z } from \"zod/v3\";\n\nexport namespace Realtime {\n  export type PublishFn = <\n    TMessage extends MaybePromise<Realtime.Message.Input>,\n  >(\n    message: TMessage,\n  ) => Promise<Awaited<TMessage>[\"data\"]>;\n\n  export type Token<\n    TChannel extends Channel | Channel.Definition,\n    TTopics extends (keyof Channel.InferTopics<\n      Channel.Definition.AsChannel<TChannel>\n    > &\n      string)[] = (keyof Channel.InferTopics<\n      Channel.Definition.AsChannel<TChannel>\n    > &\n      string)[],\n  > = TChannel extends Channel.Definition\n    ? Subscribe.Token<Channel.Definition.AsChannel<TChannel>, TTopics>\n    : TChannel extends Channel\n      ? Subscribe.Token<TChannel, TTopics>\n      : never;\n\n  export namespace Subscribe {\n    export type InferChannelInput<T> = T extends Realtime.Channel.Definition\n      ? Realtime.Channel.Definition.InferId<T>\n      : T;\n\n    export type StreamSubscription<\n      TSubscribeToken extends Token = Token,\n      TData extends Simplify<Token.InferMessage<TSubscribeToken>> = Simplify<\n        Token.InferMessage<TSubscribeToken>\n      >,\n    > = ReadableStream<TData> & {\n      /**\n       * Get a new readable stream from the subscription that delivers JSON chunks.\n       *\n       * The stream starts when this function is called and will not contain any\n       * messages that were sent before this function was called.\n       */\n      getJsonStream(): ReadableStream<TData>;\n\n      /**\n       * Get a new readable stream from the subscription that delivers\n       * SSE-compatible chunks, which are compatible with the `EventSource` API\n       * and generally used for streaming data from a server to the browser.\n       *\n       * The stream starts when this function is called and will not contain any\n       * messages that were sent before this function was called.\n       */\n      getEncodedStream(): ReadableStream<Uint8Array>;\n    };\n\n    export type Callback<\n      TSubscribeToken extends Subscribe.Token = Subscribe.Token,\n    > = (message: Token.InferMessage<TSubscribeToken>) => void;\n\n    export interface Token<\n      TChannel extends Channel | Channel.Definition = Channel,\n      TTopics extends\n        (keyof Channel.InferTopics<TChannel>)[] = (keyof Channel.InferTopics<TChannel>)[],\n    > {\n      // key used to auth - could be undefined as then we can do a cold subscribe\n      key?: string | undefined;\n      channel: Realtime.Channel.Definition.AsChannel<TChannel>;\n      topics: TTopics;\n    }\n\n    export namespace Token {\n      export type InferChannel<TToken extends Token> = TToken extends Token<\n        infer IChannel,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        any\n      >\n        ? IChannel\n        : Channel;\n\n      export type InferTopicData<\n        TToken extends Token,\n        TChannelTopics extends Record<\n          string,\n          Topic.Definition\n        > = Channel.InferTopics<Token.InferChannel<TToken>>,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      > = TToken extends Token<any, infer ITopics>\n        ? { [K in ITopics[number]]: TChannelTopics[K] }\n        : never;\n\n      export type InferMessage<TToken extends Token> = Simplify<\n        Realtime.Message<\n          Channel.InferId<Token.InferChannel<TToken>>,\n          Token.InferTopicData<TToken>\n        >\n      >;\n    }\n  }\n\n  // We need to use a `Message` type so that we can appropriately type incoming\n  // and outgoing messages with generics, but we also need to validate these at\n  // runtime.\n  //\n  // Ideally in the future we use protobuf for this, but for now we use Zod.\n  // This type is used to assert that the Zod schema matches the generic type.\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type _AssertMessageSchemaMatchesGeneric = Expect<\n    IsEqual<z.output<typeof messageSchema>, Message.Raw>\n  >;\n\n  export const messageSchema = z\n    .object({\n      channel: z.string().optional(),\n      topic: z.string().optional(),\n      data: z.any(),\n      run_id: z.string().optional(),\n      fn_id: z.string().optional(),\n      created_at: z\n        .string()\n        .optional()\n        .transform((v) => (v ? new Date(v) : undefined)),\n      env_id: z.string().optional(),\n      stream_id: z.string().optional(),\n      kind: z.enum([\n        \"step\",\n        \"run\",\n        \"data\",\n        \"ping\",\n        \"pong\",\n        \"closing\",\n        \"event\",\n        \"sub\",\n        \"unsub\",\n        \"datastream-start\",\n        \"datastream-end\",\n        \"chunk\",\n      ]),\n    })\n    .transform(({ data, ...rest }) => {\n      return {\n        ...rest,\n        data: data ?? undefined,\n      };\n    });\n\n  // Subscribe (output) msg\n  export type Message<\n    TChannelId extends string = string,\n    TTopics extends Record<string, Realtime.Topic.Definition> = Record<\n      string,\n      Realtime.Topic.Definition\n    >,\n  > = {\n    [K in keyof TTopics]:\n      | {\n          topic: K;\n          channel: TChannelId;\n          data: Realtime.Topic.InferSubscribe<TTopics[K]>;\n          runId?: string;\n          fnId?: string;\n          createdAt: Date;\n          envId?: string;\n          kind: \"data\";\n        }\n      | {\n          topic: K;\n          channel: TChannelId;\n          data: Realtime.Topic.InferSubscribe<TTopics[K]>;\n          runId?: string;\n          fnId?: string;\n          kind: \"datastream-start\" | \"datastream-end\" | \"chunk\";\n          streamId: string;\n          stream: ReadableStream<Realtime.Topic.InferSubscribe<TTopics[K]>>;\n        };\n  }[keyof TTopics];\n\n  export namespace Message {\n    // Publish (input) msg\n    export type Input<\n      TChannelId extends string = string,\n      TTopicId extends string = string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TData = any,\n    > = {\n      channel: TChannelId;\n      topic: TTopicId;\n      data: TData;\n    };\n\n    export type Raw<\n      TChannelId extends string = string,\n      TTopics extends Record<string, Realtime.Topic.Definition> = Record<\n        string,\n        Realtime.Topic.Definition\n      >,\n    > = {\n      [K in keyof TTopics]: {\n        topic?: K;\n        stream_id?: string;\n        data: Realtime.Topic.InferSubscribe<TTopics[K]>;\n        channel?: TChannelId;\n        run_id?: string;\n        fn_id?: string;\n        created_at?: Date;\n        env_id?: string;\n        kind:\n          | \"step\" // step data\n          | \"run\" // run results\n          | \"data\" // misc stream data from `ctx.publish()`\n          | \"datastream-start\"\n          | \"datastream-end\"\n          | \"ping\" // keepalive server -> client\n          | \"pong\" // keepalive client -> server\n          | \"closing\" // server is closing connection, client should reconnect\n          | \"event\" // event sent to inngest\n          | \"sub\"\n          | \"unsub\"\n          | \"chunk\";\n      };\n    }[keyof TTopics];\n  }\n\n  export type Channel<\n    TChannelId extends string = string,\n    TTopics extends Record<string, Realtime.Topic.Definition> = Record<\n      string,\n      Realtime.Topic.Definition\n    >,\n  > = {\n    [K in\n      | IsLiteral<keyof TTopics, keyof TTopics, never>\n      | \"name\"\n      | \"topics\"]: K extends \"name\"\n      ? string\n      : K extends \"topics\"\n        ? TTopics\n        : Realtime.Topic<TChannelId, TTopics[K]>;\n  };\n\n  export namespace Channel {\n    export type Like = {\n      channel: string;\n      topics: string[];\n    };\n\n    export type InferId<TChannel extends Channel> = TChannel extends Channel<\n      infer IId,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      any\n    >\n      ? IId\n      : string;\n\n    export type AsChannel<T extends Channel | string> = T extends Channel\n      ? T\n      : T extends string\n        ? Realtime.Channel<T>\n        : never;\n\n    export type InferTopics<\n      TChannel extends Channel | Channel.Definition,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    > = TChannel extends Channel.Definition<any, infer ITopics>\n      ? ITopics\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        TChannel extends Channel<any, infer ITopics>\n        ? ITopics\n        : Record<string, Realtime.Topic.Definition>;\n\n    export interface Definition<\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TChannelBuilderFn extends BuilderFn = (...args: any[]) => string,\n      TTopics extends Record<string, Topic.Definition> = Record<\n        string,\n        Topic.Definition\n      >,\n    > {\n      (\n        ...args: Parameters<TChannelBuilderFn>\n      ): Channel<ReturnType<TChannelBuilderFn>, TTopics>;\n\n      addTopic<UTopic extends Topic.Definition>(\n        topic: UTopic,\n      ): Definition<TChannelBuilderFn, AddTopic<TTopics, UTopic>>;\n\n      topics: TTopics;\n    }\n\n    export namespace Definition {\n      export type InferId<TChannel extends Definition> =\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        TChannel extends Definition<infer IBuilder, any>\n          ? ReturnType<IBuilder>\n          : string;\n\n      export type InferTopics<TChannel extends Definition> =\n        TChannel extends Definition<\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          any,\n          infer ITopics\n        >\n          ? ITopics\n          : Record<string, Topic.Definition>;\n\n      export type AsChannel<T extends Definition | Channel> =\n        T extends Definition\n          ? Channel<InferId<T>, InferTopics<T>>\n          : T extends Channel\n            ? T\n            : never;\n    }\n\n    export type AddTopic<\n      TCurr extends Record<string, Topic.Definition>,\n      TInc extends Topic.Definition,\n      TIncWrapped extends Record<TInc[\"name\"], TInc> = Record<\n        TInc[\"name\"],\n        TInc\n      >,\n    > = IsStringLiteral<keyof TCurr & string> extends true\n      ? Simplify<Omit<TCurr, TInc[\"name\"]> & TIncWrapped>\n      : TIncWrapped;\n\n    export type BuilderFn<TChannelId extends string = string> = (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ...args: any[]\n    ) => TChannelId;\n\n    export type Builder = <\n      const TChannelId extends string,\n      const TIdInput extends TChannelId | BuilderFn<TChannelId>,\n    >(\n      id: TIdInput,\n    ) => TIdInput extends TChannelId\n      ? Channel.Definition<() => TIdInput>\n      : TIdInput extends BuilderFn<TChannelId>\n        ? Channel.Definition<TIdInput>\n        : never;\n  }\n\n  export type Topic<\n    TChannelId extends string = string,\n    TTopic extends Topic.Definition = Topic.Definition,\n  > = (\n    data: Topic.InferPublish<TTopic>,\n  ) => Promise<\n    Realtime.Message.Input<\n      TChannelId,\n      Topic.InferId<TTopic>,\n      Topic.InferPublish<TTopic>\n    >\n  >;\n\n  export namespace Topic {\n    export type Like = {\n      name: string;\n    };\n\n    export interface Definition<\n      TTopicId extends string = string,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TPublish = any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      _TSubscribe = TPublish,\n    > {\n      name: TTopicId;\n\n      // Deliberately doesn't include `USubscribe` typing, as there's no schema\n      // to perform transformations.\n      type<const UPublish>(): Definition<TTopicId, UPublish>;\n\n      schema<const TSchema extends StandardSchemaV1>(\n        schema: TSchema,\n      ): Definition<\n        TTopicId,\n        StandardSchemaV1.InferInput<TSchema>,\n        StandardSchemaV1.InferOutput<TSchema>\n      >;\n\n      getSchema(): StandardSchemaV1 | undefined;\n    }\n\n    export type InferId<TTopic extends Topic.Definition> =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TTopic extends Topic.Definition<infer IId, any, any> ? IId : string;\n\n    export type InferPublish<TTopic extends Topic.Definition> =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TTopic extends Topic.Definition<any, infer IPublish, any>\n        ? IPublish\n        : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          any;\n\n    export type InferSubscribe<TTopic extends Topic.Definition> =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      TTopic extends Topic.Definition<any, any, infer ISubscribe>\n        ? ISubscribe\n        : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          any;\n\n    export type Builder = <const TTopicId extends string>(\n      id: TTopicId,\n    ) => Topic.Definition<TTopicId>;\n  }\n}\n\n/**\n * Expects that a value resolves to `true`, useful for asserting type checks.\n */\nexport type Expect<T extends true> = T;\n\n/**\nReturns a boolean for whether the two given types are equal.\n\n{@link https://github.com/microsoft/TypeScript/issues/27024#issuecomment-421529650}\n{@link https://stackoverflow.com/questions/68961864/how-does-the-equals-work-in-typescript/68963796#68963796}\n\nUse-cases:\n- If you want to make a conditional branch based on the result of a comparison of two types.\n\n@example\n```\nimport type {IsEqual} from 'type-fest';\n\n// This type returns a boolean for whether the given array includes the given item.\n// `IsEqual` is used to compare the given array at position 0 and the given item and then return true if they are equal.\ntype Includes<Value extends readonly any[], Item> =\n\tValue extends readonly [Value[0], ...infer rest]\n\t\t? IsEqual<Value[0], Item> extends true\n\t\t\t? true\n\t\t\t: Includes<rest, Item>\n\t\t: false;\n```\n*/\nexport type IsEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends <\n  G,\n>() => G extends B ? 1 : 2\n  ? true\n  : false;\n\n/**\n * Given a type `T`, return `Then` if `T` is a string, number, or symbol\n * literal, else `Else`.\n *\n * `Then` defaults to `true` and `Else` defaults to `false`.\n *\n * Useful for determining if an object is a generic type or has known keys.\n *\n * @example\n * ```ts\n * type IsLiteralType = IsLiteral<\"foo\">; // true\n * type IsLiteralType = IsLiteral<string>; // false\n *\n * type IsLiteralType = IsLiteral<1>; // true\n * type IsLiteralType = IsLiteral<number>; // false\n *\n * type IsLiteralType = IsLiteral<symbol>; // true\n * type IsLiteralType = IsLiteral<typeof Symbol.iterator>; // false\n *\n * type T0 = { foo: string };\n * type HasAllKnownKeys = IsLiteral<keyof T0>; // true\n *\n * type T1 = { [x: string]: any; foo: boolean };\n * type HasAllKnownKeys = IsLiteral<keyof T1>; // false\n * ```\n */\nexport type IsLiteral<T, Then = true, Else = false> = string extends T\n  ? Else\n  : number extends T\n    ? Else\n    : symbol extends T\n      ? Else\n      : Then;\n\n/**\n * Returns `true` if the given generic `T` is a string literal, e.g. `\"foo\"`, or\n * `false` if it is a string type, e.g. `string`.\n *\n * Useful for checking whether the keys of an object are known or not.\n *\n * @example\n * ```ts\n * // false\n * type ObjIsGeneric = IsStringLiteral<keyof Record<string, boolean>>;\n *\n * // true\n * type ObjIsKnown = IsStringLiteral<keyof { foo: boolean; }>; // true\n * ```\n *\n * @internal\n */\nexport type IsStringLiteral<T extends string> = string extends T ? false : true;\n\n/**\n * Returns the given generic as either itself or a promise of itself.\n */\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport type Simplify<T> = { [KeyType in keyof T]: T[KeyType] } & {};\n"],"mappings":";;;;;2BA8G+B,EAC1B,OAAO;EACN,SAAS,EAAE,QAAQ,CAAC,UAAU;EAC9B,OAAO,EAAE,QAAQ,CAAC,UAAU;EAC5B,MAAM,EAAE,KAAK;EACb,QAAQ,EAAE,QAAQ,CAAC,UAAU;EAC7B,OAAO,EAAE,QAAQ,CAAC,UAAU;EAC5B,YAAY,EACT,QAAQ,CACR,UAAU,CACV,WAAW,MAAO,IAAI,IAAI,KAAK,EAAE,GAAG,OAAW;EAClD,QAAQ,EAAE,QAAQ,CAAC,UAAU;EAC7B,WAAW,EAAE,QAAQ,CAAC,UAAU;EAChC,MAAM,EAAE,KAAK;GACX;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACA;GACD,CAAC;EACH,CAAC,CACD,WAAW,EAAE,KAAM,GAAG,WAAW;AAChC,SAAO;GACL,GAAG;GACH,MAAM,QAAQ;GACf;GACD"}