{"version":3,"file":"hooks.js","names":["subscribe","interval: NodeJS.Timeout | null"],"sources":["../src/hooks.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\nimport { subscribe } from \"./subscribe\";\nimport { type Realtime } from \"./types\";\n\nexport enum InngestSubscriptionState {\n  Closed = \"closed\",\n  Error = \"error\",\n  RefreshingToken = \"refresh_token\",\n  Connecting = \"connecting\",\n  Active = \"active\",\n  Closing = \"closing\",\n}\n\n/**\n * TODO\n */\nexport interface InngestSubscription<TToken extends Realtime.Subscribe.Token> {\n  /**\n   * TODO\n   */\n  data: Realtime.Subscribe.Token.InferMessage<TToken>[];\n\n  /**\n   * TODO\n   */\n  latestData: Realtime.Subscribe.Token.InferMessage<TToken> | null;\n\n  /**\n   * TODO\n   */\n  freshData: Realtime.Subscribe.Token.InferMessage<TToken>[];\n\n  /**\n   * TODO\n   */\n  error: Error | null;\n\n  /**\n   * TODO\n   */\n  state: InngestSubscriptionState;\n}\n\n/**\n * TODO\n */\nexport function useInngestSubscription<\n  const TToken extends Realtime.Subscribe.Token | null | undefined,\n>({\n  token: tokenInput,\n  refreshToken,\n  key,\n  enabled = true,\n  bufferInterval = 0,\n}: {\n  /**\n   * TODO\n   */\n  token?: TToken;\n\n  /**\n   * TODO\n   */\n  refreshToken?: () => Promise<TToken>;\n\n  /**\n   * TODO\n   */\n  key?: string;\n\n  /**\n   * TODO\n   */\n  enabled?: boolean;\n\n  /**\n   * TODO\n   */\n  bufferInterval?: number;\n}): InngestSubscription<NonNullable<TToken>> {\n  const [token, setToken] = useState<TToken | null | undefined>(tokenInput);\n  const [data, setData] = useState<Realtime.Message[]>([]);\n  const [freshData, setFreshData] = useState<Realtime.Message[]>([]);\n  const [error, setError] = useState<Error | null>(null);\n  const [state, setState] = useState<InngestSubscriptionState>(\n    InngestSubscriptionState.Closed,\n  );\n\n  const subscriptionRef = useRef<Realtime.Subscribe.StreamSubscription | null>(\n    null,\n  );\n  const readerRef =\n    useRef<ReadableStreamDefaultReader<Realtime.Message> | null>(null);\n  const messageBuffer = useRef<Realtime.Message[]>([]);\n  const bufferIntervalRef = useRef<number>(bufferInterval);\n\n  // Sync token if tokenInput prop changes\n  useEffect(() => {\n    if (tokenInput) setToken(tokenInput);\n  }, [tokenInput]);\n\n  // Token fetch fallback on mount\n  useEffect(() => {\n    if (!token && enabled) {\n      if (refreshToken) {\n        setState(InngestSubscriptionState.RefreshingToken);\n        refreshToken()\n          .then((newToken) => setToken(newToken))\n          .catch((err) => {\n            setError(err);\n            setState(InngestSubscriptionState.Error);\n          });\n      } else {\n        setError(new Error(\"No token provided and no refreshToken handler.\"));\n        setState(InngestSubscriptionState.Error);\n      }\n    }\n  }, []);\n\n  // Subscription management\n  useEffect(() => {\n    setError(null);\n    if (!enabled || !token) return;\n    let cancelled = false;\n\n    const start = async () => {\n      try {\n        setState(InngestSubscriptionState.Connecting);\n        const stream = await subscribe({ ...token });\n        if (cancelled) return;\n\n        subscriptionRef.current = stream;\n        setState(InngestSubscriptionState.Active);\n\n        // Explicitly get and manage the reader so that we can manually release\n        // the lock if anything goes wrong or we're done with it.\n        //\n        // Especially when this is unmounted.\n        const reader = stream.getReader();\n        readerRef.current = reader;\n        try {\n          while (!cancelled) {\n            const { done, value } = await reader.read();\n            if (done || cancelled) break;\n\n            if (bufferIntervalRef.current === 0) {\n              setFreshData([value]);\n              setData((prev) => [...prev, value]);\n            } else {\n              messageBuffer.current.push(value);\n            }\n          }\n        } finally {\n          try {\n            reader.releaseLock();\n          } catch {\n            // Reader might already be released\n          }\n\n          readerRef.current = null;\n        }\n\n        // Stream has closed cleanly\n        if (!cancelled) {\n          setState(InngestSubscriptionState.Closed);\n          if (enabled) start();\n        }\n      } catch (err) {\n        if (cancelled) return;\n        if (refreshToken) {\n          setState(InngestSubscriptionState.RefreshingToken);\n          refreshToken()\n            .then((newToken) => setToken(newToken))\n            .catch((e) => {\n              setError(e);\n              setState(InngestSubscriptionState.Error);\n            });\n        } else {\n          setError(err as Error);\n          setState(InngestSubscriptionState.Error);\n        }\n      }\n    };\n\n    start();\n\n    return () => {\n      cancelled = true;\n\n      const cleanup = async () => {\n        const readerToRemove = readerRef.current;\n        const subToRemove = subscriptionRef.current;\n\n        readerRef.current = null;\n        subscriptionRef.current = null;\n\n        try {\n          await readerToRemove?.cancel();\n        } catch {\n          // Reader might already be cancelled\n        }\n\n        try {\n          readerToRemove?.releaseLock();\n        } catch {\n          // Reader might already be released\n        }\n\n        try {\n          await subToRemove?.cancel();\n        } catch {\n          // Subscription might already be cancelled\n        }\n      };\n\n      cleanup()\n        .catch((err) => {\n          console.error(\"Error cleaning up Inngest subscription\", err);\n        })\n        .finally(() => {\n          // Ensure state is always updated even if cleanup fails\n          setState(InngestSubscriptionState.Closed);\n        });\n    };\n  }, [token, enabled, key]);\n\n  // Buffer flushing\n  useEffect(() => {\n    bufferIntervalRef.current = bufferInterval;\n    let interval: NodeJS.Timeout | null = null;\n\n    if (bufferInterval > 0) {\n      interval = setInterval(() => {\n        if (messageBuffer.current.length > 0) {\n          const buffered = [...messageBuffer.current];\n          messageBuffer.current = [];\n\n          setFreshData(buffered);\n          setData((prev) => [...prev, ...buffered]);\n        }\n      }, bufferInterval);\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [bufferInterval]);\n\n  return {\n    data,\n    latestData: data[data.length - 1] ?? null,\n    freshData,\n    error,\n    state,\n  } as unknown as InngestSubscription<NonNullable<TToken>>;\n}\n"],"mappings":"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"}