{"version":3,"file":"util.mjs","names":["resolve: DeferredPromiseReturn<T>[\"resolve\"]","reject: DeferredPromiseReturn<T>[\"reject\"]"],"sources":["../src/util.ts"],"sourcesContent":["type DeferredPromiseReturn<T> = {\n  promise: Promise<T>;\n  resolve: (value: T) => DeferredPromiseReturn<T>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  reject: (reason: any) => DeferredPromiseReturn<T>;\n};\n\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nexport const createDeferredPromise = <T>(): DeferredPromiseReturn<T> => {\n  let resolve: DeferredPromiseReturn<T>[\"resolve\"];\n  let reject: DeferredPromiseReturn<T>[\"reject\"];\n\n  const promise = new Promise<T>((_resolve, _reject) => {\n    resolve = (value: T) => {\n      _resolve(value);\n      return createDeferredPromise<T>();\n    };\n\n    reject = (reason) => {\n      _reject(reason);\n      return createDeferredPromise<T>();\n    };\n  });\n\n  return { promise, resolve: resolve!, reject: reject! };\n};\n\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nexport async function fetchWithAuthFallback<TFetch extends typeof fetch>({\n  authToken,\n  authTokenFallback,\n  fetch,\n  options,\n  url,\n}: {\n  authToken: string | undefined;\n  authTokenFallback: string | undefined;\n  fetch: TFetch;\n  options?: Parameters<TFetch>[1];\n  url: URL | string;\n}): Promise<Response> {\n  let res = await fetch(url, {\n    ...options,\n    headers: {\n      ...options?.headers,\n      ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),\n    },\n  });\n\n  if ([401, 403].includes(res.status) && authTokenFallback) {\n    res = await fetch(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        Authorization: `Bearer ${authTokenFallback}`,\n      },\n    });\n  }\n\n  return res;\n}\n\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nexport const parseAsBoolean = (value: unknown): boolean | undefined => {\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (typeof value === \"number\") {\n    return Boolean(value);\n  }\n\n  if (typeof value === \"string\") {\n    const trimmed = value.trim().toLowerCase();\n\n    if (trimmed === \"undefined\") {\n      return undefined;\n    }\n\n    if ([\"true\", \"1\"].includes(trimmed)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return undefined;\n};\n"],"mappings":";;;;;;;;AAcA,MAAa,8BAA2D;CACtE,IAAIA;CACJ,IAAIC;AAcJ,QAAO;EAAE,SAZO,IAAI,SAAY,UAAU,YAAY;AACpD,cAAW,UAAa;AACtB,aAAS,MAAM;AACf,WAAO,uBAA0B;;AAGnC,aAAU,WAAW;AACnB,YAAQ,OAAO;AACf,WAAO,uBAA0B;;IAEnC;EAEyB;EAAkB;EAAS;;;;;;AAOxD,eAAsB,sBAAmD,EACvE,WACA,mBACA,OACA,SACA,OAOoB;CACpB,IAAI,MAAM,MAAM,MAAM,KAAK;EACzB,GAAG;EACH,SAAS;GACP,GAAG,SAAS;GACZ,GAAI,YAAY,EAAE,eAAe,UAAU,aAAa,GAAG,EAAE;GAC9D;EACF,CAAC;AAEF,KAAI,CAAC,KAAK,IAAI,CAAC,SAAS,IAAI,OAAO,IAAI,kBACrC,OAAM,MAAM,MAAM,KAAK;EACrB,GAAG;EACH,SAAS;GACP,GAAG,SAAS;GACZ,eAAe,UAAU;GAC1B;EACF,CAAC;AAGJ,QAAO;;;;;;;;;;AAWT,MAAa,kBAAkB,UAAwC;AACrE,KAAI,OAAO,UAAU,UACnB,QAAO;AAGT,KAAI,OAAO,UAAU,SACnB,QAAO,QAAQ,MAAM;AAGvB,KAAI,OAAO,UAAU,UAAU;EAC7B,MAAM,UAAU,MAAM,MAAM,CAAC,aAAa;AAE1C,MAAI,YAAY,YACd;AAGF,MAAI,CAAC,QAAQ,IAAI,CAAC,SAAS,QAAQ,CACjC,QAAO;AAGT,SAAO"}