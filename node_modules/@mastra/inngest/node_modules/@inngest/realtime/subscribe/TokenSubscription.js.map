{"version":3,"file":"TokenSubscription.js","names":["StreamFanout","token: Realtime.Subscribe.Token","#apiBaseUrl","#signingKey","#signingKeyFallback","#channelId","#topics","topic","url: URL","getEnvVar","parseAsBoolean","#debug","createDeferredPromise","#ws","Realtime","#running","#fanout","streamId: unknown","#chunkStreams","api","#encoder"],"sources":["../../src/subscribe/TokenSubscription.ts"],"sourcesContent":["import debug from \"debug\";\nimport { api } from \"../api\";\nimport { getEnvVar } from \"../env\";\nimport { topic } from \"../topic\";\nimport { Realtime } from \"../types\";\nimport { createDeferredPromise, parseAsBoolean } from \"../util\";\nimport { StreamFanout } from \"./StreamFanout\";\n\n/**\n * TODO\n */\nexport class TokenSubscription {\n  #apiBaseUrl?: string;\n  #channelId: string;\n  #debug = debug(\"inngest:realtime\");\n  #encoder = new TextEncoder();\n  #fanout = new StreamFanout<Realtime.Message>();\n  #running = false;\n  #topics: Map<string, Realtime.Topic.Definition>;\n  #ws: WebSocket | null = null;\n  #signingKey: string | undefined;\n  #signingKeyFallback: string | undefined;\n\n  /**\n   * This is a map that tracks stream IDs to their corresponding streams and\n   * controllers.\n   */\n  #chunkStreams = new Map<\n    string,\n    { stream: ReadableStream; controller: ReadableStreamDefaultController }\n  >();\n\n  constructor(\n    /**\n     * TODO\n     */\n    public token: Realtime.Subscribe.Token,\n    apiBaseUrl: string | undefined,\n    signingKey: string | undefined,\n    signingKeyFallback: string | undefined,\n  ) {\n    this.#apiBaseUrl = apiBaseUrl;\n    this.#signingKey = signingKey;\n    this.#signingKeyFallback = signingKeyFallback;\n\n    if (typeof token.channel === \"string\") {\n      this.#channelId = token.channel;\n\n      this.#topics = this.token.topics.reduce<\n        Map<string, Realtime.Topic.Definition>\n      >((acc, name) => {\n        acc.set(name, topic(name));\n\n        return acc;\n      }, new Map<string, Realtime.Topic.Definition>());\n    } else {\n      this.#channelId = token.channel.name;\n\n      this.#topics = this.token.topics.reduce<\n        Map<string, Realtime.Topic.Definition>\n      >((acc, name) => {\n        acc.set(name, token.channel.topics[name] ?? topic(name));\n\n        return acc;\n      }, new Map<string, Realtime.Topic.Definition>());\n    }\n  }\n\n  private async getWsUrl(token: string): Promise<URL> {\n    let url: URL;\n    const path = \"/v1/realtime/connect\";\n    const devEnvVar = getEnvVar(\"INNGEST_DEV\");\n\n    if (this.#apiBaseUrl) {\n      url = new URL(path, this.#apiBaseUrl);\n    } else if (devEnvVar) {\n      try {\n        const devUrl = new URL(devEnvVar);\n        url = new URL(path, devUrl);\n      } catch {\n        if (parseAsBoolean(devEnvVar)) {\n          url = new URL(path, \"http://localhost:8288/\");\n        } else {\n          url = new URL(path, \"https://api.inngest.com/\");\n        }\n      }\n    } else {\n      url = new URL(\n        path,\n        getEnvVar(\"NODE_ENV\") === \"production\"\n          ? \"https://api.inngest.com/\"\n          : \"http://localhost:8288/\",\n      );\n    }\n\n    url.protocol = url.protocol === \"http:\" ? \"ws:\" : \"wss:\";\n    url.searchParams.set(\"token\", token);\n\n    return url;\n  }\n\n  /**\n   * TODO\n   */\n  public async connect() {\n    this.#debug(\n      `Establishing connection to channel \"${\n        this.#channelId\n      }\" with topics ${JSON.stringify([...this.#topics.keys()])}...`,\n    );\n\n    if (typeof WebSocket === \"undefined\") {\n      throw new Error(\"WebSockets not supported in current environment\");\n    }\n\n    let key = this.token.key;\n    if (!key) {\n      this.#debug(\n        \"No subscription token key passed; attempting to retrieve one automatically...\",\n      );\n\n      key = (\n        await this.lazilyGetSubscriptionToken({\n          ...this.token,\n          signingKey: this.#signingKey,\n          signingKeyFallback: this.#signingKeyFallback,\n        })\n      ).key;\n\n      if (!key) {\n        throw new Error(\n          \"No subscription token key passed and failed to retrieve one automatically\",\n        );\n      }\n    }\n\n    const ret = createDeferredPromise<void>();\n\n    try {\n      this.#ws = new WebSocket(await this.getWsUrl(key));\n\n      this.#ws.onopen = () => {\n        this.#debug(\"WebSocket connection established\");\n        ret.resolve();\n      };\n\n      this.#ws.onmessage = async (event) => {\n        const parseRes = await Realtime.messageSchema.safeParseAsync(\n          JSON.parse(event.data as string),\n        );\n\n        if (!parseRes.success) {\n          this.#debug(\"Received invalid message:\", parseRes.error);\n          return;\n        }\n\n        const msg = parseRes.data;\n\n        if (!this.#running) {\n          this.#debug(\n            `Received message on channel \"${msg.channel}\" for topic \"${msg.topic}\" but stream is closed`,\n          );\n        }\n\n        switch (msg.kind) {\n          case \"data\": {\n            if (!msg.channel) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no channel`,\n              );\n              return;\n            }\n\n            if (!msg.topic) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no topic`,\n              );\n              return;\n            }\n\n            const topic = this.#topics.get(msg.topic);\n            if (!topic) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" for unknown topic \"${msg.topic}\"`,\n              );\n              return;\n            }\n\n            const schema = topic.getSchema();\n            if (schema) {\n              const validateRes = await schema[\"~standard\"].validate(msg.data);\n              if (validateRes.issues) {\n                console.error(\n                  `Received message on channel \"${msg.channel}\" for topic \"${msg.topic}\" that failed schema validation:`,\n                  validateRes.issues,\n                );\n                return;\n              }\n\n              msg.data = validateRes.value;\n            }\n\n            this.#debug(\n              `Received message on channel \"${msg.channel}\" for topic \"${msg.topic}\":`,\n              msg.data,\n            );\n            return this.#fanout.write({\n              channel: msg.channel,\n              topic: msg.topic,\n              data: msg.data,\n              fnId: msg.fn_id,\n              createdAt: msg.created_at || new Date(),\n              runId: msg.run_id,\n              kind: \"data\",\n              envId: msg.env_id,\n            });\n          }\n\n          case \"datastream-start\": {\n            if (!msg.channel) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no channel`,\n              );\n              return;\n            }\n\n            if (!msg.topic) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no topic`,\n              );\n              return;\n            }\n\n            const streamId: unknown = msg.data;\n            if (typeof streamId !== \"string\" || !streamId) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no stream ID`,\n              );\n              return;\n            }\n\n            // `data` is a stream ID that we'll start receiving chunks with\n            if (this.#chunkStreams.has(streamId)) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" to create stream ID \"${streamId}\" that already exists`,\n              );\n              return;\n            }\n\n            const stream = new ReadableStream({\n              start: (controller) => {\n                this.#chunkStreams.set(streamId, { stream, controller });\n              },\n\n              cancel: () => {\n                this.#chunkStreams.delete(streamId);\n              },\n            });\n\n            this.#debug(\n              `Created stream ID \"${streamId}\" on channel \"${msg.channel}\"`,\n            );\n            return this.#fanout.write({\n              channel: msg.channel,\n              topic: msg.topic,\n              kind: \"datastream-start\",\n              data: streamId,\n              streamId,\n              fnId: msg.fn_id,\n              runId: msg.run_id,\n              stream,\n            });\n          }\n\n          case \"datastream-end\": {\n            if (!msg.channel) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no channel`,\n              );\n              return;\n            }\n\n            if (!msg.topic) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no topic`,\n              );\n              return;\n            }\n\n            const streamId: unknown = msg.data;\n            if (typeof streamId !== \"string\" || !streamId) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no stream ID`,\n              );\n              return;\n            }\n\n            // `data` is a stream ID that we'll stop receiving chunks with\n            const stream = this.#chunkStreams.get(streamId);\n            if (!stream) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" to close stream ID \"${streamId}\" that doesn't exist`,\n              );\n              return;\n            }\n\n            stream.controller.close();\n            this.#chunkStreams.delete(streamId);\n\n            this.#debug(\n              `Closed stream ID \"${streamId}\" on channel \"${msg.channel}\"`,\n            );\n            return this.#fanout.write({\n              channel: msg.channel,\n              topic: msg.topic,\n              kind: \"datastream-end\",\n              data: streamId,\n              streamId,\n              fnId: msg.fn_id,\n              runId: msg.run_id,\n              stream: stream.stream,\n            });\n          }\n\n          case \"chunk\": {\n            if (!msg.channel) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no channel`,\n              );\n              return;\n            }\n\n            if (!msg.topic) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no topic`,\n              );\n              return;\n            }\n\n            // `stream_id` is the ID of the stream we're receiving chunks for\n            if (!msg.stream_id) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" with no stream ID`,\n              );\n              return;\n            }\n\n            const stream = this.#chunkStreams.get(msg.stream_id);\n            if (!stream) {\n              this.#debug(\n                `Received message on channel \"${msg.channel}\" for unknown stream ID \"${msg.stream_id}\"`,\n              );\n              return;\n            }\n\n            this.#debug(\n              `Received chunk on channel \"${msg.channel}\" for stream ID \"${msg.stream_id}\":`,\n              msg.data,\n            );\n\n            stream.controller.enqueue(msg.data);\n\n            return this.#fanout.write({\n              channel: msg.channel,\n              topic: msg.topic,\n              kind: \"chunk\",\n              data: msg.data,\n              streamId: msg.stream_id,\n              fnId: msg.fn_id,\n              runId: msg.run_id,\n              stream: stream.stream,\n            });\n          }\n\n          default: {\n            this.#debug(\n              `Received message on channel \"${msg.channel}\" with unhandled kind \"${msg.kind}\"`,\n            );\n            return;\n          }\n        }\n      };\n\n      this.#ws.onerror = (event) => {\n        console.error(\"WebSocket error observed:\", event);\n        ret.reject(event);\n      };\n\n      this.#ws.onclose = (event) => {\n        this.#debug(\"WebSocket closed:\", event.reason);\n        this.close();\n      };\n\n      this.#running = true;\n    } catch (err) {\n      ret.reject(err);\n    }\n\n    return ret.promise;\n  }\n\n  /**\n   * TODO\n   */\n  private async lazilyGetSubscriptionToken<\n    const InputChannel extends Realtime.Channel | string,\n    const InputTopics extends (keyof Realtime.Channel.InferTopics<\n      Realtime.Channel.AsChannel<InputChannel>\n    > &\n      string)[],\n    const TToken extends Realtime.Subscribe.Token<\n      Realtime.Channel.AsChannel<InputChannel>,\n      InputTopics\n    >,\n  >(\n    /**\n     * TODO\n     */\n    args: {\n      /**\n       * TODO\n       */\n      channel: Realtime.Subscribe.InferChannelInput<InputChannel>;\n\n      /**\n       * TODO\n       */\n      topics: InputTopics;\n\n      /**\n       * TODO\n       */\n      signingKey: string | undefined;\n\n      /**\n       * TODO\n       */\n      signingKeyFallback: string | undefined;\n    },\n  ): Promise<TToken> {\n    const channelId =\n      typeof args.channel === \"string\" ? args.channel : args.channel.name;\n\n    if (!channelId) {\n      throw new Error(\"Channel ID is required to create a subscription token\");\n    }\n\n    const key = await api.getSubscriptionToken({\n      channel: channelId,\n      topics: args.topics,\n      signingKey: args.signingKey,\n      signingKeyFallback: args.signingKeyFallback,\n      apiBaseUrl: this.#apiBaseUrl,\n    });\n\n    const token = {\n      channel: channelId,\n      topics: args.topics,\n      key,\n    } as TToken;\n\n    return token;\n  }\n\n  /**\n   * TODO\n   */\n  public close(\n    /**\n     * TODO\n     */\n    reason = \"Userland closed connection\",\n  ) {\n    if (!this.#running) {\n      return;\n    }\n\n    this.#debug(\"close() called; closing connection...\");\n    this.#running = false;\n    this.#ws?.close(1000, reason);\n\n    this.#debug(`Closing ${this.#fanout.size()} streams...`);\n    this.#fanout.close();\n  }\n\n  /**\n   * TODO\n   */\n  public getJsonStream() {\n    return this.#fanout.createStream();\n  }\n\n  /**\n   * TODO\n   */\n  public getEncodedStream() {\n    return this.#fanout.createStream((chunk) => {\n      return this.#encoder.encode(`${JSON.stringify(chunk)}\\n`);\n    });\n  }\n\n  /**\n   * TODO\n   */\n  public useCallback(\n    callback: Realtime.Subscribe.Callback,\n    stream: ReadableStream<Realtime.Message> = this.getJsonStream(),\n  ) {\n    void (async () => {\n      // Explicitly get and manage the reader so that we can manually release\n      // the lock if anything goes wrong or we're done with it.\n      const reader = stream.getReader();\n      try {\n        while (this.#running) {\n          const { done, value } = await reader.read();\n          if (done || !this.#running) break;\n\n          callback(value);\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    })();\n  }\n}\n"],"mappings":"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"}