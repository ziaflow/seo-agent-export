import type { ReadableStream } from 'node:stream/web';
import type { Agent } from '@mastra/core/agent';
import type { TracingContext, AnyAISpan } from '@mastra/core/ai-tracing';
import { RuntimeContext } from '@mastra/core/di';
import type { Mastra } from '@mastra/core/mastra';
import type { WorkflowRun, WorkflowRuns } from '@mastra/core/storage';
import type { ToolExecutionContext } from '@mastra/core/tools';
import { Tool } from '@mastra/core/tools';
import { Workflow, Run, DefaultExecutionEngine } from '@mastra/core/workflows';
import type { ExecuteFunction, ExecutionContext, ExecutionEngine, ExecutionGraph, Step, WorkflowConfig, StepFlowEntry, StepResult, WorkflowResult, SerializedStepFlowEntry, Emitter, WatchEvent, StreamEvent, ChunkType, ExecutionEngineOptions, StepWithComponent } from '@mastra/core/workflows';
import type { Span } from '@opentelemetry/api';
import type { Inngest, BaseContext, InngestFunction, RegisterOptions } from 'inngest';
import { serve as inngestServe } from 'inngest/hono';
import { z } from 'zod';
type InngestCreateFunctionConfig = Parameters<Inngest['createFunction']>[0];
export type InngestFlowControlConfig = Pick<InngestCreateFunctionConfig, 'concurrency' | 'rateLimit' | 'throttle' | 'debounce' | 'priority'>;
export type InngestWorkflowConfig<TWorkflowId extends string = string, TState extends z.ZodObject<any> = z.ZodObject<any>, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>, TSteps extends Step<string, any, any, any, any, any>[] = Step<string, any, any, any, any, any>[]> = WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps> & InngestFlowControlConfig;
export type InngestEngineType = {
    step: any;
};
export declare function serve({ mastra, inngest, functions: userFunctions, registerOptions, }: {
    mastra: Mastra;
    inngest: Inngest;
    /**
     * Optional array of additional functions to serve and register with Inngest.
     */
    functions?: InngestFunction.Like[];
    registerOptions?: RegisterOptions;
}): ReturnType<typeof inngestServe>;
export declare class InngestRun<TEngineType = InngestEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TState extends z.ZodObject<any> = z.ZodObject<any>, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>> extends Run<TEngineType, TSteps, TState, TInput, TOutput> {
    #private;
    private inngest;
    serializedStepGraph: SerializedStepFlowEntry[];
    constructor(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        executionEngine: ExecutionEngine;
        executionGraph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        mastra?: Mastra;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        cleanup?: () => void;
        workflowSteps: Record<string, StepWithComponent>;
    }, inngest: Inngest);
    getRuns(eventId: string): Promise<any>;
    getRunOutput(eventId: string): Promise<any>;
    sendEvent(event: string, data: any): Promise<void>;
    cancel(): Promise<void>;
    start({ inputData, initialState, }: {
        inputData?: z.infer<TInput>;
        runtimeContext?: RuntimeContext;
        initialState?: z.infer<TState>;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    resume<TResumeSchema extends z.ZodType<any>>(params: {
        resumeData?: z.infer<TResumeSchema>;
        step: Step<string, any, any, TResumeSchema, any> | [...Step<string, any, any, any, any>[], Step<string, any, any, TResumeSchema, any>] | string | string[];
        runtimeContext?: RuntimeContext;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    _resume<TResumeSchema extends z.ZodType<any>>(params: {
        resumeData?: z.infer<TResumeSchema>;
        step: Step<string, any, any, TResumeSchema, any> | [...Step<string, any, any, any, any>[], Step<string, any, any, TResumeSchema, any>] | string | string[];
        runtimeContext?: RuntimeContext;
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    watch(cb: (event: WatchEvent) => void, type?: 'watch' | 'watch-v2'): () => void;
    stream({ inputData, runtimeContext }?: {
        inputData?: z.infer<TInput>;
        runtimeContext?: RuntimeContext;
    }): {
        stream: ReadableStream<StreamEvent>;
        getWorkflowState: () => Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    };
}
export declare class InngestWorkflow<TEngineType = InngestEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TWorkflowId extends string = string, TState extends z.ZodObject<any> = z.ZodObject<any>, TInput extends z.ZodType<any> = z.ZodType<any>, TOutput extends z.ZodType<any> = z.ZodType<any>, TPrevSchema extends z.ZodType<any> = TInput> extends Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {
    #private;
    inngest: Inngest;
    private function;
    private readonly flowControlConfig?;
    constructor(params: InngestWorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>, inngest: Inngest);
    getWorkflowRuns(args?: {
        fromDate?: Date;
        toDate?: Date;
        limit?: number;
        offset?: number;
        resourceId?: string;
    }): Promise<WorkflowRuns>;
    getWorkflowRunById(runId: string): Promise<WorkflowRun | null>;
    __registerMastra(mastra: Mastra): void;
    /**
     * @deprecated Use createRunAsync() instead.
     * @throws {Error} Always throws an error directing users to use createRunAsync()
     */
    createRun(_options?: {
        runId?: string;
    }): Run<TEngineType, TSteps, TState, TInput, TOutput>;
    createRunAsync(options?: {
        runId?: string;
        resourceId?: string;
    }): Promise<Run<TEngineType, TSteps, TState, TInput, TOutput>>;
    getFunction(): InngestFunction<Omit<InngestFunction.Options<Inngest<import("inngest").ClientOptions>, import("inngest").InngestMiddleware.Stack, InngestFunction.Trigger<string>[] | [{
        cron: string;
    } & Partial<Record<"event" | "if", never>>] | [{
        event: string;
        if?: string;
    } & Partial<Record<"cron", never>>], import("inngest").Handler.Any>, "triggers">, import("inngest").Handler.Any, import("inngest").Handler.Any, Inngest<import("inngest").ClientOptions>, import("inngest").InngestMiddleware.Stack, InngestFunction.Trigger<string>[] | [{
        cron: string;
    } & Partial<Record<"event" | "if", never>>] | [{
        event: string;
        if?: string;
    } & Partial<Record<"cron", never>>]>;
    getNestedFunctions(steps: StepFlowEntry[]): ReturnType<Inngest['createFunction']>[];
    getFunctions(): InngestFunction<Omit<InngestFunction.Options<Inngest<import("inngest").ClientOptions>, import("inngest").InngestMiddleware.Stack, InngestFunction.Trigger<string>[] | [{
        cron: string;
    } & Partial<Record<"event" | "if", never>>] | [{
        event: string;
        if?: string;
    } & Partial<Record<"cron", never>>], import("inngest").Handler.Any>, "triggers">, import("inngest").Handler.Any, import("inngest").Handler.Any, Inngest<import("inngest").ClientOptions>, import("inngest").InngestMiddleware.Stack, InngestFunction.Trigger<string>[] | [{
        cron: string;
    } & Partial<Record<"event" | "if", never>>] | [{
        event: string;
        if?: string;
    } & Partial<Record<"cron", never>>]>[];
}
export declare function createStep<TStepId extends string, TState extends z.ZodObject<any>, TStepInput extends z.ZodType<any>, TStepOutput extends z.ZodType<any>, TResumeSchema extends z.ZodType<any>, TSuspendSchema extends z.ZodType<any>>(params: {
    id: TStepId;
    description?: string;
    inputSchema: TStepInput;
    outputSchema: TStepOutput;
    resumeSchema?: TResumeSchema;
    suspendSchema?: TSuspendSchema;
    stateSchema?: TState;
    execute: ExecuteFunction<z.infer<TState>, z.infer<TStepInput>, z.infer<TStepOutput>, z.infer<TResumeSchema>, z.infer<TSuspendSchema>, InngestEngineType>;
}): Step<TStepId, TState, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, InngestEngineType>;
export declare function createStep<TStepId extends string, TStepInput extends z.ZodObject<{
    prompt: z.ZodString;
}>, TStepOutput extends z.ZodObject<{
    text: z.ZodString;
}>, TResumeSchema extends z.ZodType<any>, TSuspendSchema extends z.ZodType<any>>(agent: Agent<TStepId, any, any>): Step<TStepId, any, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema, InngestEngineType>;
export declare function createStep<TSchemaIn extends z.ZodType<any>, TSuspendSchema extends z.ZodType<any>, TResumeSchema extends z.ZodType<any>, TSchemaOut extends z.ZodType<any>, TContext extends ToolExecutionContext<TSchemaIn, TSuspendSchema, TResumeSchema>>(tool: Tool<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext> & {
    inputSchema: TSchemaIn;
    outputSchema: TSchemaOut;
    execute: (context: TContext) => Promise<any>;
}): Step<string, any, TSchemaIn, TSchemaOut, z.ZodType<any>, z.ZodType<any>, InngestEngineType>;
export declare function init(inngest: Inngest): {
    createWorkflow<TWorkflowId extends string = string, TState extends z.ZodObject<any> = z.ZodObject<any, z.UnknownKeysParam, z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>, TInput extends z.ZodType<any> = z.ZodType<any, z.ZodTypeDef, any>, TOutput extends z.ZodType<any> = z.ZodType<any, z.ZodTypeDef, any>, TSteps extends Step<string, any, any, any, any, any, InngestEngineType>[] = Step<string, any, any, any, any, any, InngestEngineType>[]>(params: InngestWorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>): InngestWorkflow<InngestEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TInput>;
    createStep: typeof createStep;
    cloneStep<TStepId extends string>(step: Step<TStepId, any, any, any, any, any, InngestEngineType>, opts: {
        id: TStepId;
    }): Step<TStepId, any, any, any, any, any, InngestEngineType>;
    cloneWorkflow<TWorkflowId extends string = string, TState extends z.ZodObject<any> = z.ZodObject<any, z.UnknownKeysParam, z.ZodTypeAny, {
        [x: string]: any;
    }, {
        [x: string]: any;
    }>, TInput extends z.ZodType<any> = z.ZodType<any, z.ZodTypeDef, any>, TOutput extends z.ZodType<any> = z.ZodType<any, z.ZodTypeDef, any>, TSteps extends Step<string, any, any, any, any, any, InngestEngineType>[] = Step<string, any, any, any, any, any, InngestEngineType>[], TPrevSchema extends z.ZodType<any> = TInput>(workflow: Workflow<InngestEngineType, TSteps, string, TState, TInput, TOutput, TPrevSchema>, opts: {
        id: TWorkflowId;
    }): Workflow<InngestEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema>;
};
export declare class InngestExecutionEngine extends DefaultExecutionEngine {
    private inngestStep;
    private inngestAttempts;
    constructor(mastra: Mastra, inngestStep: BaseContext<Inngest>['step'], inngestAttempts: number | undefined, options: ExecutionEngineOptions);
    execute<TState, TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        initialState?: TState;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: Emitter;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        runtimeContext: RuntimeContext;
        abortController: AbortController;
        currentSpan?: AnyAISpan;
        outputOptions?: {
            includeState?: boolean;
        };
    }): Promise<TOutput>;
    protected fmtReturnValue<TOutput>(executionSpan: Span | undefined, emitter: Emitter, stepResults: Record<string, StepResult<any, any, any, any>>, lastOutput: StepResult<any, any, any, any>, error?: Error | string): Promise<TOutput>;
    executeSleep({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleep';
            id: string;
            duration?: number;
            fn?: ExecuteFunction<any, any, any, any, any, InngestEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        tracingContext?: TracingContext;
    }): Promise<void>;
    executeSleepUntil({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleepUntil';
            id: string;
            date?: Date;
            fn?: ExecuteFunction<any, any, any, any, any, InngestEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        tracingContext?: TracingContext;
    }): Promise<void>;
    executeWaitForEvent({ event, timeout }: {
        event: string;
        timeout?: number;
    }): Promise<any>;
    executeStep({ step, stepResults, executionContext, resume, prevOutput, emitter, abortController, runtimeContext, tracingContext, writableStream, disableScorers, }: {
        step: Step<string, any, any>;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        executionContext: ExecutionContext;
        resume?: {
            steps: string[];
            resumePayload: any;
            runId?: string;
        };
        prevOutput: any;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        tracingContext?: TracingContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    persistStepUpdate({ workflowId, runId, stepResults, resourceId, executionContext, serializedStepGraph, workflowStatus, result, error, }: {
        workflowId: string;
        runId: string;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        serializedStepGraph: SerializedStepFlowEntry[];
        resourceId?: string;
        executionContext: ExecutionContext;
        workflowStatus: 'success' | 'failed' | 'suspended' | 'running';
        result?: Record<string, any>;
        error?: string | Error;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeConditional({ workflowId, runId, entry, prevOutput, prevStep, stepResults, serializedStepGraph, resume, executionContext, emitter, abortController, runtimeContext, writableStream, disableScorers, tracingContext, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'conditional';
            steps: StepFlowEntry[];
            conditions: ExecuteFunction<any, any, any, any, any, InngestEngineType>[];
        };
        prevStep: StepFlowEntry;
        serializedStepGraph: SerializedStepFlowEntry[];
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
        tracingContext?: TracingContext;
    }): Promise<StepResult<any, any, any, any>>;
}
export {};
//# sourceMappingURL=index.d.ts.map