'use strict';

var crypto = require('crypto');
var realtime = require('@inngest/realtime');
var aiTracing = require('@mastra/core/ai-tracing');
var di = require('@mastra/core/di');
var tools = require('@mastra/core/tools');
var workflows = require('@mastra/core/workflows');
var _constants = require('@mastra/core/workflows/_constants');
var inngest = require('inngest');
var hono = require('inngest/hono');
var zod = require('zod');

// src/index.ts
function serve({
  mastra,
  inngest,
  functions: userFunctions = [],
  registerOptions
}) {
  const wfs = mastra.getWorkflows();
  const workflowFunctions = Array.from(
    new Set(
      Object.values(wfs).flatMap((wf) => {
        if (wf instanceof InngestWorkflow) {
          wf.__registerMastra(mastra);
          return wf.getFunctions();
        }
        return [];
      })
    )
  );
  return hono.serve({
    ...registerOptions,
    client: inngest,
    functions: [...workflowFunctions, ...userFunctions]
  });
}
var InngestRun = class extends workflows.Run {
  inngest;
  serializedStepGraph;
  #mastra;
  constructor(params, inngest) {
    super(params);
    this.inngest = inngest;
    this.serializedStepGraph = params.serializedStepGraph;
    this.#mastra = params.mastra;
  }
  async getRuns(eventId) {
    const response = await fetch(`${this.inngest.apiBaseUrl ?? "https://api.inngest.com"}/v1/events/${eventId}/runs`, {
      headers: {
        Authorization: `Bearer ${process.env.INNGEST_SIGNING_KEY}`
      }
    });
    const json = await response.json();
    return json.data;
  }
  async getRunOutput(eventId) {
    let runs = await this.getRuns(eventId);
    while (runs?.[0]?.status !== "Completed" || runs?.[0]?.event_id !== eventId) {
      await new Promise((resolve) => setTimeout(resolve, 1e3));
      runs = await this.getRuns(eventId);
      if (runs?.[0]?.status === "Failed") {
        const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
          workflowName: this.workflowId,
          runId: this.runId
        });
        return {
          output: { result: { steps: snapshot?.context, status: "failed", error: runs?.[0]?.output?.message } }
        };
      }
      if (runs?.[0]?.status === "Cancelled") {
        const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
          workflowName: this.workflowId,
          runId: this.runId
        });
        return { output: { result: { steps: snapshot?.context, status: "canceled" } } };
      }
    }
    return runs?.[0];
  }
  async sendEvent(event, data) {
    await this.inngest.send({
      name: `user-event-${event}`,
      data
    });
  }
  async cancel() {
    await this.inngest.send({
      name: `cancel.workflow.${this.workflowId}`,
      data: {
        runId: this.runId
      }
    });
    const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId
    });
    if (snapshot) {
      await this.#mastra?.storage?.persistWorkflowSnapshot({
        workflowName: this.workflowId,
        runId: this.runId,
        resourceId: this.resourceId,
        snapshot: {
          ...snapshot,
          status: "canceled"
        }
      });
    }
  }
  async start({
    inputData,
    initialState
  }) {
    await this.#mastra.getStorage()?.persistWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId,
      resourceId: this.resourceId,
      snapshot: {
        runId: this.runId,
        serializedStepGraph: this.serializedStepGraph,
        value: {},
        context: {},
        activePaths: [],
        suspendedPaths: {},
        waitingPaths: {},
        timestamp: Date.now(),
        status: "running"
      }
    });
    const inputDataToUse = await this._validateInput(inputData);
    const initialStateToUse = await this._validateInitialState(initialState ?? {});
    const eventOutput = await this.inngest.send({
      name: `workflow.${this.workflowId}`,
      data: {
        inputData: inputDataToUse,
        initialState: initialStateToUse,
        runId: this.runId,
        resourceId: this.resourceId
      }
    });
    const eventId = eventOutput.ids[0];
    if (!eventId) {
      throw new Error("Event ID is not set");
    }
    const runOutput = await this.getRunOutput(eventId);
    const result = runOutput?.output?.result;
    if (result.status === "failed") {
      result.error = new Error(result.error);
    }
    if (result.status !== "suspended") {
      this.cleanup?.();
    }
    return result;
  }
  async resume(params) {
    const p = this._resume(params).then((result) => {
      if (result.status !== "suspended") {
        this.closeStreamAction?.().catch(() => {
        });
      }
      return result;
    });
    this.executionResults = p;
    return p;
  }
  async _resume(params) {
    const steps = (Array.isArray(params.step) ? params.step : [params.step]).map(
      (step) => typeof step === "string" ? step : step?.id
    );
    const snapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({
      workflowName: this.workflowId,
      runId: this.runId
    });
    const suspendedStep = this.workflowSteps[steps?.[0] ?? ""];
    const resumeDataToUse = await this._validateResumeData(params.resumeData, suspendedStep);
    const eventOutput = await this.inngest.send({
      name: `workflow.${this.workflowId}`,
      data: {
        inputData: resumeDataToUse,
        initialState: snapshot?.value ?? {},
        runId: this.runId,
        workflowId: this.workflowId,
        stepResults: snapshot?.context,
        resume: {
          steps,
          stepResults: snapshot?.context,
          resumePayload: resumeDataToUse,
          // @ts-ignore
          resumePath: snapshot?.suspendedPaths?.[steps?.[0]]
        }
      }
    });
    const eventId = eventOutput.ids[0];
    if (!eventId) {
      throw new Error("Event ID is not set");
    }
    const runOutput = await this.getRunOutput(eventId);
    const result = runOutput?.output?.result;
    if (result.status === "failed") {
      result.error = new Error(result.error);
    }
    return result;
  }
  watch(cb, type = "watch") {
    let active = true;
    const streamPromise = realtime.subscribe(
      {
        channel: `workflow:${this.workflowId}:${this.runId}`,
        topics: [type],
        app: this.inngest
      },
      (message) => {
        if (active) {
          cb(message.data);
        }
      }
    );
    return () => {
      active = false;
      streamPromise.then(async (stream) => {
        return stream.cancel();
      }).catch((err) => {
        console.error(err);
      });
    };
  }
  stream({ inputData, runtimeContext } = {}) {
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const unwatch = this.watch(async (event) => {
      try {
        const e = {
          ...event,
          type: event.type.replace("workflow-", "")
        };
        await writer.write(e);
      } catch {
      }
    }, "watch-v2");
    this.closeStreamAction = async () => {
      unwatch();
      try {
        await writer.close();
      } catch (err) {
        console.error("Error closing stream:", err);
      } finally {
        writer.releaseLock();
      }
    };
    this.executionResults = this.start({ inputData, runtimeContext }).then((result) => {
      if (result.status !== "suspended") {
        this.closeStreamAction?.().catch(() => {
        });
      }
      return result;
    });
    return {
      stream: readable,
      getWorkflowState: () => this.executionResults
    };
  }
};
var InngestWorkflow = class _InngestWorkflow extends workflows.Workflow {
  #mastra;
  inngest;
  function;
  flowControlConfig;
  constructor(params, inngest) {
    const { concurrency, rateLimit, throttle, debounce, priority, ...workflowParams } = params;
    super(workflowParams);
    const flowControlEntries = Object.entries({ concurrency, rateLimit, throttle, debounce, priority }).filter(
      ([_, value]) => value !== void 0
    );
    this.flowControlConfig = flowControlEntries.length > 0 ? Object.fromEntries(flowControlEntries) : void 0;
    this.#mastra = params.mastra;
    this.inngest = inngest;
  }
  async getWorkflowRuns(args) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return { runs: [], total: 0 };
    }
    return storage.getWorkflowRuns({ workflowName: this.id, ...args ?? {} });
  }
  async getWorkflowRunById(runId) {
    const storage = this.#mastra?.getStorage();
    if (!storage) {
      this.logger.debug("Cannot get workflow runs. Mastra engine is not initialized");
      return this.runs.get(runId) ? { ...this.runs.get(runId), workflowName: this.id } : null;
    }
    const run = await storage.getWorkflowRunById({ runId, workflowName: this.id });
    return run ?? (this.runs.get(runId) ? { ...this.runs.get(runId), workflowName: this.id } : null);
  }
  __registerMastra(mastra) {
    this.#mastra = mastra;
    this.executionEngine.__registerMastra(mastra);
    const updateNested = (step) => {
      if ((step.type === "step" || step.type === "loop" || step.type === "foreach") && step.step instanceof _InngestWorkflow) {
        step.step.__registerMastra(mastra);
      } else if (step.type === "parallel" || step.type === "conditional") {
        for (const subStep of step.steps) {
          updateNested(subStep);
        }
      }
    };
    if (this.executionGraph.steps.length) {
      for (const step of this.executionGraph.steps) {
        updateNested(step);
      }
    }
  }
  /**
   * @deprecated Use createRunAsync() instead.
   * @throws {Error} Always throws an error directing users to use createRunAsync()
   */
  createRun(_options) {
    throw new Error(
      "createRun() has been deprecated. Please use createRunAsync() instead.\n\nMigration guide:\n  Before: const run = workflow.createRun();\n  After:  const run = await workflow.createRunAsync();\n\nNote: createRunAsync() is an async method, so make sure your calling function is async."
    );
  }
  async createRunAsync(options) {
    const runIdToUse = options?.runId || crypto.randomUUID();
    const run = this.runs.get(runIdToUse) ?? new InngestRun(
      {
        workflowId: this.id,
        runId: runIdToUse,
        resourceId: options?.resourceId,
        executionEngine: this.executionEngine,
        executionGraph: this.executionGraph,
        serializedStepGraph: this.serializedStepGraph,
        mastra: this.#mastra,
        retryConfig: this.retryConfig,
        cleanup: () => this.runs.delete(runIdToUse),
        workflowSteps: this.steps
      },
      this.inngest
    );
    this.runs.set(runIdToUse, run);
    const shouldPersistSnapshot = this.options.shouldPersistSnapshot({
      workflowStatus: run.workflowRunStatus,
      stepResults: {}
    });
    const workflowSnapshotInStorage = await this.getWorkflowRunExecutionResult(runIdToUse, false);
    if (!workflowSnapshotInStorage && shouldPersistSnapshot) {
      await this.mastra?.getStorage()?.persistWorkflowSnapshot({
        workflowName: this.id,
        runId: runIdToUse,
        resourceId: options?.resourceId,
        snapshot: {
          runId: runIdToUse,
          status: "pending",
          value: {},
          context: {},
          activePaths: [],
          waitingPaths: {},
          serializedStepGraph: this.serializedStepGraph,
          suspendedPaths: {},
          result: void 0,
          error: void 0,
          // @ts-ignore
          timestamp: Date.now()
        }
      });
    }
    return run;
  }
  getFunction() {
    if (this.function) {
      return this.function;
    }
    this.function = this.inngest.createFunction(
      {
        id: `workflow.${this.id}`,
        // @ts-ignore
        retries: this.retryConfig?.attempts ?? 0,
        cancelOn: [{ event: `cancel.workflow.${this.id}` }],
        // Spread flow control configuration
        ...this.flowControlConfig
      },
      { event: `workflow.${this.id}` },
      async ({ event, step, attempt, publish }) => {
        let { inputData, initialState, runId, resourceId, resume, outputOptions } = event.data;
        if (!runId) {
          runId = await step.run(`workflow.${this.id}.runIdGen`, async () => {
            return crypto.randomUUID();
          });
        }
        const emitter = {
          emit: async (event2, data) => {
            if (!publish) {
              return;
            }
            try {
              await publish({
                channel: `workflow:${this.id}:${runId}`,
                topic: event2,
                data
              });
            } catch (err) {
              this.logger.error("Error emitting event: " + (err?.stack ?? err?.message ?? err));
            }
          },
          on: (_event, _callback) => {
          },
          off: (_event, _callback) => {
          },
          once: (_event, _callback) => {
          }
        };
        const engine = new InngestExecutionEngine(this.#mastra, step, attempt, this.options);
        const result = await engine.execute({
          workflowId: this.id,
          runId,
          resourceId,
          graph: this.executionGraph,
          serializedStepGraph: this.serializedStepGraph,
          input: inputData,
          initialState,
          emitter,
          retryConfig: this.retryConfig,
          runtimeContext: new di.RuntimeContext(),
          // TODO
          resume,
          abortController: new AbortController(),
          currentSpan: void 0,
          // TODO: Pass actual parent AI span from workflow execution context
          outputOptions
        });
        await step.run(`workflow.${this.id}.finalize`, async () => {
          if (result.status === "failed") {
            throw new inngest.NonRetriableError(`Workflow failed`, {
              cause: result
            });
          }
          return result;
        });
        return { result, runId };
      }
    );
    return this.function;
  }
  getNestedFunctions(steps) {
    return steps.flatMap((step) => {
      if (step.type === "step" || step.type === "loop" || step.type === "foreach") {
        if (step.step instanceof _InngestWorkflow) {
          return [step.step.getFunction(), ...step.step.getNestedFunctions(step.step.executionGraph.steps)];
        }
        return [];
      } else if (step.type === "parallel" || step.type === "conditional") {
        return this.getNestedFunctions(step.steps);
      }
      return [];
    });
  }
  getFunctions() {
    return [this.getFunction(), ...this.getNestedFunctions(this.executionGraph.steps)];
  }
};
function isAgent(params) {
  return params?.component === "AGENT";
}
function isTool(params) {
  return params instanceof tools.Tool;
}
function createStep(params) {
  if (isAgent(params)) {
    return {
      id: params.name,
      description: params.getDescription(),
      // @ts-ignore
      inputSchema: zod.z.object({
        prompt: zod.z.string()
      }),
      // @ts-ignore
      outputSchema: zod.z.object({
        text: zod.z.string()
      }),
      execute: async ({ inputData, [_constants.EMITTER_SYMBOL]: emitter, runtimeContext, abortSignal, abort, tracingContext }) => {
        let streamPromise = {};
        streamPromise.promise = new Promise((resolve, reject) => {
          streamPromise.resolve = resolve;
          streamPromise.reject = reject;
        });
        const toolData = {
          name: params.name,
          args: inputData
        };
        if ((await params.getLLM()).getModel().specificationVersion === `v2`) {
          const { fullStream } = await params.stream(inputData.prompt, {
            runtimeContext,
            tracingContext,
            onFinish: (result) => {
              streamPromise.resolve(result.text);
            },
            abortSignal
          });
          if (abortSignal.aborted) {
            return abort();
          }
          await emitter.emit("watch-v2", {
            type: "tool-call-streaming-start",
            ...toolData ?? {}
          });
          for await (const chunk of fullStream) {
            if (chunk.type === "text-delta") {
              await emitter.emit("watch-v2", {
                type: "tool-call-delta",
                ...toolData ?? {},
                argsTextDelta: chunk.payload.text
              });
            }
          }
        } else {
          const { fullStream } = await params.streamLegacy(inputData.prompt, {
            runtimeContext,
            tracingContext,
            onFinish: (result) => {
              streamPromise.resolve(result.text);
            },
            abortSignal
          });
          if (abortSignal.aborted) {
            return abort();
          }
          await emitter.emit("watch-v2", {
            type: "tool-call-streaming-start",
            ...toolData ?? {}
          });
          for await (const chunk of fullStream) {
            if (chunk.type === "text-delta") {
              await emitter.emit("watch-v2", {
                type: "tool-call-delta",
                ...toolData ?? {},
                argsTextDelta: chunk.textDelta
              });
            }
          }
        }
        await emitter.emit("watch-v2", {
          type: "tool-call-streaming-finish",
          ...toolData ?? {}
        });
        return {
          text: await streamPromise.promise
        };
      },
      component: params.component
    };
  }
  if (isTool(params)) {
    if (!params.inputSchema || !params.outputSchema) {
      throw new Error("Tool must have input and output schemas defined");
    }
    return {
      // TODO: tool probably should have strong id type
      // @ts-ignore
      id: params.id,
      description: params.description,
      inputSchema: params.inputSchema,
      outputSchema: params.outputSchema,
      execute: async ({ inputData, mastra, runtimeContext, tracingContext, suspend, resumeData }) => {
        return params.execute({
          context: inputData,
          mastra: aiTracing.wrapMastra(mastra, tracingContext),
          runtimeContext,
          tracingContext,
          suspend,
          resumeData
        });
      },
      component: "TOOL"
    };
  }
  return {
    id: params.id,
    description: params.description,
    inputSchema: params.inputSchema,
    outputSchema: params.outputSchema,
    resumeSchema: params.resumeSchema,
    suspendSchema: params.suspendSchema,
    execute: params.execute
  };
}
function init(inngest) {
  return {
    createWorkflow(params) {
      return new InngestWorkflow(
        params,
        inngest
      );
    },
    createStep,
    cloneStep(step, opts) {
      return {
        id: opts.id,
        description: step.description,
        inputSchema: step.inputSchema,
        outputSchema: step.outputSchema,
        resumeSchema: step.resumeSchema,
        suspendSchema: step.suspendSchema,
        stateSchema: step.stateSchema,
        execute: step.execute,
        component: step.component
      };
    },
    cloneWorkflow(workflow, opts) {
      const wf = new workflows.Workflow({
        id: opts.id,
        inputSchema: workflow.inputSchema,
        outputSchema: workflow.outputSchema,
        steps: workflow.stepDefs,
        mastra: workflow.mastra
      });
      wf.setStepFlow(workflow.stepGraph);
      wf.commit();
      return wf;
    }
  };
}
var InngestExecutionEngine = class extends workflows.DefaultExecutionEngine {
  inngestStep;
  inngestAttempts;
  constructor(mastra, inngestStep, inngestAttempts = 0, options) {
    super({ mastra, options });
    this.inngestStep = inngestStep;
    this.inngestAttempts = inngestAttempts;
  }
  async execute(params) {
    await params.emitter.emit("watch-v2", {
      type: "workflow-start",
      payload: { runId: params.runId }
    });
    const result = await super.execute(params);
    await params.emitter.emit("watch-v2", {
      type: "workflow-finish",
      payload: { runId: params.runId }
    });
    return result;
  }
  async fmtReturnValue(executionSpan, emitter, stepResults, lastOutput, error) {
    const base = {
      status: lastOutput.status,
      steps: stepResults
    };
    if (lastOutput.status === "success") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: lastOutput.output
          }
        },
        eventTimestamp: Date.now()
      });
      base.result = lastOutput.output;
    } else if (lastOutput.status === "failed") {
      base.error = error instanceof Error ? error?.stack ?? error.message : lastOutput?.error instanceof Error ? lastOutput.error.message : lastOutput.error ?? error ?? "Unknown error";
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: base.error
          }
        },
        eventTimestamp: Date.now()
      });
    } else if (lastOutput.status === "suspended") {
      await emitter.emit("watch", {
        type: "watch",
        payload: {
          workflowState: {
            status: lastOutput.status,
            steps: stepResults,
            result: null,
            error: null
          }
        },
        eventTimestamp: Date.now()
      });
      const suspendedStepIds = Object.entries(stepResults).flatMap(([stepId, stepResult]) => {
        if (stepResult?.status === "suspended") {
          const nestedPath = stepResult?.suspendPayload?.__workflow_meta?.path;
          return nestedPath ? [[stepId, ...nestedPath]] : [[stepId]];
        }
        return [];
      });
      base.suspended = suspendedStepIds;
    }
    executionSpan?.end();
    return base;
  }
  // async executeSleep({ id, duration }: { id: string; duration: number }): Promise<void> {
  //   await this.inngestStep.sleep(id, duration);
  // }
  async executeSleep({
    workflowId,
    runId,
    entry,
    prevOutput,
    stepResults,
    emitter,
    abortController,
    runtimeContext,
    executionContext,
    writableStream,
    tracingContext
  }) {
    let { duration, fn } = entry;
    const sleepSpan = tracingContext?.currentSpan?.createChildSpan({
      type: aiTracing.AISpanType.WORKFLOW_SLEEP,
      name: `sleep: ${duration ? `${duration}ms` : "dynamic"}`,
      attributes: {
        durationMs: duration,
        sleepType: fn ? "dynamic" : "fixed"
      },
      tracingPolicy: this.options?.tracingPolicy
    });
    if (fn) {
      const stepCallId = crypto.randomUUID();
      duration = await this.inngestStep.run(`workflow.${workflowId}.sleep.${entry.id}`, async () => {
        return await fn({
          runId,
          workflowId,
          mastra: this.mastra,
          runtimeContext,
          inputData: prevOutput,
          state: executionContext.state,
          setState: (state) => {
            executionContext.state = state;
          },
          runCount: -1,
          tracingContext: {
            currentSpan: sleepSpan
          },
          getInitData: () => stepResults?.input,
          getStepResult: workflows.getStepResult.bind(this, stepResults),
          // TODO: this function shouldn't have suspend probably?
          suspend: async (_suspendPayload) => {
          },
          bail: () => {
          },
          abort: () => {
            abortController?.abort();
          },
          [_constants.EMITTER_SYMBOL]: emitter,
          // TODO: add streamVNext support
          [_constants.STREAM_FORMAT_SYMBOL]: executionContext.format,
          engine: { step: this.inngestStep },
          abortSignal: abortController?.signal,
          writer: new tools.ToolStream(
            {
              prefix: "workflow-step",
              callId: stepCallId,
              name: "sleep",
              runId
            },
            writableStream
          )
        });
      });
      sleepSpan?.update({
        attributes: {
          durationMs: duration
        }
      });
    }
    try {
      await this.inngestStep.sleep(entry.id, !duration || duration < 0 ? 0 : duration);
      sleepSpan?.end();
    } catch (e) {
      sleepSpan?.error({ error: e });
      throw e;
    }
  }
  async executeSleepUntil({
    workflowId,
    runId,
    entry,
    prevOutput,
    stepResults,
    emitter,
    abortController,
    runtimeContext,
    executionContext,
    writableStream,
    tracingContext
  }) {
    let { date, fn } = entry;
    const sleepUntilSpan = tracingContext?.currentSpan?.createChildSpan({
      type: aiTracing.AISpanType.WORKFLOW_SLEEP,
      name: `sleepUntil: ${date ? date.toISOString() : "dynamic"}`,
      attributes: {
        untilDate: date,
        durationMs: date ? Math.max(0, date.getTime() - Date.now()) : void 0,
        sleepType: fn ? "dynamic" : "fixed"
      },
      tracingPolicy: this.options?.tracingPolicy
    });
    if (fn) {
      date = await this.inngestStep.run(`workflow.${workflowId}.sleepUntil.${entry.id}`, async () => {
        const stepCallId = crypto.randomUUID();
        return await fn({
          runId,
          workflowId,
          mastra: this.mastra,
          runtimeContext,
          inputData: prevOutput,
          state: executionContext.state,
          setState: (state) => {
            executionContext.state = state;
          },
          runCount: -1,
          tracingContext: {
            currentSpan: sleepUntilSpan
          },
          getInitData: () => stepResults?.input,
          getStepResult: workflows.getStepResult.bind(this, stepResults),
          // TODO: this function shouldn't have suspend probably?
          suspend: async (_suspendPayload) => {
          },
          bail: () => {
          },
          abort: () => {
            abortController?.abort();
          },
          [_constants.EMITTER_SYMBOL]: emitter,
          [_constants.STREAM_FORMAT_SYMBOL]: executionContext.format,
          // TODO: add streamVNext support
          engine: { step: this.inngestStep },
          abortSignal: abortController?.signal,
          writer: new tools.ToolStream(
            {
              prefix: "workflow-step",
              callId: stepCallId,
              name: "sleep",
              runId
            },
            writableStream
          )
        });
      });
      if (date && !(date instanceof Date)) {
        date = new Date(date);
      }
      const time = !date ? 0 : date.getTime() - Date.now();
      sleepUntilSpan?.update({
        attributes: {
          durationMs: Math.max(0, time)
        }
      });
    }
    if (!(date instanceof Date)) {
      sleepUntilSpan?.end();
      return;
    }
    try {
      await this.inngestStep.sleepUntil(entry.id, date);
      sleepUntilSpan?.end();
    } catch (e) {
      sleepUntilSpan?.error({ error: e });
      throw e;
    }
  }
  async executeWaitForEvent({ event, timeout }) {
    const eventData = await this.inngestStep.waitForEvent(`user-event-${event}`, {
      event: `user-event-${event}`,
      timeout: timeout ?? 5e3
    });
    if (eventData === null) {
      throw "Timeout waiting for event";
    }
    return eventData?.data;
  }
  async executeStep({
    step,
    stepResults,
    executionContext,
    resume,
    prevOutput,
    emitter,
    abortController,
    runtimeContext,
    tracingContext,
    writableStream,
    disableScorers
  }) {
    const stepAISpan = tracingContext?.currentSpan?.createChildSpan({
      name: `workflow step: '${step.id}'`,
      type: aiTracing.AISpanType.WORKFLOW_STEP,
      input: prevOutput,
      attributes: {
        stepId: step.id
      },
      tracingPolicy: this.options?.tracingPolicy
    });
    const { inputData, validationError } = await workflows.validateStepInput({
      prevOutput,
      step,
      validateInputs: this.options?.validateInputs ?? false
    });
    const startedAt = await this.inngestStep.run(
      `workflow.${executionContext.workflowId}.run.${executionContext.runId}.step.${step.id}.running_ev`,
      async () => {
        const startedAt2 = Date.now();
        await emitter.emit("watch", {
          type: "watch",
          payload: {
            currentStep: {
              id: step.id,
              status: "running"
            },
            workflowState: {
              status: "running",
              steps: {
                ...stepResults,
                [step.id]: {
                  status: "running"
                }
              },
              result: null,
              error: null
            }
          },
          eventTimestamp: Date.now()
        });
        await emitter.emit("watch-v2", {
          type: "workflow-step-start",
          payload: {
            id: step.id,
            status: "running",
            payload: inputData,
            startedAt: startedAt2
          }
        });
        return startedAt2;
      }
    );
    if (step instanceof InngestWorkflow) {
      const isResume = !!resume?.steps?.length;
      let result;
      let runId;
      try {
        if (isResume) {
          runId = stepResults[resume?.steps?.[0]]?.suspendPayload?.__workflow_meta?.runId ?? crypto.randomUUID();
          const snapshot = await this.mastra?.getStorage()?.loadWorkflowSnapshot({
            workflowName: step.id,
            runId
          });
          const invokeResp = await this.inngestStep.invoke(`workflow.${executionContext.workflowId}.step.${step.id}`, {
            function: step.getFunction(),
            data: {
              inputData,
              initialState: executionContext.state ?? snapshot?.value ?? {},
              runId,
              resume: {
                runId,
                steps: resume.steps.slice(1),
                stepResults: snapshot?.context,
                resumePayload: resume.resumePayload,
                // @ts-ignore
                resumePath: snapshot?.suspendedPaths?.[resume.steps?.[1]]
              },
              outputOptions: { includeState: true }
            }
          });
          result = invokeResp.result;
          runId = invokeResp.runId;
          executionContext.state = invokeResp.result.state;
        } else {
          const invokeResp = await this.inngestStep.invoke(`workflow.${executionContext.workflowId}.step.${step.id}`, {
            function: step.getFunction(),
            data: {
              inputData,
              initialState: executionContext.state ?? {},
              outputOptions: { includeState: true }
            }
          });
          result = invokeResp.result;
          runId = invokeResp.runId;
          executionContext.state = invokeResp.result.state;
        }
      } catch (e) {
        const errorCause = e?.cause;
        if (errorCause && typeof errorCause === "object") {
          result = errorCause;
          runId = errorCause.runId || crypto.randomUUID();
        } else {
          runId = crypto.randomUUID();
          result = {
            status: "failed",
            error: e instanceof Error ? e : new Error(String(e)),
            steps: {},
            input: inputData
          };
        }
      }
      const res = await this.inngestStep.run(
        `workflow.${executionContext.workflowId}.step.${step.id}.nestedwf-results`,
        async () => {
          if (result.status === "failed") {
            await emitter.emit("watch", {
              type: "watch",
              payload: {
                currentStep: {
                  id: step.id,
                  status: "failed",
                  error: result?.error
                },
                workflowState: {
                  status: "running",
                  steps: stepResults,
                  result: null,
                  error: null
                }
              },
              eventTimestamp: Date.now()
            });
            await emitter.emit("watch-v2", {
              type: "workflow-step-result",
              payload: {
                id: step.id,
                status: "failed",
                error: result?.error,
                payload: prevOutput
              }
            });
            return { executionContext, result: { status: "failed", error: result?.error } };
          } else if (result.status === "suspended") {
            const suspendedSteps = Object.entries(result.steps).filter(([_stepName, stepResult]) => {
              const stepRes2 = stepResult;
              return stepRes2?.status === "suspended";
            });
            for (const [stepName, stepResult] of suspendedSteps) {
              const suspendPath = [stepName, ...stepResult?.suspendPayload?.__workflow_meta?.path ?? []];
              executionContext.suspendedPaths[step.id] = executionContext.executionPath;
              await emitter.emit("watch", {
                type: "watch",
                payload: {
                  currentStep: {
                    id: step.id,
                    status: "suspended",
                    payload: stepResult.payload,
                    suspendPayload: {
                      ...stepResult?.suspendPayload,
                      __workflow_meta: { runId, path: suspendPath }
                    }
                  },
                  workflowState: {
                    status: "running",
                    steps: stepResults,
                    result: null,
                    error: null
                  }
                },
                eventTimestamp: Date.now()
              });
              await emitter.emit("watch-v2", {
                type: "workflow-step-suspended",
                payload: {
                  id: step.id,
                  status: "suspended"
                }
              });
              return {
                executionContext,
                result: {
                  status: "suspended",
                  payload: stepResult.payload,
                  suspendPayload: {
                    ...stepResult?.suspendPayload,
                    __workflow_meta: { runId, path: suspendPath }
                  }
                }
              };
            }
            await emitter.emit("watch", {
              type: "watch",
              payload: {
                currentStep: {
                  id: step.id,
                  status: "suspended",
                  payload: {}
                },
                workflowState: {
                  status: "running",
                  steps: stepResults,
                  result: null,
                  error: null
                }
              },
              eventTimestamp: Date.now()
            });
            return {
              executionContext,
              result: {
                status: "suspended",
                payload: {}
              }
            };
          }
          await emitter.emit("watch", {
            type: "watch",
            payload: {
              currentStep: {
                id: step.id,
                status: "success",
                output: result?.result
              },
              workflowState: {
                status: "running",
                steps: stepResults,
                result: null,
                error: null
              }
            },
            eventTimestamp: Date.now()
          });
          await emitter.emit("watch-v2", {
            type: "workflow-step-result",
            payload: {
              id: step.id,
              status: "success",
              output: result?.result
            }
          });
          await emitter.emit("watch-v2", {
            type: "workflow-step-finish",
            payload: {
              id: step.id,
              metadata: {}
            }
          });
          return { executionContext, result: { status: "success", output: result?.result } };
        }
      );
      Object.assign(executionContext, res.executionContext);
      return {
        ...res.result,
        startedAt,
        endedAt: Date.now(),
        payload: inputData,
        resumedAt: resume?.steps[0] === step.id ? startedAt : void 0,
        resumePayload: resume?.steps[0] === step.id ? resume?.resumePayload : void 0
      };
    }
    let stepRes;
    try {
      stepRes = await this.inngestStep.run(`workflow.${executionContext.workflowId}.step.${step.id}`, async () => {
        let execResults;
        let suspended;
        let bailed;
        try {
          if (validationError) {
            throw validationError;
          }
          const result = await step.execute({
            runId: executionContext.runId,
            mastra: this.mastra,
            runtimeContext,
            writableStream,
            state: executionContext?.state ?? {},
            setState: (state) => {
              executionContext.state = state;
            },
            inputData,
            resumeData: resume?.steps[0] === step.id ? resume?.resumePayload : void 0,
            tracingContext: {
              currentSpan: stepAISpan
            },
            getInitData: () => stepResults?.input,
            getStepResult: workflows.getStepResult.bind(this, stepResults),
            suspend: async (suspendPayload) => {
              executionContext.suspendedPaths[step.id] = executionContext.executionPath;
              suspended = { payload: suspendPayload };
            },
            bail: (result2) => {
              bailed = { payload: result2 };
            },
            resume: {
              steps: resume?.steps?.slice(1) || [],
              resumePayload: resume?.resumePayload,
              // @ts-ignore
              runId: stepResults[step.id]?.suspendPayload?.__workflow_meta?.runId
            },
            [_constants.EMITTER_SYMBOL]: emitter,
            engine: {
              step: this.inngestStep
            },
            abortSignal: abortController.signal
          });
          const endedAt = Date.now();
          execResults = {
            status: "success",
            output: result,
            startedAt,
            endedAt,
            payload: inputData,
            resumedAt: resume?.steps[0] === step.id ? startedAt : void 0,
            resumePayload: resume?.steps[0] === step.id ? resume?.resumePayload : void 0
          };
        } catch (e) {
          const stepFailure = {
            status: "failed",
            payload: inputData,
            error: e instanceof Error ? e.message : String(e),
            endedAt: Date.now(),
            startedAt,
            resumedAt: resume?.steps[0] === step.id ? startedAt : void 0,
            resumePayload: resume?.steps[0] === step.id ? resume?.resumePayload : void 0
          };
          execResults = stepFailure;
          const fallbackErrorMessage = `Step ${step.id} failed`;
          stepAISpan?.error({ error: new Error(execResults.error ?? fallbackErrorMessage) });
          throw new inngest.RetryAfterError(execResults.error ?? fallbackErrorMessage, executionContext.retryConfig.delay, {
            cause: execResults
          });
        }
        if (suspended) {
          execResults = {
            status: "suspended",
            suspendPayload: suspended.payload,
            payload: inputData,
            suspendedAt: Date.now(),
            startedAt,
            resumedAt: resume?.steps[0] === step.id ? startedAt : void 0,
            resumePayload: resume?.steps[0] === step.id ? resume?.resumePayload : void 0
          };
        } else if (bailed) {
          execResults = {
            status: "bailed",
            output: bailed.payload,
            payload: inputData,
            endedAt: Date.now(),
            startedAt
          };
        }
        await emitter.emit("watch", {
          type: "watch",
          payload: {
            currentStep: {
              id: step.id,
              ...execResults
            },
            workflowState: {
              status: "running",
              steps: { ...stepResults, [step.id]: execResults },
              result: null,
              error: null
            }
          },
          eventTimestamp: Date.now()
        });
        if (execResults.status === "suspended") {
          await emitter.emit("watch-v2", {
            type: "workflow-step-suspended",
            payload: {
              id: step.id,
              ...execResults
            }
          });
        } else {
          await emitter.emit("watch-v2", {
            type: "workflow-step-result",
            payload: {
              id: step.id,
              ...execResults
            }
          });
          await emitter.emit("watch-v2", {
            type: "workflow-step-finish",
            payload: {
              id: step.id,
              metadata: {}
            }
          });
        }
        stepAISpan?.end({ output: execResults });
        return { result: execResults, executionContext, stepResults };
      });
    } catch (e) {
      const stepFailure = e instanceof Error ? e?.cause : {
        status: "failed",
        error: e instanceof Error ? e.message : String(e),
        payload: inputData,
        startedAt,
        endedAt: Date.now()
      };
      stepRes = {
        result: stepFailure,
        executionContext,
        stepResults: {
          ...stepResults,
          [step.id]: stepFailure
        }
      };
    }
    if (disableScorers !== false && stepRes.result.status === "success") {
      await this.inngestStep.run(`workflow.${executionContext.workflowId}.step.${step.id}.score`, async () => {
        if (step.scorers) {
          await this.runScorers({
            scorers: step.scorers,
            runId: executionContext.runId,
            input: inputData,
            output: stepRes.result,
            workflowId: executionContext.workflowId,
            stepId: step.id,
            runtimeContext,
            disableScorers,
            tracingContext: { currentSpan: stepAISpan }
          });
        }
      });
    }
    Object.assign(executionContext.suspendedPaths, stepRes.executionContext.suspendedPaths);
    Object.assign(stepResults, stepRes.stepResults);
    executionContext.state = stepRes.executionContext.state;
    return stepRes.result;
  }
  async persistStepUpdate({
    workflowId,
    runId,
    stepResults,
    resourceId,
    executionContext,
    serializedStepGraph,
    workflowStatus,
    result,
    error
  }) {
    await this.inngestStep.run(
      `workflow.${workflowId}.run.${runId}.path.${JSON.stringify(executionContext.executionPath)}.stepUpdate`,
      async () => {
        const shouldPersistSnapshot = this.options.shouldPersistSnapshot({ stepResults, workflowStatus });
        if (!shouldPersistSnapshot) {
          return;
        }
        await this.mastra?.getStorage()?.persistWorkflowSnapshot({
          workflowName: workflowId,
          runId,
          resourceId,
          snapshot: {
            runId,
            value: executionContext.state,
            context: stepResults,
            activePaths: [],
            suspendedPaths: executionContext.suspendedPaths,
            waitingPaths: {},
            serializedStepGraph,
            status: workflowStatus,
            result,
            error,
            // @ts-ignore
            timestamp: Date.now()
          }
        });
      }
    );
  }
  async executeConditional({
    workflowId,
    runId,
    entry,
    prevOutput,
    prevStep,
    stepResults,
    serializedStepGraph,
    resume,
    executionContext,
    emitter,
    abortController,
    runtimeContext,
    writableStream,
    disableScorers,
    tracingContext
  }) {
    const conditionalSpan = tracingContext?.currentSpan?.createChildSpan({
      type: aiTracing.AISpanType.WORKFLOW_CONDITIONAL,
      name: `conditional: '${entry.conditions.length} conditions'`,
      input: prevOutput,
      attributes: {
        conditionCount: entry.conditions.length
      },
      tracingPolicy: this.options?.tracingPolicy
    });
    let execResults;
    const truthyIndexes = (await Promise.all(
      entry.conditions.map(
        (cond, index) => this.inngestStep.run(`workflow.${workflowId}.conditional.${index}`, async () => {
          const evalSpan = conditionalSpan?.createChildSpan({
            type: aiTracing.AISpanType.WORKFLOW_CONDITIONAL_EVAL,
            name: `condition: '${index}'`,
            input: prevOutput,
            attributes: {
              conditionIndex: index
            },
            tracingPolicy: this.options?.tracingPolicy
          });
          try {
            const result = await cond({
              runId,
              workflowId,
              mastra: this.mastra,
              runtimeContext,
              runCount: -1,
              inputData: prevOutput,
              state: executionContext.state,
              setState: (state) => {
                executionContext.state = state;
              },
              tracingContext: {
                currentSpan: evalSpan
              },
              getInitData: () => stepResults?.input,
              getStepResult: workflows.getStepResult.bind(this, stepResults),
              // TODO: this function shouldn't have suspend probably?
              suspend: async (_suspendPayload) => {
              },
              bail: () => {
              },
              abort: () => {
                abortController.abort();
              },
              [_constants.EMITTER_SYMBOL]: emitter,
              [_constants.STREAM_FORMAT_SYMBOL]: executionContext.format,
              // TODO: add streamVNext support
              engine: {
                step: this.inngestStep
              },
              abortSignal: abortController.signal,
              writer: new tools.ToolStream(
                {
                  prefix: "workflow-step",
                  callId: crypto.randomUUID(),
                  name: "conditional",
                  runId
                },
                writableStream
              )
            });
            evalSpan?.end({
              output: result,
              attributes: {
                result: !!result
              }
            });
            return result ? index : null;
          } catch (e) {
            evalSpan?.error({
              error: e instanceof Error ? e : new Error(String(e)),
              attributes: {
                result: false
              }
            });
            return null;
          }
        })
      )
    )).filter((index) => index !== null);
    const stepsToRun = entry.steps.filter((_, index) => truthyIndexes.includes(index));
    conditionalSpan?.update({
      attributes: {
        truthyIndexes,
        selectedSteps: stepsToRun.map((s) => s.type === "step" ? s.step.id : `control-${s.type}`)
      }
    });
    const results = await Promise.all(
      stepsToRun.map(
        (step, index) => this.executeEntry({
          workflowId,
          runId,
          entry: step,
          serializedStepGraph,
          prevStep,
          stepResults,
          resume,
          executionContext: {
            workflowId,
            runId,
            executionPath: [...executionContext.executionPath, index],
            suspendedPaths: executionContext.suspendedPaths,
            retryConfig: executionContext.retryConfig,
            executionSpan: executionContext.executionSpan,
            state: executionContext.state
          },
          emitter,
          abortController,
          runtimeContext,
          writableStream,
          disableScorers,
          tracingContext: {
            currentSpan: conditionalSpan
          }
        })
      )
    );
    const hasFailed = results.find((result) => result.result.status === "failed");
    const hasSuspended = results.find((result) => result.result.status === "suspended");
    if (hasFailed) {
      execResults = { status: "failed", error: hasFailed.result.error };
    } else if (hasSuspended) {
      execResults = { status: "suspended", suspendPayload: hasSuspended.result.suspendPayload };
    } else {
      execResults = {
        status: "success",
        output: results.reduce((acc, result, index) => {
          if (result.result.status === "success") {
            acc[stepsToRun[index].step.id] = result.output;
          }
          return acc;
        }, {})
      };
    }
    if (execResults.status === "failed") {
      conditionalSpan?.error({
        error: new Error(execResults.error)
      });
    } else {
      conditionalSpan?.end({
        output: execResults.output || execResults
      });
    }
    return execResults;
  }
};

exports.InngestExecutionEngine = InngestExecutionEngine;
exports.InngestRun = InngestRun;
exports.InngestWorkflow = InngestWorkflow;
exports.createStep = createStep;
exports.init = init;
exports.serve = serve;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map