import type { Span } from '@opentelemetry/api';
import type { AISpan, TracingContext } from '../ai-tracing/index.js';
import { AISpanType } from '../ai-tracing/index.js';
import type { RuntimeContext } from '../di/index.js';
import { MastraError, ErrorDomain, ErrorCategory } from '../error/index.js';
import type { IErrorDefinition } from '../error/index.js';
import type { MastraScorers } from '../scores/index.js';
import type { ChunkType } from '../stream/types.js';
import type { DynamicArgument } from '../types/index.js';
import type { ExecutionGraph } from './execution-engine.js';
import { ExecutionEngine } from './execution-engine.js';
import type { ConditionFunction, ExecuteFunction, LoopConditionFunction, Step } from './step.js';
import type { DefaultEngineType, Emitter, SerializedStepFlowEntry, StepFlowEntry, StepResult } from './types.js';
export type ExecutionContext = {
    workflowId: string;
    runId: string;
    executionPath: number[];
    suspendedPaths: Record<string, number[]>;
    waitingPaths?: Record<string, number[]>;
    retryConfig: {
        attempts: number;
        delay: number;
    };
    executionSpan: Span;
    format?: 'aisdk' | 'mastra' | undefined;
    state: Record<string, any>;
};
/**
 * Default implementation of the ExecutionEngine using XState
 */
export declare class DefaultExecutionEngine extends ExecutionEngine {
    /**
     * Preprocesses an error caught during workflow execution.
     *
     * - Wraps a non-MastraError exception
     * - Logs error details
     */
    protected preprocessExecutionError(e: unknown, errorDefinition: IErrorDefinition<ErrorDomain, ErrorCategory>, logPrefix: string): MastraError;
    /**
     * The runCounts map is used to keep track of the run count for each step.
     * The step id is used as the key and the run count is the value.
     */
    protected runCounts: Map<string, number>;
    /**
     * Get or generate the run count for a step.
     * If the step id is not in the map, it will be added and the run count will be 0.
     * If the step id is in the map, it will return the run count.
     *
     * @param stepId - The id of the step.
     * @returns The run count for the step.
     */
    protected getOrGenerateRunCount(stepId: Step['id']): number;
    protected fmtReturnValue<TOutput>(executionSpan: Span | undefined, emitter: Emitter, stepResults: Record<string, StepResult<any, any, any, any>>, lastOutput: StepResult<any, any, any, any>, error?: Error | string): Promise<TOutput>;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    execute<TState, TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        disableScorers?: boolean;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        initialState?: TState;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: Emitter;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        runtimeContext: RuntimeContext;
        workflowAISpan?: AISpan<AISpanType.WORKFLOW_RUN>;
        abortController: AbortController;
        writableStream?: WritableStream<ChunkType>;
        format?: 'aisdk' | 'mastra' | undefined;
        outputOptions?: {
            includeState?: boolean;
        };
    }): Promise<TOutput>;
    getStepOutput(stepResults: Record<string, any>, step?: StepFlowEntry): any;
    executeSleep({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleep';
            id: string;
            duration?: number;
            fn?: ExecuteFunction<any, any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        tracingContext: TracingContext;
    }): Promise<void>;
    executeSleepUntil({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, executionContext, writableStream, tracingContext, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleepUntil';
            id: string;
            date?: Date;
            fn?: ExecuteFunction<any, any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        tracingContext: TracingContext;
    }): Promise<void>;
    executeWaitForEvent({ event, emitter, timeout, tracingContext, }: {
        event: string;
        emitter: Emitter;
        timeout?: number;
        tracingContext?: TracingContext;
    }): Promise<any>;
    executeStep({ workflowId, runId, resourceId, step, stepResults, executionContext, resume, prevOutput, emitter, abortController, runtimeContext, skipEmits, writableStream, disableScorers, serializedStepGraph, tracingContext, iterationCount, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        step: Step<string, any, any>;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        executionContext: ExecutionContext;
        resume?: {
            steps: string[];
            resumePayload: any;
        };
        prevOutput: any;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        skipEmits?: boolean;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
        serializedStepGraph: SerializedStepFlowEntry[];
        tracingContext: TracingContext;
        iterationCount?: number;
    }): Promise<StepResult<any, any, any, any>>;
    protected runScorers({ scorers, runId, input, output, workflowId, stepId, runtimeContext, disableScorers, tracingContext, }: {
        scorers: DynamicArgument<MastraScorers>;
        runId: string;
        input: any;
        output: any;
        runtimeContext: RuntimeContext;
        workflowId: string;
        stepId: string;
        disableScorers?: boolean;
        tracingContext: TracingContext;
    }): Promise<void>;
    executeParallel({ workflowId, runId, resourceId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        entry: {
            type: 'parallel';
            steps: StepFlowEntry[];
        };
        serializedStepGraph: SerializedStepFlowEntry[];
        prevStep: StepFlowEntry;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        tracingContext: TracingContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    executeConditional({ workflowId, runId, resourceId, entry, prevOutput, prevStep, serializedStepGraph, stepResults, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'conditional';
            steps: StepFlowEntry[];
            conditions: ConditionFunction<any, any, any, any, DefaultEngineType>[];
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        tracingContext: TracingContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    executeLoop({ workflowId, runId, resourceId, entry, prevOutput, stepResults, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        entry: {
            type: 'loop';
            step: Step;
            condition: LoopConditionFunction<any, any, any, any, DefaultEngineType>;
            loopType: 'dowhile' | 'dountil';
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        tracingContext: TracingContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
        serializedStepGraph: SerializedStepFlowEntry[];
    }): Promise<StepResult<any, any, any, any>>;
    executeForeach({ workflowId, runId, resourceId, entry, prevOutput, stepResults, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, serializedStepGraph, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        entry: {
            type: 'foreach';
            step: Step;
            opts: {
                concurrency: number;
            };
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        tracingContext: TracingContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
        serializedStepGraph: SerializedStepFlowEntry[];
    }): Promise<StepResult<any, any, any, any>>;
    protected persistStepUpdate({ workflowId, runId, resourceId, stepResults, serializedStepGraph, executionContext, workflowStatus, result, error, runtimeContext, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        serializedStepGraph: SerializedStepFlowEntry[];
        executionContext: ExecutionContext;
        workflowStatus: 'success' | 'failed' | 'suspended' | 'running' | 'waiting';
        result?: Record<string, any>;
        error?: string | Error;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeEntry({ workflowId, runId, resourceId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, tracingContext, emitter, abortController, runtimeContext, writableStream, disableScorers, }: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        entry: StepFlowEntry;
        prevStep: StepFlowEntry;
        serializedStepGraph: SerializedStepFlowEntry[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        tracingContext: TracingContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
        disableScorers?: boolean;
    }): Promise<{
        result: StepResult<any, any, any, any>;
        stepResults?: Record<string, StepResult<any, any, any, any>>;
        executionContext?: ExecutionContext;
    }>;
}
//# sourceMappingURL=default.d.ts.map