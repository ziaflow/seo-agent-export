{"version":3,"sources":["../../../src/scores/scoreTraces/scoreTraces.ts","../../../src/scores/scoreTraces/utils.ts","../../../src/scores/scoreTraces/scoreTracesWorkflow.ts"],"names":["MastraError","convertMessages","createStep","z","pMap","span","saveScorePayloadSchema","createWorkflow"],"mappings":"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","file":"index.cjs","sourcesContent":["import { MastraError } from '../../error';\nimport type { Mastra } from '../../mastra';\n\nexport async function scoreTraces({\n  scorerName,\n  targets,\n  mastra,\n}: {\n  scorerName: string;\n  targets: { traceId: string; spanId?: string }[];\n  mastra: Mastra;\n}) {\n  const workflow = mastra.__getInternalWorkflow('__batch-scoring-traces');\n  try {\n    const run = await workflow.createRunAsync();\n    await run.start({ inputData: { targets, scorerName } });\n  } catch (error) {\n    const mastraError = new MastraError(\n      {\n        category: 'SYSTEM',\n        domain: 'SCORER',\n        id: 'MASTRA_SCORER_FAILED_TO_RUN_TRACE_SCORING',\n        details: {\n          scorerName,\n          targets: JSON.stringify(targets),\n        },\n      },\n      error,\n    );\n    mastra.getLogger()?.trackException(mastraError);\n    mastra.getLogger()?.error(mastraError.toString());\n  }\n}\n","import type { ToolInvocation } from 'ai';\nimport type { UIMessageWithMetadata } from '../../agent';\nimport { convertMessages } from '../../agent/message-list/utils/convert-messages';\nimport { AISpanType } from '../../ai-tracing';\nimport type { AISpanRecord, AITraceRecord } from '../../storage';\nimport type { ScorerRunInputForAgent, ScorerRunOutputForAgent } from '../types';\n\n// // Span tree structure for efficient lookups\ninterface SpanTree {\n  spanMap: Map<string, AISpanRecord>;\n  childrenMap: Map<string, AISpanRecord[]>;\n  rootSpans: AISpanRecord[];\n}\n\n// Spans don't have ids, so we need to omit it from the UIMessageWithMetadata type\ntype TransformedUIMessage = Omit<UIMessageWithMetadata, 'id'>;\n\n/**\n * Build a hierarchical span tree with efficient lookup maps\n */\nexport function buildSpanTree(spans: AISpanRecord[]): SpanTree {\n  const spanMap = new Map<string, AISpanRecord>();\n  const childrenMap = new Map<string, AISpanRecord[]>();\n  const rootSpans: AISpanRecord[] = [];\n\n  // First pass: build span map\n  for (const span of spans) {\n    spanMap.set(span.spanId, span);\n  }\n\n  // Second pass: build parent-child relationships\n  for (const span of spans) {\n    if (span.parentSpanId === null) {\n      rootSpans.push(span);\n    } else {\n      const siblings = childrenMap.get(span.parentSpanId) || [];\n      siblings.push(span);\n      childrenMap.set(span.parentSpanId, siblings);\n    }\n  }\n\n  // Sort children by startedAt timestamp for temporal ordering\n  for (const children of childrenMap.values()) {\n    children.sort((a, b) => new Date(a.startedAt).getTime() - new Date(b.startedAt).getTime());\n  }\n\n  // Sort root spans by startedAt\n  rootSpans.sort((a, b) => new Date(a.startedAt).getTime() - new Date(b.startedAt).getTime());\n\n  return { spanMap, childrenMap, rootSpans };\n}\n\n/**\n * Extract children spans of a specific type\n */\nfunction getChildrenOfType<T extends AISpanRecord>(\n  spanTree: SpanTree,\n  parentSpanId: string,\n  spanType: AISpanType,\n): T[] {\n  const children = spanTree.childrenMap.get(parentSpanId) || [];\n  return children.filter(span => span.spanType === spanType) as T[];\n}\n\n/**\n * Convert AI SDK v5 message content to v4 format\n */\nfunction normalizeMessageContent(content: string | Array<{ type: string; text: string }>): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  const tempMessage = {\n    id: 'temp',\n    role: 'user' as const,\n    parts: content.map(part => ({ type: part.type as 'text', text: part.text })),\n  };\n\n  const converted = convertMessages(tempMessage).to('AIV4.UI');\n  return converted[0]?.content || '';\n}\n\n/**\n * Convert v5 message to v4 UIMessage format using convertMessages\n * Ensures full consistency with AI SDK UIMessage behavior\n */\nfunction convertToUIMessage(\n  message: { role: string; content: string | Array<{ type: string; text: string }> },\n  createdAt: Date,\n): UIMessageWithMetadata {\n  // Create proper message input for convertMessages\n  let messageInput;\n  if (typeof message.content === 'string') {\n    messageInput = {\n      id: 'temp',\n      role: message.role as 'user' | 'assistant' | 'system',\n      content: message.content,\n    };\n  } else {\n    messageInput = {\n      id: 'temp',\n      role: message.role as 'user' | 'assistant' | 'system',\n      parts: message.content.map(part => ({ type: part.type as 'text', text: part.text })),\n    };\n  }\n\n  const converted = convertMessages(messageInput).to('AIV4.UI');\n  const result = converted[0];\n\n  if (!result) {\n    throw new Error('Failed to convert message');\n  }\n\n  return {\n    ...result,\n    id: '', // Spans don't have message IDs\n    createdAt: new Date(createdAt), // Use span timestamp\n  };\n}\n\n/**\n * Extract input messages from agent run span\n */\nfunction extractInputMessages(agentSpan: AISpanRecord): TransformedUIMessage[] {\n  const input = agentSpan.input;\n\n  // Handle different input formats\n  if (typeof input === 'string') {\n    return [\n      {\n        role: 'user',\n        content: input,\n        createdAt: new Date(agentSpan.startedAt),\n        parts: [{ type: 'text', text: input }],\n        experimental_attachments: [],\n      },\n    ];\n  }\n\n  if (Array.isArray(input)) {\n    return input.map(msg => convertToUIMessage(msg, agentSpan.startedAt));\n  }\n\n  // @ts-ignore\n  if (input && typeof input === 'object' && Array.isArray(input.messages)) {\n    // @ts-ignore\n    return input.messages.map(msg => convertToUIMessage(msg, agentSpan.startedAt));\n  }\n  return [];\n}\n\n/**\n * Extract system messages from LLM span\n */\nfunction extractSystemMessages(llmSpan: AISpanRecord): Array<{ role: 'system'; content: string }> {\n  return (llmSpan.input?.messages || [])\n    .filter((msg: any) => msg.role === 'system')\n    .map((msg: any) => ({\n      role: 'system' as const,\n      content: normalizeMessageContent(msg.content),\n    }));\n}\n\n/**\n * Extract conversation history (remembered messages) from LLM span\n * Excludes system messages and the current input message\n */\nfunction extractRememberedMessages(llmSpan: AISpanRecord, currentInputContent: string): TransformedUIMessage[] {\n  const messages = (llmSpan.input?.messages || [])\n    .filter((msg: any) => msg.role !== 'system')\n    .filter((msg: any) => normalizeMessageContent(msg.content) !== currentInputContent);\n\n  return messages.map((msg: any) => convertToUIMessage(msg, llmSpan.startedAt));\n}\n\n/**\n * Reconstruct tool invocations from tool call spans\n */\nfunction reconstructToolInvocations(spanTree: SpanTree, parentSpanId: string) {\n  const toolSpans = getChildrenOfType<AISpanRecord>(spanTree, parentSpanId, AISpanType.TOOL_CALL);\n\n  return toolSpans.map(toolSpan => ({\n    state: 'result' as const,\n    toolName: toolSpan.attributes?.toolId,\n    args: toolSpan.input || {},\n    result: toolSpan.output || {},\n  }));\n}\n\n/**\n * Create message parts array including tool invocations and text\n */\nfunction createMessageParts(toolInvocations: AISpanRecord[], textContent: string) {\n  const parts: { type: 'tool-invocation' | 'text'; toolInvocation?: AISpanRecord; text?: string }[] = [];\n  for (const toolInvocation of toolInvocations) {\n    parts.push({\n      type: 'tool-invocation',\n      toolInvocation,\n    });\n  }\n\n  if (textContent.trim()) {\n    parts.push({\n      type: 'text',\n      text: textContent,\n    });\n  }\n\n  return parts;\n}\n\n/**\n * Validate trace structure and throw descriptive errors\n */\nexport function validateTrace(trace: AITraceRecord): void {\n  if (!trace) {\n    throw new Error('Trace is null or undefined');\n  }\n\n  if (!trace.spans || !Array.isArray(trace.spans)) {\n    throw new Error('Trace must have a spans array');\n  }\n\n  if (trace.spans.length === 0) {\n    throw new Error('Trace has no spans');\n  }\n\n  // Check for circular references in parent-child relationships\n  const spanIds = new Set(trace.spans.map(span => span.spanId));\n  for (const span of trace.spans) {\n    if (span.parentSpanId && !spanIds.has(span.parentSpanId)) {\n      throw new Error(`Span ${span.spanId} references non-existent parent ${span.parentSpanId}`);\n    }\n  }\n}\n\n/**\n * Find the most recent LLM span that contains conversation history\n */\nfunction findPrimaryLLMSpan(spanTree: SpanTree, rootAgentSpan: AISpanRecord): AISpanRecord {\n  const directLLMSpans = getChildrenOfType<AISpanRecord>(spanTree, rootAgentSpan.spanId, AISpanType.LLM_GENERATION);\n  if (directLLMSpans.length > 0) {\n    // There should only be one LLM generation span per agent run which is a direct child of the root agent span\n    return directLLMSpans[0]!;\n  }\n\n  throw new Error('No LLM generation span found in trace');\n}\n\n/**\n * Extract common trace validation and span tree building logic\n */\nfunction prepareTraceForTransformation(trace: AITraceRecord) {\n  validateTrace(trace);\n  const spanTree = buildSpanTree(trace.spans);\n\n  // Find the root agent run span\n  const rootAgentSpan = spanTree.rootSpans.find(span => span.spanType === 'agent_run') as AISpanRecord | undefined;\n\n  if (!rootAgentSpan) {\n    throw new Error('No root agent_run span found in trace');\n  }\n\n  return { spanTree, rootAgentSpan };\n}\n\nexport function transformTraceToScorerInputAndOutput(trace: AITraceRecord): {\n  input: ScorerRunInputForAgent;\n  output: ScorerRunOutputForAgent;\n} {\n  const { spanTree, rootAgentSpan } = prepareTraceForTransformation(trace);\n\n  if (!rootAgentSpan.output) {\n    throw new Error('Root agent span has no output');\n  }\n\n  // Build input\n  const primaryLLMSpan = findPrimaryLLMSpan(spanTree, rootAgentSpan);\n  const inputMessages = extractInputMessages(rootAgentSpan);\n  const systemMessages = extractSystemMessages(primaryLLMSpan);\n\n  // Extract remembered messages from LLM span (excluding current input)\n  const currentInputContent = inputMessages[0]?.content || '';\n  const rememberedMessages = extractRememberedMessages(primaryLLMSpan, currentInputContent);\n\n  const input = {\n    // We do not keep track of the tool call ids in traces, so we need to cast to UIMessageWithMetadata\n    inputMessages: inputMessages as UIMessageWithMetadata[],\n    rememberedMessages: rememberedMessages as UIMessageWithMetadata[],\n    systemMessages,\n    taggedSystemMessages: {}, // Todo: Support tagged system messages\n  };\n\n  // Build output\n  const toolInvocations = reconstructToolInvocations(spanTree, rootAgentSpan.spanId);\n  const responseText = rootAgentSpan.output.text || '';\n\n  const responseMessage: TransformedUIMessage = {\n    role: 'assistant',\n    content: responseText,\n    createdAt: new Date(rootAgentSpan.endedAt || rootAgentSpan.startedAt),\n    // @ts-ignore\n    parts: createMessageParts(toolInvocations, responseText),\n    experimental_attachments: [],\n    // Tool invocations are being deprecated however we need to support it for now\n    toolInvocations: toolInvocations as unknown as ToolInvocation[],\n  };\n\n  // We do not keep track of the tool call ids in traces, so we need to cast to UIMessageWithMetadata\n  const output = [responseMessage as UIMessageWithMetadata];\n\n  return {\n    input,\n    output,\n  };\n}\n","import pMap from 'p-map';\nimport z from 'zod';\nimport { InternalSpans } from '../../ai-tracing';\nimport type { TracingContext } from '../../ai-tracing';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../error';\nimport type { AISpanRecord, AITraceRecord, MastraStorage } from '../../storage';\nimport { createStep, createWorkflow } from '../../workflows/evented';\nimport type { MastraScorer, ScorerRun } from '../base';\nimport type { ScoreRowData } from '../types';\nimport { saveScorePayloadSchema } from '../types';\nimport { transformTraceToScorerInputAndOutput } from './utils';\n\nconst getTraceStep = createStep({\n  id: '__process-trace-scoring',\n  inputSchema: z.object({\n    targets: z.array(\n      z.object({\n        traceId: z.string(),\n        spanId: z.string().optional(),\n      }),\n    ),\n    scorerName: z.string(),\n  }),\n  outputSchema: z.any(),\n  execute: async ({ inputData, tracingContext, mastra }) => {\n    const logger = mastra.getLogger();\n    if (!logger) {\n      console.warn(\n        '[scoreTracesWorkflow] Logger not initialized: no debug or error logs will be recorded for scoring traces.',\n      );\n    }\n\n    const storage = mastra.getStorage();\n    if (!storage) {\n      const mastraError = new MastraError({\n        id: 'MASTRA_STORAGE_NOT_FOUND_FOR_TRACE_SCORING',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.SYSTEM,\n        text: 'Storage not found for trace scoring',\n        details: {\n          scorerName: inputData.scorerName,\n        },\n      });\n      logger?.error(mastraError.toString());\n      logger?.trackException(mastraError);\n      return;\n    }\n\n    let scorer: MastraScorer | undefined;\n    try {\n      scorer = mastra.getScorerByName(inputData.scorerName);\n    } catch (error) {\n      const mastraError = new MastraError(\n        {\n          id: 'MASTRA_SCORER_NOT_FOUND_FOR_TRACE_SCORING',\n          domain: ErrorDomain.SCORER,\n          category: ErrorCategory.SYSTEM,\n          text: `Scorer not found for trace scoring`,\n          details: {\n            scorerName: inputData.scorerName,\n          },\n        },\n        error,\n      );\n      logger?.error(mastraError.toString());\n      logger?.trackException(mastraError);\n      return;\n    }\n\n    await pMap(\n      inputData.targets,\n      async target => {\n        try {\n          await runScorerOnTarget({ storage, scorer, target, tracingContext });\n        } catch (error) {\n          const mastraError = new MastraError(\n            {\n              id: 'MASTRA_SCORER_FAILED_TO_RUN_SCORER_ON_TRACE',\n              domain: ErrorDomain.SCORER,\n              category: ErrorCategory.SYSTEM,\n              details: {\n                scorerName: scorer.name,\n                spanId: target.spanId || '',\n                traceId: target.traceId,\n              },\n            },\n            error,\n          );\n          logger?.error(mastraError.toString());\n          logger?.trackException(mastraError);\n        }\n      },\n      { concurrency: 3 },\n    );\n  },\n});\n\nexport async function runScorerOnTarget({\n  storage,\n  scorer,\n  target,\n  tracingContext,\n}: {\n  storage: MastraStorage;\n  scorer: MastraScorer;\n  target: { traceId: string; spanId?: string };\n  tracingContext: TracingContext;\n}) {\n  // TODO: add storage api to get a single span\n  const trace = await storage.getAITrace(target.traceId);\n\n  if (!trace) {\n    throw new Error(`Trace not found for scoring, traceId: ${target.traceId}`);\n  }\n\n  let span: AISpanRecord | undefined;\n  if (target.spanId) {\n    span = trace.spans.find(span => span.spanId === target.spanId);\n  } else {\n    span = trace.spans.find(span => span.parentSpanId === null);\n  }\n\n  if (!span) {\n    throw new Error(\n      `Span not found for scoring, traceId: ${target.traceId}, spanId: ${target.spanId ?? 'Not provided'}`,\n    );\n  }\n\n  const scorerRun = buildScorerRun({\n    scorerType: scorer.type === 'agent' ? 'agent' : undefined,\n    tracingContext,\n    trace,\n    targetSpan: span,\n  });\n\n  const result = await scorer.run(scorerRun);\n  const traceId = `${target.traceId}${target.spanId ? `-${target.spanId}` : ''}`;\n  const scorerResult = {\n    ...result,\n    scorer: {\n      id: scorer.name,\n      name: scorer.name,\n      description: scorer.description,\n    },\n    traceId,\n    entityId: span.name,\n    entityType: span.spanType,\n    entity: { traceId: span.traceId, spanId: span.spanId },\n    source: 'TEST',\n    scorerId: scorer.name,\n  };\n\n  const savedScoreRecord = await validateAndSaveScore({ storage, scorerResult });\n  await attachScoreToSpan({ storage, span, scoreRecord: savedScoreRecord });\n}\n\nasync function validateAndSaveScore({ storage, scorerResult }: { storage: MastraStorage; scorerResult: ScorerRun }) {\n  const payloadToSave = saveScorePayloadSchema.parse(scorerResult);\n  const result = await storage.saveScore(payloadToSave);\n  return result.score;\n}\n\nfunction buildScorerRun({\n  scorerType,\n  tracingContext,\n  trace,\n  targetSpan,\n}: {\n  scorerType?: string;\n  tracingContext: TracingContext;\n  trace: AITraceRecord;\n  targetSpan: AISpanRecord;\n}) {\n  let runPayload: ScorerRun;\n  if (scorerType === 'agent') {\n    const { input, output } = transformTraceToScorerInputAndOutput(trace);\n    runPayload = {\n      input,\n      output,\n    };\n  } else {\n    runPayload = { input: targetSpan.input, output: targetSpan.output };\n  }\n\n  runPayload.tracingContext = tracingContext;\n  return runPayload;\n}\n\nasync function attachScoreToSpan({\n  storage,\n  span,\n  scoreRecord,\n}: {\n  storage: MastraStorage;\n  span: AISpanRecord;\n  scoreRecord: ScoreRowData;\n}) {\n  const existingLinks = span.links || [];\n  const link = {\n    type: 'score',\n    scoreId: scoreRecord.id,\n    scorerName: scoreRecord.scorer.name,\n    score: scoreRecord.score,\n    createdAt: scoreRecord.createdAt,\n  };\n  await storage.updateAISpan({\n    spanId: span.spanId,\n    traceId: span.traceId,\n    updates: { links: [...existingLinks, link] },\n  });\n}\n\nexport const scoreTracesWorkflow = createWorkflow({\n  id: '__batch-scoring-traces',\n  inputSchema: z.object({\n    targets: z.array(\n      z.object({\n        traceId: z.string(),\n        spanId: z.string().optional(),\n      }),\n    ),\n    scorerName: z.string(),\n  }),\n  outputSchema: z.any(),\n  steps: [getTraceStep],\n  options: {\n    tracingPolicy: {\n      internal: InternalSpans.ALL,\n    },\n  },\n});\n\nscoreTracesWorkflow.then(getTraceStep).commit();\n"]}