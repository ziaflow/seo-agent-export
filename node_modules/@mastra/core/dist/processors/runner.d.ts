import type { MessageList } from '../agent/message-list/index.js';
import type { TracingContext } from '../ai-tracing/index.js';
import type { IMastraLogger } from '../logger/index.js';
import type { ChunkType, OutputSchema } from '../stream/index.js';
import type { MastraModelOutput } from '../stream/base/output.js';
import type { Processor } from './index.js';
/**
 * Implementation of processor state management
 */
export declare class ProcessorState<OUTPUT extends OutputSchema = undefined> {
    private accumulatedText;
    customState: Record<string, any>;
    streamParts: ChunkType<OUTPUT>[];
    constructor(_processorName: string);
    addPart(part: ChunkType<OUTPUT>): void;
}
export declare class ProcessorRunner {
    readonly inputProcessors: Processor[];
    readonly outputProcessors: Processor[];
    private readonly logger;
    private readonly agentName;
    constructor({ inputProcessors, outputProcessors, logger, agentName, }: {
        inputProcessors?: Processor[];
        outputProcessors?: Processor[];
        logger: IMastraLogger;
        agentName: string;
    });
    runOutputProcessors(messageList: MessageList, tracingContext?: TracingContext, telemetry?: any): Promise<MessageList>;
    /**
     * Process a stream part through all output processors with state management
     */
    processPart<OUTPUT extends OutputSchema>(part: ChunkType<OUTPUT>, processorStates: Map<string, ProcessorState<OUTPUT>>, tracingContext?: TracingContext): Promise<{
        part: ChunkType<OUTPUT> | null | undefined;
        blocked: boolean;
        reason?: string;
    }>;
    runOutputProcessorsForStream<OUTPUT extends OutputSchema = undefined>(streamResult: MastraModelOutput<OUTPUT>, tracingContext?: TracingContext): Promise<ReadableStream<any>>;
    runInputProcessors(messageList: MessageList, tracingContext?: TracingContext, telemetry?: any): Promise<MessageList>;
}
//# sourceMappingURL=runner.d.ts.map