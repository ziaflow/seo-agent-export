{"version":3,"sources":["../src/scores/base.ts","../src/scores/run-experiment/scorerAccumulator.ts","../src/scores/run-experiment/index.ts"],"names":["MastraError","randomUUID","createStep","z","createWorkflow","Agent","Workflow"],"mappings":"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","file":"chunk-2QV245Q5.cjs","sourcesContent":["import { randomUUID } from 'crypto';\nimport { z } from 'zod';\nimport { Agent } from '../agent';\nimport { InternalSpans } from '../ai-tracing';\nimport type { TracingContext } from '../ai-tracing';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../error';\nimport type { MastraLanguageModel } from '../llm/model/shared.types';\nimport { createWorkflow, createStep } from '../workflows';\nimport type { ScoringSamplingConfig, ScorerRunInputForAgent, ScorerRunOutputForAgent } from './types';\n\ninterface ScorerStepDefinition {\n  name: string;\n  definition: any;\n  isPromptObject: boolean;\n}\n\n// Predefined type shortcuts for common scorer patterns\ntype ScorerTypeShortcuts = {\n  agent: {\n    input: ScorerRunInputForAgent;\n    output: ScorerRunOutputForAgent;\n  };\n};\n\n// Pipeline scorer\n// TInput and TRunOutput establish the type contract for the entire scorer pipeline,\n// ensuring type safety flows through all steps and contexts\ninterface ScorerConfig<TName extends string = string, TInput = any, TRunOutput = any> {\n  name: TName;\n  description: string;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n  // Optional type specification - can be enum shortcut or explicit schemas\n  type?:\n    | keyof ScorerTypeShortcuts\n    | {\n        input: z.ZodSchema<TInput>;\n        output: z.ZodSchema<TRunOutput>;\n      };\n}\n\n// Standardized input type for all pipelines\ninterface ScorerRun<TInput = any, TOutput = any> {\n  runId?: string;\n  input?: TInput;\n  output: TOutput;\n  groundTruth?: any;\n  runtimeContext?: Record<string, any>;\n  tracingContext?: TracingContext;\n}\n\n// Prompt object definition with conditional typing\ninterface PromptObject<\n  TOutput,\n  TAccumulated extends Record<string, any>,\n  TStepName extends string = string,\n  TInput = any,\n  TRunOutput = any,\n> {\n  description: string;\n  outputSchema: z.ZodSchema<TOutput>;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n\n  // Support both sync and async createPrompt\n  createPrompt: (context: PromptObjectContext<TAccumulated, TStepName, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Helper types\ntype StepResultKey<T extends string> = `${T}StepResult`;\n\n// Simple utility type to extract resolved types from potentially async functions\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\n// Simplified context type\ntype StepContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = {\n  run: ScorerRun<TInput, TRunOutput>;\n  results: TAccumulated;\n};\n\n// Simplified AccumulatedResults - don't try to resolve Promise types here\ntype AccumulatedResults<T extends Record<string, any>, K extends string, V> = T & Record<StepResultKey<K>, V>;\n\n// Special context type for generateReason that includes the score\ntype GenerateReasonContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = StepContext<\n  TAccumulated,\n  TInput,\n  TRunOutput\n> & {\n  score: TAccumulated extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;\n};\n\ntype ScorerRunResult<TAccumulatedResults extends Record<string, any>, TInput, TRunOutput> = Promise<\n  ScorerRun<TInput, TRunOutput> & {\n    score: TAccumulatedResults extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;\n    reason?: TAccumulatedResults extends Record<'generateReasonStepResult', infer TReason> ? TReason : undefined;\n\n    // Prompts\n    preprocessPrompt?: string;\n    analyzePrompt?: string;\n    generateScorePrompt?: string;\n    generateReasonPrompt?: string;\n\n    // Results\n    preprocessStepResult?: TAccumulatedResults extends Record<'preprocessStepResult', infer TPreprocess>\n      ? TPreprocess\n      : undefined;\n    analyzeStepResult?: TAccumulatedResults extends Record<'analyzeStepResult', infer TAnalyze> ? TAnalyze : undefined;\n  } & { runId: string }\n>;\n\n// Conditional type for PromptObject context\ntype PromptObjectContext<\n  TAccumulated extends Record<string, any>,\n  TStepName extends string,\n  TInput,\n  TRunOutput,\n> = TStepName extends 'generateReason'\n  ? GenerateReasonContext<TAccumulated, TInput, TRunOutput>\n  : StepContext<TAccumulated, TInput, TRunOutput>;\n\n// Function step types that support both sync and async\ntype FunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput, TOutput> =\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => TOutput)\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<TOutput>);\n\ntype GenerateReasonFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => any)\n  | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => Promise<any>);\n\ntype GenerateScoreFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => number)\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<number>);\n\n// Special prompt object type for generateScore that always returns a number\ninterface GenerateScorePromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {\n  description: string;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n  // Support both sync and async createPrompt\n  createPrompt: (context: StepContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Special prompt object type for generateReason that always returns a string\ninterface GenerateReasonPromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {\n  description: string;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n  // Support both sync and async createPrompt\n  createPrompt: (context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Step definition types that support both function and prompt object steps\ntype PreprocessStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> =\n  | FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput>\n  | PromptObject<TStepOutput, TAccumulated, 'preprocess', TInput, TRunOutput>;\n\ntype AnalyzeStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> =\n  | FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput>\n  | PromptObject<TStepOutput, TAccumulated, 'analyze', TInput, TRunOutput>;\n\n// Conditional type for generateScore step definition\ntype GenerateScoreStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | GenerateScoreFunctionStep<TAccumulated, TInput, TRunOutput>\n  | GenerateScorePromptObject<TAccumulated, TInput, TRunOutput>;\n\n// Conditional type for generateReason step definition\ntype GenerateReasonStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | GenerateReasonFunctionStep<TAccumulated, TInput, TRunOutput>\n  | GenerateReasonPromptObject<TAccumulated, TInput, TRunOutput>;\n\nclass MastraScorer<\n  TName extends string = string,\n  TInput = any,\n  TRunOutput = any,\n  TAccumulatedResults extends Record<string, any> = {},\n> {\n  constructor(\n    public config: ScorerConfig<TName, TInput, TRunOutput>,\n    private steps: Array<ScorerStepDefinition> = [],\n    private originalPromptObjects: Map<\n      string,\n      | PromptObject<any, any, any, TInput, TRunOutput>\n      | GenerateReasonPromptObject<any, TInput, TRunOutput>\n      | GenerateScorePromptObject<any, TInput, TRunOutput>\n    > = new Map(),\n  ) {}\n\n  get type() {\n    return this.config.type;\n  }\n\n  get name(): TName {\n    return this.config.name;\n  }\n\n  get description(): string {\n    return this.config.description;\n  }\n\n  get judge() {\n    return this.config.judge;\n  }\n\n  preprocess<TPreprocessOutput>(\n    stepDef: PreprocessStepDef<TAccumulatedResults, TPreprocessOutput, TInput, TRunOutput>,\n  ): MastraScorer<\n    TName,\n    TInput,\n    TRunOutput,\n    AccumulatedResults<TAccumulatedResults, 'preprocess', Awaited<TPreprocessOutput>>\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as PromptObject<\n        TPreprocessOutput,\n        TAccumulatedResults,\n        'preprocess',\n        TInput,\n        TRunOutput\n      >;\n      this.originalPromptObjects.set('preprocess', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'preprocess',\n          definition: stepDef as FunctionStep<any, TInput, TRunOutput, TPreprocessOutput>,\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  analyze<TAnalyzeOutput>(\n    stepDef: AnalyzeStepDef<TAccumulatedResults, TAnalyzeOutput, TInput, TRunOutput>,\n  ): MastraScorer<\n    TName,\n    TInput,\n    TRunOutput,\n    AccumulatedResults<TAccumulatedResults, 'analyze', Awaited<TAnalyzeOutput>>\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as PromptObject<TAnalyzeOutput, TAccumulatedResults, 'analyze', TInput, TRunOutput>;\n      this.originalPromptObjects.set('analyze', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'analyze',\n          definition: isPromptObj ? undefined : (stepDef as FunctionStep<any, TInput, TRunOutput, TAnalyzeOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  generateScore<TScoreOutput extends number = number>(\n    stepDef: GenerateScoreStepDef<TAccumulatedResults, TInput, TRunOutput>,\n  ): MastraScorer<\n    TName,\n    TInput,\n    TRunOutput,\n    AccumulatedResults<TAccumulatedResults, 'generateScore', Awaited<TScoreOutput>>\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as GenerateScorePromptObject<TAccumulatedResults, TInput, TRunOutput>;\n      this.originalPromptObjects.set('generateScore', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'generateScore',\n          definition: isPromptObj ? undefined : (stepDef as GenerateScoreFunctionStep<any, TInput, TRunOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  generateReason<TReasonOutput = string>(\n    stepDef: GenerateReasonStepDef<TAccumulatedResults, TInput, TRunOutput>,\n  ): MastraScorer<\n    TName,\n    TInput,\n    TRunOutput,\n    AccumulatedResults<TAccumulatedResults, 'generateReason', Awaited<TReasonOutput>>\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as GenerateReasonPromptObject<TAccumulatedResults, TInput, TRunOutput>;\n      this.originalPromptObjects.set('generateReason', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'generateReason',\n          definition: isPromptObj ? undefined : (stepDef as GenerateReasonFunctionStep<any, TInput, TRunOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  private get hasGenerateScore(): boolean {\n    return this.steps.some(step => step.name === 'generateScore');\n  }\n\n  async run(input: ScorerRun<TInput, TRunOutput>): ScorerRunResult<TAccumulatedResults, TInput, TRunOutput> {\n    // Runtime check: execute only allowed after generateScore\n    if (!this.hasGenerateScore) {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_MISSING_GENERATE_SCORE',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Cannot execute pipeline without generateScore() step`,\n        details: {\n          scorerId: this.config.name,\n          steps: this.steps.map(s => s.name).join(', '),\n        },\n      });\n    }\n\n    const { tracingContext } = input;\n\n    let runId = input.runId;\n    if (!runId) {\n      runId = randomUUID();\n    }\n\n    const run = { ...input, runId };\n\n    const workflow = this.toMastraWorkflow();\n    const workflowRun = await workflow.createRunAsync();\n    const workflowResult = await workflowRun.start({\n      inputData: {\n        run,\n      },\n      tracingContext,\n    });\n\n    if (workflowResult.status === 'failed') {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_WORKFLOW_FAILED',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Scorer Run Failed: ${workflowResult.error}`,\n        details: {\n          scorerId: this.config.name,\n          steps: this.steps.map(s => s.name).join(', '),\n        },\n      });\n    }\n\n    return this.transformToScorerResult({ workflowResult, originalInput: run });\n  }\n\n  private isPromptObject(stepDef: any): boolean {\n    // Check if it's a generateScore prompt object (has description and createPrompt, but no outputSchema)\n    if (\n      typeof stepDef === 'object' &&\n      'description' in stepDef &&\n      'createPrompt' in stepDef &&\n      !('outputSchema' in stepDef)\n    ) {\n      return true;\n    }\n\n    // For other steps, check for description, outputSchema, and createPrompt\n    const isOtherPromptObject =\n      typeof stepDef === 'object' && 'description' in stepDef && 'outputSchema' in stepDef && 'createPrompt' in stepDef;\n\n    return isOtherPromptObject;\n  }\n\n  getSteps(): Array<{ name: string; type: 'function' | 'prompt'; description?: string }> {\n    return this.steps.map(step => ({\n      name: step.name,\n      type: step.isPromptObject ? 'prompt' : 'function',\n      description: step.definition.description,\n    }));\n  }\n\n  private toMastraWorkflow() {\n    // Convert each scorer step to a workflow step\n    const workflowSteps = this.steps.map(scorerStep => {\n      return createStep({\n        id: scorerStep.name,\n        description: `Scorer step: ${scorerStep.name}`,\n        inputSchema: z.any(),\n        outputSchema: z.any(),\n        execute: async ({ inputData, getInitData, tracingContext }) => {\n          const { accumulatedResults = {}, generatedPrompts = {} } = inputData;\n          const { run } = getInitData();\n\n          const context = this.createScorerContext(scorerStep.name, run, accumulatedResults);\n\n          let stepResult;\n          let newGeneratedPrompts = generatedPrompts;\n          if (scorerStep.isPromptObject) {\n            const { result, prompt } = await this.executePromptStep(scorerStep, tracingContext, context);\n            stepResult = result;\n            newGeneratedPrompts = {\n              ...generatedPrompts,\n              [`${scorerStep.name}Prompt`]: prompt,\n            };\n          } else {\n            stepResult = await this.executeFunctionStep(scorerStep, context);\n          }\n\n          const newAccumulatedResults = {\n            ...accumulatedResults,\n            [`${scorerStep.name}StepResult`]: stepResult,\n          };\n\n          return {\n            stepResult,\n            accumulatedResults: newAccumulatedResults,\n            generatedPrompts: newGeneratedPrompts,\n          };\n        },\n      });\n    });\n\n    const workflow = createWorkflow({\n      id: `scorer-${this.config.name}`,\n      description: this.config.description,\n      inputSchema: z.object({\n        run: z.any(), // ScorerRun\n      }),\n      outputSchema: z.object({\n        run: z.any(),\n        score: z.number(),\n        reason: z.string().optional(),\n        preprocessResult: z.any().optional(),\n        analyzeResult: z.any().optional(),\n        preprocessPrompt: z.string().optional(),\n        analyzePrompt: z.string().optional(),\n        generateScorePrompt: z.string().optional(),\n        generateReasonPrompt: z.string().optional(),\n      }),\n      options: {\n        // mark all spans generated as part of the scorer workflow internal\n        tracingPolicy: {\n          internal: InternalSpans.ALL,\n        },\n      },\n    });\n\n    let chainedWorkflow = workflow;\n    for (const step of workflowSteps) {\n      // @ts-ignore - Complain about the type mismatch when we chain the steps\n      chainedWorkflow = chainedWorkflow.then(step);\n    }\n\n    return chainedWorkflow.commit();\n  }\n\n  private createScorerContext(\n    stepName: string,\n    run: ScorerRun<TInput, TRunOutput>,\n    accumulatedResults: Record<string, any>,\n  ) {\n    if (stepName === 'generateReason') {\n      const score = accumulatedResults.generateScoreStepResult;\n      return { run, results: accumulatedResults, score };\n    }\n\n    return { run, results: accumulatedResults };\n  }\n\n  private async executeFunctionStep(scorerStep: ScorerStepDefinition, context: any) {\n    return await scorerStep.definition(context);\n  }\n\n  private async executePromptStep(scorerStep: ScorerStepDefinition, tracingContext: TracingContext, context: any) {\n    const originalStep = this.originalPromptObjects.get(scorerStep.name);\n    if (!originalStep) {\n      throw new Error(`Step \"${scorerStep.name}\" is not a prompt object`);\n    }\n\n    const prompt = await originalStep.createPrompt(context);\n    const model = originalStep.judge?.model ?? this.config.judge?.model;\n    const instructions = originalStep.judge?.instructions ?? this.config.judge?.instructions;\n\n    if (!model || !instructions) {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_MISSING_MODEL_OR_INSTRUCTIONS',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Step \"${scorerStep.name}\" requires a model and instructions`,\n        details: {\n          scorerId: this.config.name,\n          step: scorerStep.name,\n        },\n      });\n    }\n\n    const judge = new Agent({\n      name: 'judge',\n      model,\n      instructions,\n      options: { tracingPolicy: { internal: InternalSpans.ALL } },\n    });\n\n    // GenerateScore output must be a number\n    if (scorerStep.name === 'generateScore') {\n      let result;\n      if (model.specificationVersion === 'v2') {\n        result = await judge.generate(prompt, {\n          output: z.object({ score: z.number() }),\n          tracingContext,\n        });\n      } else {\n        result = await judge.generateLegacy(prompt, {\n          output: z.object({ score: z.number() }),\n          tracingContext,\n        });\n      }\n      return { result: result.object.score, prompt };\n\n      // GenerateReason output must be a string\n    } else if (scorerStep.name === 'generateReason') {\n      let result;\n      if (model.specificationVersion === 'v2') {\n        result = await judge.generate(prompt, { tracingContext });\n      } else {\n        result = await judge.generateLegacy(prompt, { tracingContext });\n      }\n      return { result: result.text, prompt };\n    } else {\n      const promptStep = originalStep as PromptObject<any, any, any, TInput, TRunOutput>;\n      let result;\n      if (model.specificationVersion === 'v2') {\n        result = await judge.generate(prompt, {\n          output: promptStep.outputSchema,\n          tracingContext,\n        });\n      } else {\n        result = await judge.generateLegacy(prompt, {\n          output: promptStep.outputSchema,\n          tracingContext,\n        });\n      }\n      return { result: result.object, prompt };\n    }\n  }\n\n  private transformToScorerResult({\n    workflowResult,\n    originalInput,\n  }: {\n    workflowResult: any;\n    originalInput: ScorerRun<TInput, TRunOutput> & { runId: string };\n  }) {\n    const finalStepResult = workflowResult.result;\n    const accumulatedResults = finalStepResult?.accumulatedResults || {};\n    const generatedPrompts = finalStepResult?.generatedPrompts || {};\n\n    return {\n      ...originalInput,\n      score: accumulatedResults.generateScoreStepResult,\n      generateScorePrompt: generatedPrompts.generateScorePrompt,\n      reason: accumulatedResults.generateReasonStepResult,\n      generateReasonPrompt: generatedPrompts.generateReasonPrompt,\n      preprocessStepResult: accumulatedResults.preprocessStepResult,\n      preprocessPrompt: generatedPrompts.preprocessPrompt,\n      analyzeStepResult: accumulatedResults.analyzeStepResult,\n      analyzePrompt: generatedPrompts.analyzePrompt,\n    };\n  }\n}\n\n// Overload: enum type shortcuts (e.g., type: 'agent')\nexport function createScorer<TName extends string, TType extends keyof ScorerTypeShortcuts>(\n  config: Omit<ScorerConfig<TName, any, any>, 'type'> & {\n    type: TType;\n  },\n): MastraScorer<TName, ScorerTypeShortcuts[TType]['input'], ScorerTypeShortcuts[TType]['output'], {}>;\n\n// Overload: infer TInput/TRunOutput from provided Zod schemas in config.type\nexport function createScorer<\n  TName extends string,\n  TInputSchema extends z.ZodTypeAny,\n  TOutputSchema extends z.ZodTypeAny,\n>(\n  config: Omit<ScorerConfig<TName, z.infer<TInputSchema>, z.infer<TOutputSchema>>, 'type'> & {\n    type: { input: TInputSchema; output: TOutputSchema };\n  },\n): MastraScorer<TName, z.infer<TInputSchema>, z.infer<TOutputSchema>, {}>;\n\n// Overload: explicit generics (backwards compatible)\nexport function createScorer<TInput = any, TRunOutput = any, TName extends string = string>(\n  config: ScorerConfig<TName, TInput, TRunOutput>,\n): MastraScorer<TName, TInput, TRunOutput, {}>;\n\n// Implementation\nexport function createScorer(config: any): any {\n  return new MastraScorer({\n    name: config.name,\n    description: config.description,\n    judge: config.judge,\n    type: config.type,\n  });\n}\n\nexport type MastraScorerEntry = {\n  scorer: MastraScorer<any, any, any>;\n  sampling?: ScoringSamplingConfig;\n};\n\nexport type MastraScorers = Record<string, MastraScorerEntry>;\n\n// Export types and interfaces for use in test files\nexport type { ScorerConfig, ScorerRun, PromptObject };\n\nexport { MastraScorer };\n","export class ScoreAccumulator {\n  private flatScores: Record<string, number[]> = {};\n  private workflowScores: Record<string, number[]> = {};\n  private stepScores: Record<string, Record<string, number[]>> = {};\n\n  addScores(scorerResults: Record<string, any>) {\n    const isTargetWorkflowAndHasStepScores = 'steps' in scorerResults;\n    if (isTargetWorkflowAndHasStepScores) {\n      this.addNestedScores(scorerResults);\n    } else {\n      this.addFlatScores(scorerResults);\n    }\n  }\n\n  private addFlatScores(scorerResults: Record<string, any>) {\n    for (const [scorerName, result] of Object.entries(scorerResults)) {\n      if (!this.flatScores[scorerName]) {\n        this.flatScores[scorerName] = [];\n      }\n      this.flatScores[scorerName].push((result as { score: number }).score);\n    }\n  }\n\n  private addNestedScores(scorerResults: Record<string, any>) {\n    if ('workflow' in scorerResults && scorerResults.workflow) {\n      for (const [scorerName, result] of Object.entries(scorerResults.workflow)) {\n        if (!this.workflowScores[scorerName]) {\n          this.workflowScores[scorerName] = [];\n        }\n        this.workflowScores[scorerName].push((result as { score: number }).score);\n      }\n    }\n\n    if ('steps' in scorerResults && scorerResults.steps) {\n      for (const [stepId, stepResults] of Object.entries(scorerResults.steps)) {\n        if (!this.stepScores[stepId]) {\n          this.stepScores[stepId] = {};\n        }\n        for (const [scorerName, result] of Object.entries(stepResults as Record<string, any>)) {\n          if (!this.stepScores[stepId][scorerName]) {\n            this.stepScores[stepId][scorerName] = [];\n          }\n          this.stepScores[stepId][scorerName].push((result as { score: number }).score);\n        }\n      }\n    }\n  }\n\n  addStepScores(stepScorerResults: Record<string, Record<string, any>>) {\n    for (const [stepId, stepResults] of Object.entries(stepScorerResults)) {\n      if (!this.stepScores[stepId]) {\n        this.stepScores[stepId] = {};\n      }\n      for (const [scorerName, result] of Object.entries(stepResults)) {\n        if (!this.stepScores[stepId][scorerName]) {\n          this.stepScores[stepId][scorerName] = [];\n        }\n        this.stepScores[stepId][scorerName].push((result as { score: number }).score);\n      }\n    }\n  }\n\n  getAverageScores(): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    for (const [scorerName, scoreArray] of Object.entries(this.flatScores)) {\n      result[scorerName] = this.getAverageScore(scoreArray);\n    }\n\n    // Add workflow scores\n    if (Object.keys(this.workflowScores).length > 0) {\n      result.workflow = {};\n      for (const [scorerName, scoreArray] of Object.entries(this.workflowScores)) {\n        result.workflow[scorerName] = this.getAverageScore(scoreArray);\n      }\n    }\n\n    if (Object.keys(this.stepScores).length > 0) {\n      result.steps = {};\n      for (const [stepId, stepScorers] of Object.entries(this.stepScores)) {\n        result.steps[stepId] = {};\n        for (const [scorerName, scoreArray] of Object.entries(stepScorers)) {\n          result.steps[stepId][scorerName] = this.getAverageScore(scoreArray);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private getAverageScore(scoreArray: number[]): number {\n    if (scoreArray.length > 0) {\n      return scoreArray.reduce((a, b) => a + b, 0) / scoreArray.length;\n    } else {\n      return 0;\n    }\n  }\n}\n","import type { CoreMessage } from 'ai';\nimport type { Agent, AiMessageType, UIMessageWithMetadata } from '../../agent';\nimport type { TracingContext } from '../../ai-tracing';\nimport { MastraError } from '../../error';\nimport type { RuntimeContext } from '../../runtime-context';\nimport { Workflow } from '../../workflows';\nimport type { WorkflowResult, StepResult } from '../../workflows';\nimport type { MastraScorer } from '../base';\nimport { ScoreAccumulator } from './scorerAccumulator';\n\ntype RunExperimentDataItem<TTarget = unknown> = {\n  input: TTarget extends Workflow<any, any>\n    ? any\n    : TTarget extends Agent\n      ? string | string[] | CoreMessage[] | AiMessageType[] | UIMessageWithMetadata[]\n      : unknown;\n  groundTruth?: any;\n  runtimeContext?: RuntimeContext;\n  tracingContext?: TracingContext;\n};\n\ntype WorkflowScorerConfig = {\n  workflow?: MastraScorer<any, any, any, any>[];\n  steps?: Record<string, MastraScorer<any, any, any, any>[]>;\n};\n\ntype RunExperimentResult = {\n  scores: Record<string, any>;\n  summary: {\n    totalItems: number;\n  };\n};\n\n// Agent with scorers array\nexport function runExperiment<TAgent extends Agent>(config: {\n  data: RunExperimentDataItem<TAgent>[];\n  scorers: MastraScorer<any, any, any, any>[];\n  target: TAgent;\n  onItemComplete?: (params: {\n    item: RunExperimentDataItem<TAgent>;\n    targetResult: ReturnType<Agent['generate']>;\n    scorerResults: Record<string, any>; // Flat structure: { scorerName: result }\n  }) => void | Promise<void>;\n  concurrency?: number;\n}): Promise<RunExperimentResult>;\n\n// Workflow with scorers array\nexport function runExperiment<TWorkflow extends Workflow>(config: {\n  data: RunExperimentDataItem<TWorkflow>[];\n  scorers: MastraScorer<any, any, any, any>[];\n  target: TWorkflow;\n  onItemComplete?: (params: {\n    item: RunExperimentDataItem<TWorkflow>;\n    targetResult: WorkflowResult<any, any, any, any>;\n    scorerResults: Record<string, any>; // Flat structure: { scorerName: result }\n  }) => void | Promise<void>;\n  concurrency?: number;\n}): Promise<RunExperimentResult>;\n\n// Workflow with workflow configuration\nexport function runExperiment<TWorkflow extends Workflow>(config: {\n  data: RunExperimentDataItem<TWorkflow>[];\n  scorers: WorkflowScorerConfig;\n  target: TWorkflow;\n  onItemComplete?: (params: {\n    item: RunExperimentDataItem<TWorkflow>;\n    targetResult: WorkflowResult<any, any, any, any>;\n    scorerResults: {\n      workflow?: Record<string, any>;\n      steps?: Record<string, Record<string, any>>;\n    };\n  }) => void | Promise<void>;\n  concurrency?: number;\n}): Promise<RunExperimentResult>;\nexport async function runExperiment(config: {\n  data: RunExperimentDataItem<any>[];\n  scorers: MastraScorer<any, any, any, any>[] | WorkflowScorerConfig;\n  target: Agent | Workflow;\n  onItemComplete?: (params: {\n    item: RunExperimentDataItem<any>;\n    targetResult: any;\n    scorerResults: any;\n  }) => void | Promise<void>;\n  concurrency?: number;\n}): Promise<RunExperimentResult> {\n  const { data, scorers, target, onItemComplete, concurrency = 1 } = config;\n\n  validateExperimentInputs(data, scorers, target);\n\n  let totalItems = 0;\n  const scoreAccumulator = new ScoreAccumulator();\n\n  const pMap = (await import('p-map')).default;\n  await pMap(\n    data,\n    async (item: RunExperimentDataItem<any>) => {\n      const targetResult = await executeTarget(target, item);\n      const scorerResults = await runScorers(scorers, targetResult, item);\n      scoreAccumulator.addScores(scorerResults);\n\n      if (onItemComplete) {\n        await onItemComplete({\n          item,\n          targetResult: targetResult as any,\n          scorerResults: scorerResults as any,\n        });\n      }\n\n      totalItems++;\n    },\n    { concurrency },\n  );\n\n  return {\n    scores: scoreAccumulator.getAverageScores(),\n    summary: {\n      totalItems,\n    },\n  };\n}\n\nfunction isWorkflow(target: Agent | Workflow): target is Workflow {\n  return target instanceof Workflow;\n}\n\nfunction isWorkflowScorerConfig(scorers: any): scorers is WorkflowScorerConfig {\n  return typeof scorers === 'object' && !Array.isArray(scorers) && ('workflow' in scorers || 'steps' in scorers);\n}\n\nfunction validateExperimentInputs(\n  data: RunExperimentDataItem<any>[],\n  scorers: MastraScorer<any, any, any, any>[] | WorkflowScorerConfig,\n  target: Agent | Workflow,\n): void {\n  if (data.length === 0) {\n    throw new MastraError({\n      domain: 'SCORER',\n      id: 'RUN_EXPERIMENT_FAILED_NO_DATA_PROVIDED',\n      category: 'USER',\n      text: 'Failed to run experiment: Data array is empty',\n    });\n  }\n\n  for (let i = 0; i < data.length; i++) {\n    const item = data[i];\n    if (!item || typeof item !== 'object' || !('input' in item)) {\n      throw new MastraError({\n        domain: 'SCORER',\n        id: 'INVALID_DATA_ITEM',\n        category: 'USER',\n        text: `Invalid data item at index ${i}: must have 'input' properties`,\n      });\n    }\n  }\n\n  // Validate scorers\n  if (Array.isArray(scorers)) {\n    if (scorers.length === 0) {\n      throw new MastraError({\n        domain: 'SCORER',\n        id: 'NO_SCORERS_PROVIDED',\n        category: 'USER',\n        text: 'At least one scorer must be provided',\n      });\n    }\n  } else if (isWorkflow(target) && isWorkflowScorerConfig(scorers)) {\n    const hasScorers =\n      (scorers.workflow && scorers.workflow.length > 0) || (scorers.steps && Object.keys(scorers.steps).length > 0);\n\n    if (!hasScorers) {\n      throw new MastraError({\n        domain: 'SCORER',\n        id: 'NO_SCORERS_PROVIDED',\n        category: 'USER',\n        text: 'At least one workflow or step scorer must be provided',\n      });\n    }\n  } else if (!isWorkflow(target) && !Array.isArray(scorers)) {\n    throw new MastraError({\n      domain: 'SCORER',\n      id: 'INVALID_AGENT_SCORERS',\n      category: 'USER',\n      text: 'Agent scorers must be an array of scorers',\n    });\n  }\n}\n\nasync function executeTarget(target: Agent | Workflow, item: RunExperimentDataItem<any>) {\n  try {\n    if (isWorkflow(target)) {\n      return await executeWorkflow(target, item);\n    } else {\n      return await executeAgent(target, item);\n    }\n  } catch (error) {\n    throw new MastraError(\n      {\n        domain: 'SCORER',\n        id: 'RUN_EXPERIMENT_TARGET_FAILED_TO_GENERATE_RESULT',\n        category: 'USER',\n        text: 'Failed to run experiment: Error generating result from target',\n        details: {\n          item: JSON.stringify(item),\n        },\n      },\n      error,\n    );\n  }\n}\n\nasync function executeWorkflow(target: Workflow, item: RunExperimentDataItem<any>) {\n  const run = await target.createRunAsync({ disableScorers: true });\n  const workflowResult = await run.start({\n    inputData: item.input,\n    runtimeContext: item.runtimeContext,\n  });\n\n  return {\n    scoringData: {\n      input: item.input,\n      output: workflowResult.status === 'success' ? workflowResult.result : undefined,\n      stepResults: workflowResult.steps as Record<string, StepResult<any, any, any, any>>,\n    },\n  };\n}\n\nasync function executeAgent(agent: Agent, item: RunExperimentDataItem<any>) {\n  const model = await agent.getModel();\n  if (model.specificationVersion === 'v2') {\n    return await agent.generate(item.input as any, {\n      scorers: {},\n      returnScorerData: true,\n      runtimeContext: item.runtimeContext,\n    });\n  } else {\n    return await agent.generateLegacy(item.input as any, {\n      scorers: {},\n      returnScorerData: true,\n      runtimeContext: item.runtimeContext,\n    });\n  }\n}\n\nasync function runScorers(\n  scorers: MastraScorer<any, any, any, any>[] | WorkflowScorerConfig,\n  targetResult: any,\n  item: RunExperimentDataItem<any>,\n): Promise<Record<string, any>> {\n  const scorerResults: Record<string, any> = {};\n\n  if (Array.isArray(scorers)) {\n    for (const scorer of scorers) {\n      try {\n        const score = await scorer.run({\n          input: targetResult.scoringData?.input,\n          output: targetResult.scoringData?.output,\n          groundTruth: item.groundTruth,\n          runtimeContext: item.runtimeContext,\n          tracingContext: item.tracingContext,\n        });\n\n        scorerResults[scorer.name] = score;\n      } catch (error) {\n        throw new MastraError(\n          {\n            domain: 'SCORER',\n            id: 'RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_RESULT',\n            category: 'USER',\n            text: `Failed to run experiment: Error running scorer ${scorer.name}`,\n            details: {\n              scorerName: scorer.name,\n              item: JSON.stringify(item),\n            },\n          },\n          error,\n        );\n      }\n    }\n  } else {\n    // Handle workflow scorer config\n    if (scorers.workflow) {\n      const workflowScorerResults: Record<string, any> = {};\n      for (const scorer of scorers.workflow) {\n        const score = await scorer.run({\n          input: targetResult.scoringData.input,\n          output: targetResult.scoringData.output,\n          groundTruth: item.groundTruth,\n          runtimeContext: item.runtimeContext,\n          tracingContext: item.tracingContext,\n        });\n        workflowScorerResults[scorer.name] = score;\n      }\n      if (Object.keys(workflowScorerResults).length > 0) {\n        scorerResults.workflow = workflowScorerResults;\n      }\n    }\n\n    if (scorers.steps) {\n      const stepScorerResults: Record<string, any> = {};\n      for (const [stepId, stepScorers] of Object.entries(scorers.steps)) {\n        const stepResult = targetResult.scoringData.stepResults?.[stepId];\n        if (stepResult?.status === 'success' && stepResult.payload && stepResult.output) {\n          const stepResults: Record<string, any> = {};\n          for (const scorer of stepScorers) {\n            try {\n              const score = await scorer.run({\n                input: stepResult.payload,\n                output: stepResult.output,\n                groundTruth: item.groundTruth,\n                runtimeContext: item.runtimeContext,\n                tracingContext: item.tracingContext,\n              });\n              stepResults[scorer.name] = score;\n            } catch (error) {\n              throw new MastraError(\n                {\n                  domain: 'SCORER',\n                  id: 'RUN_EXPERIMENT_SCORER_FAILED_TO_SCORE_STEP_RESULT',\n                  category: 'USER',\n                  text: `Failed to run experiment: Error running scorer ${scorer.name} on step ${stepId}`,\n                  details: {\n                    scorerName: scorer.name,\n                    stepId,\n                  },\n                },\n                error,\n              );\n            }\n          }\n          if (Object.keys(stepResults).length > 0) {\n            stepScorerResults[stepId] = stepResults;\n          }\n        }\n      }\n      if (Object.keys(stepScorerResults).length > 0) {\n        scorerResults.steps = stepScorerResults;\n      }\n    }\n  }\n\n  return scorerResults;\n}\n"]}