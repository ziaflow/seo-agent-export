import path from 'node:path';
import fs from 'node:fs/promises';
import cp from 'node:child_process';
import { createRequire, isBuiltin } from 'node:module';
const { name, version } = createRequire(import.meta.url)('#package.json');
const workspaceRootFiles = [
    'pnpm-workspace.yaml',
    'lerna.json',
    'rush.json',
];
const defaults = {
    builtins: true,
    builtinsPrefix: 'add',
    packagePath: [],
    deps: true,
    devDeps: false,
    peerDeps: true,
    optDeps: true,
    include: [],
    exclude: []
};
const isString = (str) => typeof str === 'string' && str.length > 0;
const fileExists = (name) => fs.stat(name).then(stat => stat.isFile()).catch(() => false);
function nodeExternals(options = {}) {
    const config = { ...defaults, ...options };
    let include = [], exclude = [];
    const isIncluded = (id) => include.length > 0 && include.some(rx => rx.test(id)), isExcluded = (id) => exclude.length > 0 && exclude.some(rx => rx.test(id));
    const gitTopLevel = new Promise(resolve => {
        cp.execFile('git', ['rev-parse', '--show-toplevel'], (error, stdout) => {
            resolve(error ? '' : path.normalize(stdout.trim()));
        });
    });
    return {
        name: name.replace(/^rollup-plugin-/, ''),
        version,
        apply: 'build',
        enforce: 'pre',
        async buildStart() {
            [include, exclude] = ['include', 'exclude'].map(option => []
                .concat(config[option])
                .reduce((result, entry, index) => {
                if (entry instanceof RegExp)
                    result.push(entry);
                else if (isString(entry))
                    result.push(new RegExp('^' + entry.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$'));
                else if (entry)
                    this.warn(`Ignoring wrong entry type #${index} in '${option}' option: ${JSON.stringify(entry)}`);
                return result;
            }, []));
            const packagePaths = []
                .concat(config.packagePath)
                .filter(isString)
                .map(packagePath => path.resolve(packagePath));
            if (packagePaths.length === 0) {
                for (let current = process.cwd(), previous = ''; previous !== current; previous = current, current = path.dirname(current)) {
                    const name = path.join(current, 'package.json');
                    if (await fileExists(name))
                        packagePaths.push(name);
                    const breaks = await Promise.all([
                        gitTopLevel.then(topLevel => topLevel === current),
                        ...workspaceRootFiles.map(name => fileExists(path.join(current, name)))
                    ]);
                    if (breaks.some(result => result))
                        break;
                }
            }
            const externals = {};
            for (const packagePath of packagePaths) {
                const manifest = await fs.readFile(packagePath)
                    .then(buffer => JSON.parse(buffer.toString()))
                    .catch((err) => err);
                if (manifest instanceof Error) {
                    const message = manifest instanceof SyntaxError
                        ? `File ${JSON.stringify(packagePath)} does not look like a valid package.json.`
                        : `Cannot read ${JSON.stringify(packagePath)}, error: ${manifest.code}.`;
                    return this.error({ message, stack: undefined });
                }
                Object.assign(externals, config.deps ? manifest.dependencies : undefined, config.devDeps ? manifest.devDependencies : undefined, config.peerDeps ? manifest.peerDependencies : undefined, config.optDeps ? manifest.optionalDependencies : undefined);
                this.addWatchFile(packagePath);
                if (Array.isArray(manifest.workspaces))
                    break;
            }
            const names = Object.keys(externals);
            if (names.length > 0)
                include.push(new RegExp('^(?:' + names.join('|') + ')(?:/.+)?$'));
        },
        resolveId(specifier, _, { isEntry }) {
            if (isEntry
                || /^(?:\0|\.{1,2}\/)/.test(specifier)
                || path.isAbsolute(specifier)) {
                return null;
            }
            if (isBuiltin(specifier)) {
                const stripped = specifier.replace(/^node:/, '');
                return {
                    id: config.builtinsPrefix === 'ignore'
                        ? specifier
                        : config.builtinsPrefix === 'add' || !isBuiltin(stripped)
                            ? 'node:' + stripped
                            : stripped,
                    external: (config.builtins || isIncluded(specifier)) && !isExcluded(specifier),
                    moduleSideEffects: false
                };
            }
            return isIncluded(specifier) && !isExcluded(specifier)
                ? false
                : null;
        }
    };
}
export default nodeExternals;
export { nodeExternals };
//# sourceMappingURL=index.js.map