{"version":3,"file":"gke.js","sourceRoot":"","sources":["../../../src/detectors/gke.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;GAeG;;;AAEH;;;GAGG;AAEH,yCAAyC;AACzC,6BAA6B;AAE7B,MAAM,2BAA2B,GAAG,yBAAyB,CAAC;AAC9D,MAAM,0BAA0B,GAAG,yBAAyB,CAAC;AAC7D,MAAM,8BAA8B,GAAG,6BAA6B,CAAC;AAE9D,KAAK,UAAU,KAAK;IACzB,OAAO,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,KAAK,SAAS,CAAC;AAChE,CAAC;AAFD,sBAEC;AAED;;;GAGG;AACI,KAAK,UAAU,MAAM;IAC1B,OAAO,MAAM,GAAG,CAAC,MAAM,EAAE,CAAC;AAC5B,CAAC;AAFD,wBAEC;AAED;;;GAGG;AACI,KAAK,UAAU,WAAW;IAC/B,OAAO,QAAQ,CAAC,QAAQ,CAAS,0BAA0B,CAAC,CAAC;AAC/D,CAAC;AAFD,kCAEC;AAED;;;GAGG;AACI,KAAK,UAAU,wBAAwB;IAI5C,MAAM,eAAe,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAC7C,8BAA8B,CAC/B,CAAC;IACF,QAAQ,SAAS,CAAC,eAAe,EAAE,GAAG,CAAC,EAAE;QACvC,KAAK,CAAC;YACJ,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,eAAe,EAAE,CAAC;QACpD,KAAK,CAAC;YACJ,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,eAAe,EAAE,CAAC;QAClD;YACE,MAAM,IAAI,KAAK,CACb,6CAA6C,eAAe,EAAE,CAC/D,CAAC;KACL;AACH,CAAC;AAjBD,4DAiBC;AAED,SAAS,SAAS,CAAC,CAAS,EAAE,IAAY;IACxC,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACjC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;YACjB,KAAK,IAAI,CAAC,CAAC;SACZ;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Implementation in this file copied from\n * https://github.com/GoogleCloudPlatform/opentelemetry-operations-go/blob/v1.8.0/detectors/gcp/gke.go\n */\n\nimport * as metadata from 'gcp-metadata';\nimport * as gce from './gce';\n\nconst KUBERNETES_SERVICE_HOST_ENV = 'KUBERNETES_SERVICE_HOST';\nconst CLUSTER_NAME_METADATA_ATTR = 'attributes/cluster-name';\nconst CLUSTER_LOCATION_METADATA_ATTR = 'attributes/cluster-location';\n\nexport async function onGke(): Promise<boolean> {\n  return process.env[KUBERNETES_SERVICE_HOST_ENV] !== undefined;\n}\n\n/**\n * The instance ID of the instance on which this program is running. Check that {@link onGke()}\n * is true before calling this, or it may throw exceptions.\n */\nexport async function hostId(): Promise<string> {\n  return await gce.hostId();\n}\n\n/**\n * The name of the GKE cluster in which this program is running. Check that {@link onGke()} is\n * true before calling this, or it may throw exceptions.\n */\nexport async function clusterName(): Promise<string> {\n  return metadata.instance<string>(CLUSTER_NAME_METADATA_ATTR);\n}\n\n/**\n * The location of the cluster and whether the cluster is zonal or regional. Check that {@link\n * onGke()} is true before calling this, or it may throw exceptions.\n */\nexport async function availabilityZoneOrRegion(): Promise<{\n  type: 'zone' | 'region';\n  value: string;\n}> {\n  const clusterLocation = await metadata.instance<string>(\n    CLUSTER_LOCATION_METADATA_ATTR\n  );\n  switch (countChar(clusterLocation, '-')) {\n    case 1:\n      return { type: 'region', value: clusterLocation };\n    case 2:\n      return { type: 'zone', value: clusterLocation };\n    default:\n      throw new Error(\n        `unrecognized format for cluster location: ${clusterLocation}`\n      );\n  }\n}\n\nfunction countChar(s: string, char: string): number {\n  let count = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === char) {\n      count += 1;\n    }\n  }\n  return count;\n}\n"]}