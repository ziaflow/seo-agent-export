{"version":3,"file":"cloudflare.js","names":["frameworkName: SupportedFrameworkName"],"sources":["../src/cloudflare.ts"],"sourcesContent":["/**\n * An adapter for Cloudflare Workers (and Workers on Pages) to serve and\n * register any declared functions with Inngest, making them available to be\n * triggered by events.\n *\n * @example\n * ```ts\n * import { serve } from \"inngest/cloudflare\";\n * import { inngest } from \"../../inngest/client\";\n * import fnA from \"../../inngest/fnA\"; // Your own function\n *\n * export const onRequest = serve({\n *   client: inngest,\n *   functions: [fnA],\n * });\n * ```\n *\n * @example Cloudflare Workers\n * ```ts\n * import { serve } from \"inngest/cloudflare\";\n * import { inngest } from \"../../inngest/client\";\n * import fnA from \"../../inngest/fnA\"; // Your own function\n *\n * export default {\n *   fetch: serve({\n *     client: inngest,\n *     functions: [fnA],\n *   }),\n * };\n * ```\n *\n * @module\n */\n\nimport {\n  InngestCommHandler,\n  type ServeHandlerOptions,\n} from \"./components/InngestCommHandler.ts\";\nimport type { Either } from \"./helpers/types.ts\";\nimport type { SupportedFrameworkName } from \"./types.ts\";\n\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexport const frameworkName: SupportedFrameworkName = \"cloudflare-pages\";\n\n/**\n * Expected arguments for a Cloudflare Pages Function.\n */\nexport type PagesHandlerArgs = [\n  { request: Request; env: Record<string, string | undefined> },\n];\n\n/**\n * Expected arguments for a Cloudflare Worker.\n */\nexport type WorkersHandlerArgs = [Request, Record<string, string | undefined>];\n\n/**\n * Support both Cloudflare Pages Functions and Cloudflare Workers by lightly\n * asserting the shape of the input arguments at runtime.\n */\nconst deriveHandlerArgs = (\n  args: Either<PagesHandlerArgs, WorkersHandlerArgs>,\n): { req: Request; env: Record<string, string | undefined> } => {\n  if (!Array.isArray(args) || args.length < 1) {\n    throw new Error(\"No arguments passed to serve handler\");\n  }\n\n  if (typeof args[0] === \"object\" && \"request\" in args[0] && \"env\" in args[0]) {\n    return {\n      req: args[0].request,\n      env: args[0].env,\n    };\n  }\n\n  if (args.length > 1 && typeof args[1] === \"object\") {\n    return {\n      req: args[0],\n      env: args[1],\n    };\n  }\n\n  throw new Error(\n    \"Could not derive handler arguments from input; are you sure you're using serve() correctly?\",\n  );\n};\n\n/**\n * In Cloudflare, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * @example Cloudflare Pages\n * ```ts\n * import { serve } from \"inngest/cloudflare\";\n * import { inngest } from \"../../inngest/client\";\n * import fnA from \"../../inngest/fnA\"; // Your own function\n *\n * export const onRequest = serve({\n *   client: inngest,\n *   functions: [fnA],\n * });\n * ```\n *\n * @example Cloudflare Workers\n * ```ts\n * import { serve } from \"inngest/cloudflare\";\n * import { inngest } from \"../../inngest/client\";\n * import fnA from \"../../inngest/fnA\"; // Your own function\n *\n * export default {\n *   fetch: serve({\n *     client: inngest,\n *     functions: [fnA],\n *   }),\n * };\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nexport const serve = (\n  options: ServeHandlerOptions,\n): ((\n  ...args: Either<PagesHandlerArgs, WorkersHandlerArgs>\n) => Promise<Response>) => {\n  const handler = new InngestCommHandler({\n    frameworkName,\n\n    /**\n     * Assume that we want to override the `fetch` implementation with the one\n     * globally available in the Cloudflare env. Specifying it here will\n     * ensure we avoid trying to load a Node-compatible version later.\n     */\n    fetch: fetch.bind(globalThis),\n    ...options,\n    handler: (...args: Either<PagesHandlerArgs, WorkersHandlerArgs>) => {\n      const { req, env } = deriveHandlerArgs(args);\n\n      return {\n        body: () => req.json(),\n        headers: (key) => req.headers.get(key),\n        method: () => req.method,\n        env: () => env,\n        url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n        transformResponse: ({ body, status, headers }) => {\n          return new Response(body, {\n            status,\n            headers,\n          });\n        },\n        transformStreamingResponse: ({ body, status, headers }) => {\n          return new Response(body, {\n            status,\n            headers,\n          });\n        },\n      };\n    },\n  });\n\n  /**\n   * Assign a non-variadic length to the handler to ensure early runtime guards\n   * aren't triggered when assessing whether exported functions are valid within\n   * the framework.\n   */\n  const requestHandler = Object.defineProperties(handler.createHandler(), {\n    length: { value: 2 },\n  });\n\n  return requestHandler;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,MAAaA,gBAAwC;;;;;AAkBrD,MAAM,qBACJ,SAC8D;AAC9D,KAAI,CAAC,MAAM,QAAQ,KAAK,IAAI,KAAK,SAAS,EACxC,OAAM,IAAI,MAAM,uCAAuC;AAGzD,KAAI,OAAO,KAAK,OAAO,YAAY,aAAa,KAAK,MAAM,SAAS,KAAK,GACvE,QAAO;EACL,KAAK,KAAK,GAAG;EACb,KAAK,KAAK,GAAG;EACd;AAGH,KAAI,KAAK,SAAS,KAAK,OAAO,KAAK,OAAO,SACxC,QAAO;EACL,KAAK,KAAK;EACV,KAAK,KAAK;EACX;AAGH,OAAM,IAAI,MACR,8FACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCH,MAAa,SACX,YAGyB;CACzB,MAAM,UAAU,IAAI,mBAAmB;EACrC;EAOA,OAAO,MAAM,KAAK,WAAW;EAC7B,GAAG;EACH,UAAU,GAAG,SAAuD;GAClE,MAAM,EAAE,KAAK,QAAQ,kBAAkB,KAAK;AAE5C,UAAO;IACL,YAAY,IAAI,MAAM;IACtB,UAAU,QAAQ,IAAI,QAAQ,IAAI,IAAI;IACtC,cAAc,IAAI;IAClB,WAAW;IACX,WAAW,IAAI,IAAI,IAAI,KAAK,WAAW,IAAI,QAAQ,IAAI,OAAO,IAAI,KAAK;IACvE,oBAAoB,EAAE,MAAM,QAAQ,cAAc;AAChD,YAAO,IAAI,SAAS,MAAM;MACxB;MACA;MACD,CAAC;;IAEJ,6BAA6B,EAAE,MAAM,QAAQ,cAAc;AACzD,YAAO,IAAI,SAAS,MAAM;MACxB;MACA;MACD,CAAC;;IAEL;;EAEJ,CAAC;AAWF,QAJuB,OAAO,iBAAiB,QAAQ,eAAe,EAAE,EACtE,QAAQ,EAAE,OAAO,GAAG,EACrB,CAAC"}