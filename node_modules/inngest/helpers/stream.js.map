{"version":3,"file":"stream.js","names":["passFinalize: (value: (data: unknown) => void) => void"],"sources":["../../src/helpers/stream.ts"],"sourcesContent":["import { stringify } from \"./strings.ts\";\n\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nexport const createStream = (opts?: {\n  /**\n   * The interval in milliseconds to send a heartbeat.\n   *\n   * Defaults to `3000`.\n   */\n  interval?: number;\n\n  /**\n   * The value to send as a heartbeat.\n   *\n   * Defaults to `\" \"`.\n   */\n  value?: string;\n}): Promise<{ finalize: (data: unknown) => void; stream: ReadableStream }> => {\n  /**\n   * We need to resolve this promise with both the stream and the `finalize`\n   * function, but having them both instantiated synchronously is difficult, as\n   * we need access to the stream's internals too.\n   *\n   * We create this cheeky deferred promise to grab the internal `finalize`\n   * value. Be warned that simpler solutions may appear to compile, but fail at\n   * runtime due to variables not being assigned; make sure to test your code!\n   */\n  let passFinalize: (value: (data: unknown) => void) => void;\n\n  const finalizeP = new Promise<(data: unknown) => void>((resolve) => {\n    passFinalize = resolve;\n  });\n\n  const interval = opts?.interval ?? 3000;\n  const value = opts?.value ?? \" \";\n\n  return new Promise(async (resolve, reject) => {\n    try {\n      const stream = new ReadableStream({\n        start(controller) {\n          const encoder = new TextEncoder();\n\n          const heartbeat = setInterval(() => {\n            controller.enqueue(encoder.encode(value));\n          }, interval);\n\n          const finalize = (data: unknown) => {\n            clearInterval(heartbeat);\n\n            // `data` may be a `Promise`. If it is, we need to wait for it to\n            // resolve before sending it. To support this elegantly we'll always\n            // assume it's a promise and handle that case.\n            void Promise.resolve(data).then((resolvedData) => {\n              controller.enqueue(encoder.encode(stringify(resolvedData)));\n              controller.close();\n            });\n          };\n\n          passFinalize(finalize);\n        },\n      });\n\n      resolve({ stream, finalize: await finalizeP });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n"],"mappings":";;;;;;;;;;AASA,MAAa,gBAAgB,SAciD;;;;;;;;;;CAU5E,IAAIA;CAEJ,MAAM,YAAY,IAAI,SAAkC,YAAY;AAClE,iBAAe;GACf;CAEF,MAAM,WAAW,MAAM,YAAY;CACnC,MAAM,QAAQ,MAAM,SAAS;AAE7B,QAAO,IAAI,QAAQ,OAAO,SAAS,WAAW;AAC5C,MAAI;AAyBF,WAAQ;IAAE,QAxBK,IAAI,eAAe,EAChC,MAAM,YAAY;KAChB,MAAM,UAAU,IAAI,aAAa;KAEjC,MAAM,YAAY,kBAAkB;AAClC,iBAAW,QAAQ,QAAQ,OAAO,MAAM,CAAC;QACxC,SAAS;KAEZ,MAAM,YAAY,SAAkB;AAClC,oBAAc,UAAU;AAKxB,MAAK,QAAQ,QAAQ,KAAK,CAAC,MAAM,iBAAiB;AAChD,kBAAW,QAAQ,QAAQ,OAAO,UAAU,aAAa,CAAC,CAAC;AAC3D,kBAAW,OAAO;QAClB;;AAGJ,kBAAa,SAAS;OAEzB,CAAC;IAEgB,UAAU,MAAM;IAAW,CAAC;WACvC,KAAK;AACZ,UAAO,IAAI;;GAEb"}