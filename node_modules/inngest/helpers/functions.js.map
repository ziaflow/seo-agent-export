{"version":3,"file":"functions.js","names":["version: ExecutionVersion","err","why: string | undefined"],"sources":["../../src/helpers/functions.ts"],"sourcesContent":["import { ZodError, z } from \"zod/v3\";\nimport type { InngestApi } from \"../api/api.ts\";\nimport { stepsSchemas } from \"../api/schema.ts\";\nimport { PREFERRED_EXECUTION_VERSION } from \"../components/execution/InngestExecution.ts\";\nimport { err, ok, type Result } from \"../types.ts\";\nimport { ExecutionVersion } from \"./consts.ts\";\nimport { prettyError } from \"./errors.ts\";\nimport type { Await } from \"./types.ts\";\n\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const cacheFn = <T extends (...args: any[]) => any>(fn: T): T => {\n  const key = \"value\";\n  const cache = new Map<typeof key, unknown>();\n\n  return ((...args) => {\n    if (!cache.has(key)) {\n      cache.set(key, fn(...args));\n    }\n\n    return cache.get(key);\n  }) as T;\n};\n\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport const waterfall = <TFns extends ((arg?: any) => any)[]>(\n  fns: TFns,\n\n  /**\n   * A function that transforms the result of each function in the waterfall,\n   * ready for the next function.\n   *\n   * Will not be called on the final function.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  transform?: (prev: any, output: any) => any,\n): ((...args: Parameters<TFns[number]>) => Promise<Await<TFns[number]>>) => {\n  return (...args) => {\n    const chain = fns.reduce(async (acc, fn) => {\n      const prev = await acc;\n      const output = (await fn(prev)) as Promise<Await<TFns[number]>>;\n\n      if (transform) {\n        return await transform(prev, output);\n      }\n\n      if (typeof output === \"undefined\") {\n        return prev;\n      }\n\n      return output;\n    }, Promise.resolve(args[0]));\n\n    return chain;\n  };\n};\n\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nexport const undefinedToNull = (v: unknown) => {\n  const isUndefined = typeof v === \"undefined\";\n  return isUndefined ? null : v;\n};\n\nconst fnDataVersionSchema = z.object({\n  version: z\n    .literal(-1)\n    .or(z.literal(0))\n    .or(z.literal(1))\n    .or(z.literal(2))\n    .optional()\n    .transform<ExecutionVersion>((v) => {\n      if (typeof v === \"undefined\") {\n        console.debug(\n          `No request version specified by executor; defaulting to v${PREFERRED_EXECUTION_VERSION}`,\n        );\n\n        return PREFERRED_EXECUTION_VERSION;\n      }\n\n      return v === -1 ? PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\n\nexport const parseFnData = (data: unknown) => {\n  let version: ExecutionVersion;\n\n  try {\n    ({ version } = fnDataVersionSchema.parse(data));\n\n    const versionHandlers = {\n      [ExecutionVersion.V0]: () =>\n        ({\n          version: ExecutionVersion.V0,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V0],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  attempt: z.number().default(0),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n              use_api: z.boolean().default(false),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V1]: () =>\n        ({\n          version: ExecutionVersion.V1,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V1],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  fn_id: z.string().optional(),\n                  attempt: z.number().default(0),\n                  max_attempts: z.number().optional(),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  qi_id: z.string().optional(),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n\n      [ExecutionVersion.V2]: () =>\n        ({\n          version: ExecutionVersion.V2,\n          ...z\n            .object({\n              event: z.record(z.any()),\n              events: z.array(z.record(z.any())).default([]),\n              steps: stepsSchemas[ExecutionVersion.V2],\n              ctx: z\n                .object({\n                  run_id: z.string(),\n                  fn_id: z.string().optional(),\n                  attempt: z.number().default(0),\n                  max_attempts: z.number().optional(),\n                  disable_immediate_execution: z.boolean().default(false),\n                  use_api: z.boolean().default(false),\n                  qi_id: z.string().optional(),\n                  stack: z\n                    .object({\n                      stack: z\n                        .array(z.string())\n                        .nullable()\n                        .transform((v) => (Array.isArray(v) ? v : [])),\n                      current: z.number(),\n                    })\n                    .passthrough()\n                    .optional()\n                    .nullable(),\n                })\n                .optional()\n                .nullable(),\n            })\n            .parse(data),\n        }) as const,\n    } satisfies Record<ExecutionVersion, () => unknown>;\n\n    return versionHandlers[version]();\n  } catch (err) {\n    throw new Error(parseFailureErr(err));\n  }\n};\nexport type FnData = ReturnType<typeof parseFnData>;\n\ntype ParseErr = string;\nexport const fetchAllFnData = async ({\n  data,\n  api,\n  version,\n}: {\n  data: FnData;\n  api: InngestApi;\n  version: ExecutionVersion;\n}): Promise<Result<FnData, ParseErr>> => {\n  const result = { ...data };\n\n  try {\n    if (\n      (result.version === ExecutionVersion.V0 && result.use_api) ||\n      (result.version === ExecutionVersion.V1 && result.ctx?.use_api)\n    ) {\n      if (!result.ctx?.run_id) {\n        return err(\n          prettyError({\n            whatHappened: \"failed to attempt retrieving data from API\",\n            consequences: \"function execution can't continue\",\n            why: \"run_id is missing from context\",\n            stack: true,\n          }),\n        );\n      }\n\n      const [evtResp, stepResp] = await Promise.all([\n        api.getRunBatch(result.ctx.run_id),\n        api.getRunSteps(result.ctx.run_id, version),\n      ]);\n\n      if (evtResp.ok) {\n        result.events = evtResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve list of events\",\n            consequences: \"function execution can't continue\",\n            why: evtResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n\n      if (stepResp.ok) {\n        result.steps = stepResp.value;\n      } else {\n        return err(\n          prettyError({\n            whatHappened: \"failed to retrieve steps for function run\",\n            consequences: \"function execution can't continue\",\n            why: stepResp.error?.error,\n            stack: true,\n          }),\n        );\n      }\n    }\n\n    // If we don't have a stack here, we need to at least set something.\n    // TODO We should be passed this by the steps API.\n    const stepIds = Object.keys(result.steps || {});\n    if (stepIds.length && !result.ctx?.stack?.length) {\n      result.ctx = {\n        ...(result.ctx as NonNullable<typeof result.ctx>),\n        stack: {\n          stack: stepIds,\n          current: stepIds.length - 1,\n        },\n      };\n    }\n\n    return ok(result);\n  } catch (error) {\n    // print it out for now.\n    // move to something like protobuf so we don't have to deal with this\n    console.error(error);\n\n    return err(parseFailureErr(error));\n  }\n};\n\nconst parseFailureErr = (err: unknown) => {\n  let why: string | undefined;\n  if (err instanceof ZodError) {\n    why = err.toString();\n  }\n\n  return prettyError({\n    whatHappened: \"Failed to parse data from executor.\",\n    consequences: \"Function execution can't continue.\",\n    toFixNow:\n      \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n    stack: true,\n    why,\n  });\n};\n"],"mappings":"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"}