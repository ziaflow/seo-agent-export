{"version":3,"file":"Inngest.js","names":["headers: Record<string, string>","payloads: EventPayload[]","rawBody: unknown","body: SendEventResponse | undefined","providedLogger: Logger"],"sources":["../../src/components/Inngest.ts"],"sourcesContent":["import { InngestApi } from \"../api/api.ts\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  dummyEventKey,\n  envKeys,\n  headerKeys,\n  logPrefix,\n} from \"../helpers/consts.ts\";\nimport { createEntropy } from \"../helpers/crypto.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport {\n  allProcessEnv,\n  getFetch,\n  getMode,\n  inngestHeaders,\n  type Mode,\n  processEnv,\n} from \"../helpers/env.ts\";\nimport { fixEventKeyMissingSteps, prettyError } from \"../helpers/errors.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { retryWithBackoff } from \"../helpers/promises.ts\";\nimport { stringify } from \"../helpers/strings.ts\";\nimport type {\n  AsArray,\n  IsNever,\n  SendEventPayload,\n  SimplifyDeep,\n  SingleOrArray,\n  WithoutInternal,\n} from \"../helpers/types.ts\";\nimport {\n  DefaultLogger,\n  type Logger,\n  ProxyLogger,\n} from \"../middleware/logger.ts\";\nimport {\n  type ClientOptions,\n  type EventNameFromTrigger,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  type InvokeTargetFunctionDefinition,\n  type SendEventOutput,\n  type SendEventResponse,\n  sendEventResponseSchema,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { EventSchemas } from \"./EventSchemas.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport type { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\nimport {\n  type ExtendWithMiddleware,\n  getHookStack,\n  InngestMiddleware,\n  type MiddlewareRegisterFn,\n  type MiddlewareRegisterReturn,\n  type SendEventHookStack,\n} from \"./InngestMiddleware.ts\";\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * Given a set of client options for Inngest, return the event types that can\n * be sent or received.\n *\n * @public\n */\nexport type EventsFromOpts<TOpts extends ClientOptions> =\n  TOpts[\"schemas\"] extends EventSchemas<infer U>\n    ? U\n    : Record<string, EventPayload>;\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport class Inngest<TClientOpts extends ClientOptions = ClientOptions>\n  implements Inngest.Like\n{\n  get [Symbol.toStringTag](): typeof Inngest.Tag {\n    return Inngest.Tag;\n  }\n\n  /**\n   * The ID of this instance, most commonly a reference to the application it\n   * resides in.\n   *\n   * The ID of your client should remain the same for its lifetime; if you'd\n   * like to change the name of your client as it appears in the Inngest UI,\n   * change the `name` property instead.\n   */\n  public readonly id: string;\n\n  /**\n   * Stores the options so we can remember explicit settings the user has\n   * provided.\n   */\n  private readonly options: TClientOpts;\n\n  /**\n   * Inngest event key, used to send events to Inngest Cloud.\n   */\n  private eventKey = \"\";\n\n  private _apiBaseUrl: string | undefined;\n  private _eventBaseUrl: string | undefined;\n\n  private readonly inngestApi: InngestApi;\n\n  /**\n   * The absolute URL of the Inngest Cloud API.\n   */\n  private sendEventUrl: URL = new URL(\n    `e/${this.eventKey}`,\n    defaultInngestEventBaseUrl,\n  );\n\n  private headers!: Record<string, string>;\n\n  private readonly fetch: FetchT;\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private readonly logger: Logger;\n\n  private localFns: InngestFunction.Any[] = [];\n\n  /**\n   * A promise that resolves when the middleware stack has been initialized and\n   * the client is ready to be used.\n   */\n  private readonly middleware: Promise<MiddlewareRegisterReturn[]>;\n\n  /**\n   * Whether the client is running in a production environment. This can\n   * sometimes be `undefined` if the client has expressed no preference or\n   * perhaps environment variables are only available at a later stage in the\n   * runtime, for example when receiving a request.\n   *\n   * An {@link InngestCommHandler} should prioritize this value over all other\n   * settings, but should still check for the presence of an environment\n   * variable if it is not set.\n   */\n  private _mode!: Mode;\n\n  protected readonly schemas?: NonNullable<TClientOpts[\"schemas\"]>;\n\n  private _appVersion: string | undefined;\n\n  get apiBaseUrl(): string | undefined {\n    return this._apiBaseUrl;\n  }\n\n  get eventBaseUrl(): string | undefined {\n    return this._eventBaseUrl;\n  }\n\n  get env(): string | null {\n    return this.headers[headerKeys.Environment] ?? null;\n  }\n\n  get appVersion(): string | undefined {\n    return this._appVersion;\n  }\n\n  /**\n   * A client used to interact with the Inngest API by sending or reacting to\n   * events.\n   *\n   * To provide event typing, see {@link EventSchemas}.\n   *\n   * ```ts\n   * const inngest = new Inngest({ name: \"My App\" });\n   *\n   * // or to provide event typing too\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"app/user.created\": {\n   *       data: { userId: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  constructor(options: TClientOpts) {\n    this.options = options;\n\n    const {\n      id,\n      fetch,\n      logger = new DefaultLogger(),\n      middleware,\n      isDev,\n      schemas,\n      appVersion,\n    } = this.options;\n\n    if (!id) {\n      // TODO PrettyError\n      throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n    }\n\n    this.id = id;\n\n    this._mode = getMode({\n      explicitMode:\n        typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n    });\n\n    this.fetch = getFetch(fetch);\n\n    this.inngestApi = new InngestApi({\n      baseUrl: this.apiBaseUrl,\n      signingKey: processEnv(envKeys.InngestSigningKey) || \"\",\n      signingKeyFallback: processEnv(envKeys.InngestSigningKeyFallback),\n      fetch: this.fetch,\n      mode: this.mode,\n    });\n\n    this.schemas = schemas;\n    this.loadModeEnvVars();\n\n    this.logger = logger;\n\n    this.middleware = this.initializeMiddleware([\n      ...builtInMiddleware,\n      ...(middleware || []),\n    ]);\n\n    this._appVersion = appVersion;\n  }\n\n  /**\n   * Returns a `Promise` that resolves when the app is ready and all middleware\n   * has been initialized.\n   */\n  public get ready(): Promise<void> {\n    return this.middleware.then(() => {});\n  }\n\n  /**\n   * Set the environment variables for this client. This is useful if you are\n   * passed environment variables at runtime instead of as globals and need to\n   * update the client with those values as requests come in.\n   */\n  public setEnvVars(\n    env: Record<string, string | undefined> = allProcessEnv(),\n  ): this {\n    this.mode = getMode({ env, client: this });\n\n    return this;\n  }\n\n  private loadModeEnvVars(): void {\n    this._apiBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestApiBaseUrl);\n\n    this._eventBaseUrl =\n      this.options.baseUrl ||\n      this.mode[\"env\"][envKeys.InngestEventApiBaseUrl] ||\n      this.mode[\"env\"][envKeys.InngestBaseUrl] ||\n      this.mode.getExplicitUrl(defaultInngestEventBaseUrl);\n\n    this.setEventKey(\n      this.options.eventKey || this.mode[\"env\"][envKeys.InngestEventKey] || \"\",\n    );\n\n    this.headers = inngestHeaders({\n      inngestEnv: this.options.env,\n      env: this.mode[\"env\"],\n    });\n\n    this.inngestApi[\"mode\"] = this.mode;\n    this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n  }\n\n  /**\n   * Initialize all passed middleware, running the `register` function on each\n   * in sequence and returning the requested hook registrations.\n   */\n  private async initializeMiddleware(\n    middleware: InngestMiddleware.Like[] = [],\n    opts?: {\n      registerInput?: Omit<Parameters<MiddlewareRegisterFn>[0], \"client\">;\n      prefixStack?: Promise<MiddlewareRegisterReturn[]>;\n    },\n  ): Promise<MiddlewareRegisterReturn[]> {\n    /**\n     * Wait for the prefix stack to run first; do not trigger ours before this\n     * is complete.\n     */\n    const prefix = await (opts?.prefixStack ?? []);\n\n    const stack = middleware.reduce<Promise<MiddlewareRegisterReturn[]>>(\n      async (acc, m) => {\n        // Be explicit about waiting for the previous middleware to finish\n        const prev = await acc;\n        const next = await (m as InngestMiddleware.Any).init({\n          client: this,\n          ...opts?.registerInput,\n        });\n\n        return [...prev, next];\n      },\n      Promise.resolve([]),\n    );\n\n    return [...prefix, ...(await stack)];\n  }\n\n  private get mode(): Mode {\n    return this._mode;\n  }\n\n  private set mode(m) {\n    this._mode = m;\n    this.loadModeEnvVars();\n  }\n\n  /**\n   * Given a response from Inngest, relay the error to the caller.\n   */\n  private async getResponseError(\n    response: globalThis.Response,\n    rawBody: unknown,\n    foundErr = \"Unknown error\",\n  ): Promise<Error> {\n    let errorMessage = foundErr;\n\n    if (errorMessage === \"Unknown error\") {\n      switch (response.status) {\n        case 401:\n          errorMessage = \"Event key Not Found\";\n          break;\n        case 400:\n          errorMessage = \"Cannot process event payload\";\n          break;\n        case 403:\n          errorMessage = \"Forbidden\";\n          break;\n        case 404:\n          errorMessage = \"Event key not found\";\n          break;\n        case 406:\n          errorMessage = `${JSON.stringify(await rawBody)}`;\n          break;\n        case 409:\n        case 412:\n          errorMessage = \"Event transformation failed\";\n          break;\n        case 413:\n          errorMessage = \"Event payload too large\";\n          break;\n        case 500:\n          errorMessage = \"Internal server error\";\n          break;\n        default:\n          try {\n            errorMessage = await response.text();\n          } catch (_err) {\n            errorMessage = `${JSON.stringify(await rawBody)}`;\n          }\n          break;\n      }\n    }\n\n    return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n  }\n\n  /**\n   * Set the event key for this instance of Inngest. This is useful if for some\n   * reason the key is not available at time of instantiation or present in the\n   * `INNGEST_EVENT_KEY` environment variable.\n   */\n  public setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey: string,\n  ): void {\n    this.eventKey = eventKey || dummyEventKey;\n\n    this.sendEventUrl = new URL(\n      `e/${this.eventKey}`,\n      this.eventBaseUrl || defaultInngestEventBaseUrl,\n    );\n  }\n\n  private eventKeySet(): boolean {\n    return Boolean(this.eventKey) && this.eventKey !== dummyEventKey;\n  }\n\n  /**\n   * EXPERIMENTAL: This API is not yet stable and may change in the future\n   * without a major version bump.\n   *\n   * Send a Signal to Inngest.\n   */\n  public async sendSignal({\n    signal,\n    data,\n    env,\n  }: {\n    /**\n     * The signal to send.\n     */\n    signal: string;\n\n    /**\n     * The data to send with the signal.\n     */\n    data?: unknown;\n\n    /**\n     * The Inngest environment to send the signal to. Defaults to whichever\n     * environment this client's key is associated with.\n     *\n     * It's like you never need to change this unless you're trying to sync\n     * multiple systems together using branch names.\n     */\n    env?: string;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const headers: Record<string, string> = {\n      ...(env ? { [headerKeys.Environment]: env } : {}),\n    };\n\n    return this._sendSignal({ signal, data, headers });\n  }\n\n  private async _sendSignal({\n    signal,\n    data,\n    headers,\n  }: {\n    signal: string;\n    data?: unknown;\n    headers?: Record<string, string>;\n  }): Promise<InngestApi.SendSignalResponse> {\n    const res = await this.inngestApi.sendSignal(\n      { signal, data },\n      { ...this.headers, ...headers },\n    );\n    if (res.ok) {\n      return res.value;\n    }\n\n    throw new Error(\n      `Failed to send signal: ${res.error?.error || \"Unknown error\"}`,\n    );\n  }\n\n  /**\n   * Send one or many events to Inngest. Takes an entire payload (including\n   * name) as each input.\n   *\n   * ```ts\n   * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n   * ```\n   *\n   * Returns a promise that will resolve if the event(s) were sent successfully,\n   * else throws with an error explaining what went wrong.\n   *\n   * If you wish to send an event with custom types (i.e. one that hasn't been\n   * generated), make sure to add it when creating your Inngest instance, like\n   * so:\n   *\n   * ```ts\n   * const inngest = new Inngest({\n   *   name: \"My App\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"my/event\": {\n   *       name: \"my/event\";\n   *       data: { bar: string };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  public async send<Payload extends SendEventPayload<GetEvents<this>>>(\n    payload: Payload,\n    options?: {\n      /**\n       * The Inngest environment to send events to. Defaults to whichever\n       * environment this client's event key is associated with.\n       *\n       * It's likely you never need to change this unless you're trying to sync\n       * multiple systems together using branch names.\n       */\n      env?: string;\n    },\n  ): Promise<SendEventOutput<TClientOpts>> {\n    const headers: Record<string, string> = {\n      ...(options?.env ? { [headerKeys.Environment]: options.env } : {}),\n    };\n\n    return this._send({ payload, headers });\n  }\n\n  /**\n   * Internal method for sending an event, used to allow Inngest internals to\n   * further customize the request sent to an Inngest Server.\n   */\n  private async _send<Payload extends SendEventPayload<GetEvents<this>>>({\n    payload,\n    headers,\n  }: {\n    payload: Payload;\n    headers?: Record<string, string>;\n  }): Promise<SendEventOutput<TClientOpts>> {\n    const nowMillis = new Date().getTime();\n\n    let maxAttempts = 5;\n\n    // Attempt to set the event ID seed header. If it fails then disable retries\n    // (but we still want to send the event).\n    try {\n      const entropy = createEntropy(10);\n      const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n      headers = {\n        ...headers,\n        [headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}`,\n      };\n    } catch (err) {\n      let message = \"Event-sending retries disabled\";\n      if (err instanceof Error) {\n        message += `: ${err.message}`;\n      }\n\n      console.debug(message);\n\n      // Disable retries.\n      maxAttempts = 1;\n    }\n\n    const hooks = await getHookStack(\n      this.middleware,\n      \"onSendEvent\",\n      undefined,\n      {\n        transformInput: (prev, output) => {\n          return { ...prev, ...output };\n        },\n        transformOutput(prev, output) {\n          return {\n            result: { ...prev.result, ...output?.result },\n          };\n        },\n      },\n    );\n\n    let payloads: EventPayload[] = Array.isArray(payload)\n      ? (payload as EventPayload[])\n      : payload\n        ? ([payload] as [EventPayload])\n        : [];\n\n    const inputChanges = await hooks.transformInput?.({\n      payloads: [...payloads],\n    });\n    if (inputChanges?.payloads) {\n      payloads = [...inputChanges.payloads];\n    }\n\n    // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n    // filled by the event server so is safe, and adding here fixes Next.js\n    // server action cache issues.\n    payloads = payloads.map((p) => {\n      return {\n        ...p,\n        // Always generate an idempotency ID for an event for retries\n        id: p.id,\n        ts: p.ts || nowMillis,\n        data: p.data || {},\n      };\n    });\n\n    const applyHookToOutput = async (\n      arg: Parameters<NonNullable<SendEventHookStack[\"transformOutput\"]>>[0],\n    ): Promise<SendEventOutput<TClientOpts>> => {\n      const hookOutput = await hooks.transformOutput?.(arg);\n      return {\n        ...arg.result,\n        ...hookOutput?.result,\n        // ðŸ¤®\n      } as unknown as SendEventOutput<TClientOpts>;\n    };\n\n    /**\n     * It can be valid for a user to send an empty list of events; if this\n     * happens, show a warning that this may not be intended, but don't throw.\n     */\n    if (!payloads.length) {\n      console.warn(\n        prettyError({\n          type: \"warn\",\n          whatHappened: \"`inngest.send()` called with no events\",\n          reassurance:\n            \"This is not an error, but you may not have intended to do this.\",\n          consequences:\n            \"The returned promise will resolve, but no events have been sent to Inngest.\",\n          stack: true,\n        }),\n      );\n\n      return await applyHookToOutput({ result: { ids: [] } });\n    }\n\n    // When sending events, check if the dev server is available.  If so, use the\n    // dev server.\n    let url = this.sendEventUrl.href;\n\n    /**\n     * If in prod mode and key is not present, fail now.\n     */\n    if (this.mode.isCloud && !this.eventKeySet()) {\n      throw new Error(\n        prettyError({\n          whatHappened: \"Failed to send event\",\n          consequences: \"Your event or events were not sent to Inngest.\",\n          why: \"We couldn't find an event key to use to send events to Inngest.\",\n          toFixNow: fixEventKeyMissingSteps,\n        }),\n      );\n    }\n\n    /**\n     * If dev mode has been inferred, try to hit the dev server first to see if\n     * it exists. If it does, use it, otherwise fall back to whatever server we\n     * have configured.\n     *\n     * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n     * user has set this it means they have already chosen a URL to hit.\n     */\n    if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = devServerUrl(defaultDevServerHost, `e/${this.eventKey}`).href;\n      }\n    }\n\n    const body = await retryWithBackoff(\n      async () => {\n        let rawBody: unknown;\n        let body: SendEventResponse | undefined;\n\n        // We don't need to do fallback auth here because this uses event keys and\n        // not signing keys\n        const response = await this.fetch(url, {\n          method: \"POST\",\n          body: stringify(payloads),\n          headers: { ...this.headers, ...headers },\n        });\n\n        try {\n          rawBody = await response.json();\n          body = await sendEventResponseSchema.parseAsync(rawBody);\n        } catch (_err) {\n          throw await this.getResponseError(response, rawBody);\n        }\n\n        if (body.status !== 200 || body.error) {\n          throw await this.getResponseError(response, rawBody, body.error);\n        }\n\n        return body;\n      },\n      {\n        maxAttempts,\n        baseDelay: 100,\n      },\n    );\n\n    return await applyHookToOutput({ result: { ids: body.ids } });\n  }\n\n  public createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const fn = this._createFunction(rawOptions, rawTrigger, handler);\n\n    this.localFns.push(fn);\n\n    return fn;\n  };\n\n  public get funcs() {\n    return this.localFns;\n  }\n\n  private _createFunction: Inngest.CreateFunction<this> = (\n    rawOptions,\n    rawTrigger,\n    handler,\n  ) => {\n    const options = this.sanitizeOptions(rawOptions);\n    const triggers = this.sanitizeTriggers(rawTrigger);\n\n    return new InngestFunction(\n      this,\n      {\n        ...options,\n        triggers,\n      },\n      handler,\n    );\n  };\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeOptions<T extends InngestFunction.Options>(options: T): T {\n    if (Object.hasOwn(options, \"fns\")) {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    if (typeof options === \"string\") {\n      // v2 -> v3 runtime migraton warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return { id: options as string } as T;\n    }\n\n    return options;\n  }\n\n  /**\n   * Runtime-only validation.\n   */\n  private sanitizeTriggers<\n    T extends SingleOrArray<InngestFunction.Trigger<string>>,\n  >(triggers: T): AsArray<T> {\n    if (typeof triggers === \"string\") {\n      // v2 -> v3 migration warning\n      console.warn(\n        `${logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n\n      return [{ event: triggers as string }] as AsArray<T>;\n    }\n\n    if (!Array.isArray(triggers)) {\n      return [triggers] as AsArray<T>;\n    }\n\n    return triggers as AsArray<T>;\n  }\n}\n\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexport const builtInMiddleware = (<T extends InngestMiddleware.Stack>(\n  m: T,\n): T => m)([\n  new InngestMiddleware({\n    name: \"Inngest: Logger\",\n    init({ client }) {\n      return {\n        onFunctionRun(arg) {\n          const { ctx } = arg;\n\n          const metadata = {\n            runID: ctx.runId,\n            eventName: ctx.event.name,\n            functionName: arg.fn.name,\n          };\n\n          let providedLogger: Logger = client[\"logger\"];\n          // create a child logger if the provided logger has child logger implementation\n          try {\n            if (\"child\" in providedLogger) {\n              type ChildLoggerFn = (\n                metadata: Record<string, unknown>,\n              ) => Logger;\n              providedLogger = (providedLogger.child as ChildLoggerFn)(\n                metadata,\n              );\n            }\n          } catch (err) {\n            console.error('failed to create \"childLogger\" with error: ', err);\n            // no-op\n          }\n          const logger = new ProxyLogger(providedLogger);\n\n          return {\n            transformInput() {\n              return {\n                ctx: {\n                  /**\n                   * The passed in logger from the user.\n                   * Defaults to a console logger if not provided.\n                   */\n                  logger: logger as Logger,\n                },\n              };\n            },\n            beforeExecution() {\n              logger.enable();\n            },\n            transformOutput({ result: { error } }) {\n              if (error) {\n                logger.error(error);\n              }\n            },\n            async beforeResponse() {\n              await logger.flush();\n            },\n          };\n        },\n      };\n    },\n  }),\n]);\n\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ name: \"My App\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   name: \"My App\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nexport namespace Inngest {\n  export const Tag = \"Inngest.App\" as const;\n\n  /**\n   * Represents any `Inngest` instance, regardless of generics and inference.\n   *\n   * Prefer use of `Inngest.Like` where possible to ensure compatibility with\n   * multiple versions.\n   */\n  export type Any = Inngest;\n\n  /**\n   * References any `Inngest` instance across library versions, useful for use\n   * in public APIs to ensure compatibility with multiple versions.\n   *\n   * Prefer use of `Inngest.Any` internally and `Inngest.Like` for public APIs.\n   */\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof Inngest.Tag;\n  }\n\n  export type CreateFunction<TClient extends Inngest.Any> = <\n    TMiddleware extends InngestMiddleware.Stack,\n    TTrigger extends SingleOrArray<\n      InngestFunction.Trigger<TriggersFromClient<TClient>>\n    >,\n    THandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ]\n      >\n    >,\n    TFailureHandler extends Handler.Any = Handler<\n      TClient,\n      EventNameFromTrigger<GetEvents<TClient, true>, AsArray<TTrigger>[number]>,\n      ExtendWithMiddleware<\n        [\n          typeof builtInMiddleware,\n          NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n          TMiddleware,\n        ],\n        FailureEventArgs<\n          GetEvents<TClient, true>[EventNameFromTrigger<\n            GetEvents<TClient, true>,\n            AsArray<TTrigger>[number]\n          >]\n        >\n      >\n    >,\n  >(\n    options: Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    trigger: TTrigger,\n    handler: THandler,\n  ) => InngestFunction<\n    Omit<\n      InngestFunction.Options<\n        TClient,\n        TMiddleware,\n        AsArray<TTrigger>,\n        TFailureHandler\n      >,\n      \"triggers\"\n    >,\n    THandler,\n    TFailureHandler,\n    TClient,\n    TMiddleware,\n    AsArray<TTrigger>\n  >;\n}\n\n/**\n * A helper type to extract the type of a set of event tooling from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic step tools for an Inngest instance.\n * ```ts\n * type StepTools = GetStepTools<typeof inngest>;\n * ```\n *\n * @example Get step tools with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type StepTools = GetStepTools<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetStepTools<\n  TInngest extends Inngest.Any,\n  TTrigger extends keyof GetEvents<TInngest> &\n    string = keyof GetEvents<TInngest> & string,\n> = GetFunctionInput<TInngest, TTrigger> extends { step: infer TStep }\n  ? TStep\n  : never;\n\n/**\n * A helper type to extract the type of the input to a function from a given\n * Inngest instance and optionally a trigger.\n *\n * @example Get generic function input for an Inngest instance.\n * ```ts\n * type Input = GetFunctionInput<typeof inngest>;\n * ```\n *\n * @example Get function input with a trigger, ensuring tools like `waitForEvent` are typed.\n * ```ts\n * type Input = GetFunctionInput<typeof Inngest, \"github/pull_request\">;\n * ```\n *\n * @public\n */\nexport type GetFunctionInput<\n  TClient extends Inngest.Any,\n  TTrigger extends TriggersFromClient<TClient> = TriggersFromClient<TClient>,\n> = Parameters<\n  // Handler<\n  //   ClientOptionsFromInngest<TInngest>,\n  //   GetEvents<TInngest, true>,\n  //   TTrigger,\n  //   ExtendWithMiddleware<\n  //     [\n  //       typeof builtInMiddleware,\n  //       NonNullable<ClientOptionsFromInngest<TInngest>[\"middleware\"]>,\n  //     ]\n  //   >\n  // >\n  Handler<\n    TClient,\n    TTrigger,\n    ExtendWithMiddleware<\n      [\n        typeof builtInMiddleware,\n        NonNullable<ClientOptionsFromInngest<TClient>[\"middleware\"]>,\n      ]\n    >\n  >\n>[0];\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * @example Get a function's output\n * ```ts\n * type Output = GetFunctionOutput<typeof myFunction>;\n * ```\n *\n * @public\n */\nexport type GetFunctionOutput<\n  TFunction extends InvokeTargetFunctionDefinition,\n> = TFunction extends InngestFunction.Any\n  ? GetFunctionOutputFromInngestFunction<TFunction>\n  : TFunction extends InngestFunctionReference.Any\n    ? GetFunctionOutputFromReferenceInngestFunction<TFunction>\n    : unknown;\n\n/**\n * A helper type to extract the type of the output of an Inngest function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromInngestFunction<\n  TFunction extends InngestFunction.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunction<any, infer IHandler, any, any, any, any>\n  ? IsNever<SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<Awaited<ReturnType<IHandler>>>>\n  : unknown;\n\n/**\n * A helper type to extract the type of the output of a referenced Inngest\n * function.\n *\n * Used internally for {@link GetFunctionOutput}. Code outside of this package\n * should use {@link GetFunctionOutput} instead.\n *\n * @internal\n */\nexport type GetFunctionOutputFromReferenceInngestFunction<\n  TFunction extends InngestFunctionReference.Any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n> = TFunction extends InngestFunctionReference<any, infer IOutput>\n  ? IsNever<SimplifyDeep<Jsonify<IOutput>>> extends true\n    ? null\n    : SimplifyDeep<Jsonify<IOutput>>\n  : unknown;\n\n/**\n * When passed an Inngest client, will return all event types for that client.\n *\n * It's recommended to use this instead of directly reusing your event types, as\n * Inngest will add extra properties and internal events such as `ts` and\n * `inngest/function.finished`.\n *\n * @example\n * ```ts\n * import { EventSchemas, Inngest, type GetEvents } from \"inngest\";\n *\n * export const inngest = new Inngest({\n *   id: \"example-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": { data: { userId: string } };\n *   }>(),\n * });\n *\n * type Events = GetEvents<typeof inngest>;\n * type AppUserCreated = Events[\"app/user.created\"];\n *\n * ```\n *\n * @public\n */\nexport type GetEvents<\n  TInngest extends Inngest.Any,\n  TWithInternal extends boolean = false,\n> = TWithInternal extends true\n  ? EventsFromOpts<ClientOptionsFromInngest<TInngest>>\n  : WithoutInternal<EventsFromOpts<ClientOptionsFromInngest<TInngest>>>;\n\n/**\n * A helper type to extract the inferred options from a given Inngest instance.\n *\n * @example\n * ```ts\n * type Options = ClientOptionsFromInngest<typeof inngest>;\n * ```\n *\n * @public\n */\n\nexport type ClientOptionsFromInngest<TInngest extends Inngest.Any> =\n  TInngest extends Inngest<infer U> ? U : ClientOptions;\n"],"mappings":"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"}