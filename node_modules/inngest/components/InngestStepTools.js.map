{"version":3,"file":"InngestStepTools.js","names":["opts: HashedOp[\"opts\"]","matchOpts: { timeout: string; if?: string }","msTimeStr: string","Temporal.isTemporalDuration","Temporal.getISOString","opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      }","stepFetch","headers: Record<string, string>","step: GenericStepTools"],"sources":["../../src/components/InngestStepTools.ts"],"sourcesContent":["import { type AiAdapter, models } from \"@inngest/ai\";\nimport { z } from \"zod/v3\";\nimport { getAsyncCtx } from \"../experimental\";\nimport { logPrefix } from \"../helpers/consts.ts\";\nimport type { Jsonify } from \"../helpers/jsonify.ts\";\nimport { timeStr } from \"../helpers/strings.ts\";\nimport * as Temporal from \"../helpers/temporal.ts\";\nimport type {\n  ExclusiveKeys,\n  ParametersExceptFirst,\n  SendEventPayload,\n  SimplifyDeep,\n  WithoutInternalStr,\n} from \"../helpers/types.ts\";\nimport {\n  type EventPayload,\n  type HashedOp,\n  type InvocationResult,\n  type InvokeTargetFunctionDefinition,\n  type MinimalEventPayload,\n  type SendEventOutput,\n  StepMode,\n  StepOpCode,\n  type StepOptions,\n  type StepOptionsOrId,\n  type TriggerEventFromFunction,\n  type TriggersFromClient,\n} from \"../types.ts\";\nimport type { InngestExecution } from \"./execution/InngestExecution.ts\";\nimport { fetch as stepFetch } from \"./Fetch.ts\";\nimport type {\n  ClientOptionsFromInngest,\n  GetEvents,\n  GetFunctionOutput,\n  GetStepTools,\n  Inngest,\n} from \"./Inngest.ts\";\nimport { InngestFunction } from \"./InngestFunction.ts\";\nimport { InngestFunctionReference } from \"./InngestFunctionReference.ts\";\n\nexport interface FoundStep extends HashedOp {\n  hashedId: string;\n  fn?: (...args: unknown[]) => unknown;\n  rawArgs: unknown[];\n\n  /**\n   * A boolean representing whether the step has been fulfilled, either\n   * resolving or rejecting the `Promise` returned to userland code.\n   *\n   * Note that this is distinct from {@link hasStepState}, which instead tracks\n   * whether the step has been given some state from the Executor. State from\n   * the Executor could be data other than a resolution or rejection, such as\n   * inputs.\n   */\n  fulfilled: boolean;\n\n  /**\n   * A boolean representing whether the step has been given some state from the\n   * Executor. State from the Executor could be data other than a resolution or\n   * rejection, such as inputs.\n   *\n   * This is distinct from {@link fulfilled}, which instead tracks whether the\n   * step has been fulfilled, either resolving or rejecting the `Promise`\n   * returned to userland code.\n   */\n  hasStepState: boolean;\n\n  handled: boolean;\n\n  /**\n   * The promise that has been returned to userland code for this step.\n   */\n  promise: Promise<unknown>;\n\n  /**\n   * Returns a boolean representing whether or not the step was handled on this\n   * invocation.\n   */\n  handle: () => boolean;\n\n  // TODO This is used to track the input we want for this step. Might be\n  // present in ctx from Executor.\n  input?: unknown;\n}\n\nexport type MatchOpFn<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> = (\n  stepOptions: StepOptions,\n  /**\n   * Arguments passed by the user.\n   */\n  ...args: ParametersExceptFirst<T>\n) => Omit<HashedOp, \"data\" | \"error\">;\n\nexport type StepHandler = (info: {\n  matchOp: MatchOpFn;\n  opts?: StepToolOptions;\n  args: [StepOptionsOrId, ...unknown[]];\n}) => Promise<unknown>;\n\nexport interface StepToolOptions<\n  T extends (...args: unknown[]) => Promise<unknown> = (\n    ...args: unknown[]\n  ) => Promise<unknown>,\n> {\n  /**\n   * Optionally, we can also provide a function that will be called when\n   * Inngest tells us to run this operation.\n   *\n   * If this function is defined, the first time the tool is used it will\n   * report the desired operation (including options) to the Inngest. Inngest\n   * will then call back to the function to tell it to run the step and then\n   * retrieve data.\n   *\n   * We do this in order to allow functionality such as per-step retries; this\n   * gives the SDK the opportunity to tell Inngest what it wants to do before\n   * it does it.\n   *\n   * This function is passed the arguments passed by the user. It will be run\n   * when we receive an operation matching this one that does not contain a\n   * `data` property.\n   */\n  fn?: (...args: Parameters<T>) => unknown;\n}\n\nexport const getStepOptions = (options: StepOptionsOrId): StepOptions => {\n  if (typeof options === \"string\") {\n    return { id: options };\n  }\n\n  return options;\n};\n\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexport const STEP_INDEXING_SUFFIX = \":\";\n\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nexport const createStepTools = <TClient extends Inngest.Any>(\n  client: TClient,\n  execution: InngestExecution,\n  stepHandler: StepHandler,\n) => {\n  /**\n   * A local helper used to create tools that can be used to submit an op.\n   *\n   * When using this function, a generic type should be provided which is the\n   * function signature exposed to the user.\n   */\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  const createTool = <T extends (...args: any[]) => Promise<unknown>>(\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp: MatchOpFn<T>,\n    opts?: StepToolOptions<T>,\n  ): T => {\n    return (async (...args: Parameters<T>): Promise<unknown> => {\n      const parsedArgs = args as unknown as [StepOptionsOrId, ...unknown[]];\n      return stepHandler({ args: parsedArgs, matchOp, opts });\n    }) as T;\n  };\n\n  /**\n   * Create a new step run tool that can be used to run a step function using\n   * `step.run()` as a shim.\n   */\n  const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type?: string,\n  ) => {\n    return createTool<\n      // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n      <TFn extends (...args: any[]) => unknown>(\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The function to run when this step is executed. Can be synchronous or\n         * asynchronous.\n         *\n         * The return value of this function will be the return value of this\n         * call to `run`, meaning you can return and reason about return data\n         * for next steps.\n         */\n        fn: TFn,\n\n        /**\n         * Optional input to pass to the function. If this is specified, Inngest\n         * will keep track of the input for this step and be able to display it\n         * in the UI.\n         */\n        ...input: Parameters<TFn>\n      ) => Promise<\n        /**\n         * TODO Middleware can affect this. If run input middleware has returned\n         * new step data, do not Jsonify.\n         */\n        SimplifyDeep<\n          Jsonify<\n            TFn extends (...args: Parameters<TFn>) => Promise<infer U>\n              ? Awaited<U extends void ? null : U>\n              : ReturnType<TFn> extends void\n                ? null\n                : ReturnType<TFn>\n          >\n        >\n      >\n    >(\n      ({ id, name }, _fn, ...input) => {\n        const opts: HashedOp[\"opts\"] = {\n          ...(input.length ? { input } : {}),\n          ...(type ? { type } : {}),\n        };\n\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: id,\n          displayName: name ?? id,\n          ...(Object.keys(opts).length ? { opts } : {}),\n          userland: { id },\n        };\n      },\n      {\n        fn: (_, fn, ...input) => fn(...input),\n      },\n    );\n  };\n\n  /**\n   * Define the set of tools the user has access to for their step functions.\n   *\n   * Each key is the function name and is expected to run `createTool` and pass\n   * a generic type for that function as it will appear in the user's code.\n   */\n  const tools = {\n    /**\n     * Send one or many events to Inngest. Should always be used in place of\n     * `inngest.send()` to ensure that the event send is successfully retried\n     * and not sent multiple times due to memoisation.\n     *\n     * @example\n     * ```ts\n     * await step.sendEvent(\"emit-user-creation\", {\n     *   name: \"app/user.created\",\n     *   data: { id: 123 },\n     * });\n     *\n     * await step.sendEvent(\"emit-user-updates\", [\n     *   {\n     *     name: \"app/user.created\",\n     *     data: { id: 123 },\n     *   },\n     *   {\n     *     name: \"app/user.feed.created\",\n     *     data: { id: 123 },\n     *   },\n     * ]);\n     * ```\n     *\n     * Returns a promise that will resolve once the event has been sent.\n     */\n    sendEvent: createTool<\n      <Payload extends SendEventPayload<GetEvents<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        payload: Payload,\n      ) => Promise<SendEventOutput<ClientOptionsFromInngest<TClient>>>\n    >(\n      ({ id, name }) => {\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: \"sendEvent\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendEvent\",\n          },\n          userland: { id },\n        };\n      },\n      {\n        fn: (_idOrOptions, payload) => {\n          return client[\"_send\"]({\n            payload,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Wait for a particular signal to be received before continuing. When the\n     * signal is received, its data will be returned.\n     */\n    waitForSignal: createTool<\n      <TData>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForSignalOpts,\n      ) => Promise<{ signal: string; data: Jsonify<TData> } | null>\n    >(({ id, name }, opts) => {\n      // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n      // Temporal.ZonedDateTimeLike\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.WaitForSignal,\n        name: opts.signal,\n        displayName: name ?? id,\n        opts: {\n          signal: opts.signal,\n          timeout: timeStr(opts.timeout),\n          conflict: opts.onConflict,\n        },\n        userland: { id },\n      };\n    }),\n\n    /**\n     * Send a Signal to Inngest.\n     */\n    sendSignal: createTool<\n      (idOrOptions: StepOptionsOrId, opts: SendSignalOpts) => Promise<null>\n    >(\n      ({ id, name }, opts) => {\n        return {\n          id,\n          mode: StepMode.Sync,\n          op: StepOpCode.StepPlanned,\n          name: \"sendSignal\",\n          displayName: name ?? id,\n          opts: {\n            type: \"step.sendSignal\",\n            signal: opts.signal,\n          },\n          userland: { id },\n        };\n      },\n      {\n        fn: (_idOrOptions, opts) => {\n          return client[\"_sendSignal\"]({\n            signal: opts.signal,\n            data: opts.data,\n            headers: execution[\"options\"][\"headers\"],\n          });\n        },\n      },\n    ),\n\n    /**\n     * Wait for a particular event to be received before continuing. When the\n     * event is received, it will be returned.\n     *\n     * You can also provide options to control the particular event that is\n     * received, for example to ensure that a user ID matches between two\n     * events, or to only wait a maximum amount of time before giving up and\n     * returning `null` instead of any event data.\n     */\n    waitForEvent: createTool<\n      <IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>>(\n        idOrOptions: StepOptionsOrId,\n        opts: WaitForEventOpts<GetEvents<TClient, true>, IncomingEvent>,\n      ) => Promise<\n        IncomingEvent extends WithoutInternalStr<TriggersFromClient<TClient>>\n          ? GetEvents<TClient, false>[IncomingEvent] | null\n          : IncomingEvent | null\n      >\n    >(\n      (\n        { id, name },\n\n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts,\n      ) => {\n        const matchOpts: { timeout: string; if?: string } = {\n          timeout: timeStr(typeof opts === \"string\" ? opts : opts.timeout),\n        };\n\n        if (typeof opts !== \"string\") {\n          if (opts?.match) {\n            matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n          } else if (opts?.if) {\n            matchOpts.if = opts.if;\n          }\n        }\n\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.WaitForEvent,\n          name: opts.event,\n          opts: matchOpts,\n          displayName: name ?? id,\n          userland: { id },\n        };\n      },\n    ),\n\n    /**\n     * Use this tool to run business logic. Each call to `run` will be retried\n     * individually, meaning you can compose complex workflows that safely\n     * retry dependent asynchronous actions.\n     *\n     * The function you pass to `run` will be called only when this \"step\" is to\n     * be executed and can be synchronous or asynchronous.\n     *\n     * In either case, the return value of the function will be the return value\n     * of the `run` tool, meaning you can return and reason about return data\n     * for next steps.\n     */\n    run: createStepRun(),\n\n    /**\n     * AI tooling for running AI models and other AI-related tasks.\n     */\n    ai: {\n      /**\n       * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      infer: createTool<\n        <TAdapter extends AiAdapter>(\n          idOrOptions: StepOptionsOrId,\n          options: AiInferOpts<TAdapter>,\n        ) => Promise<AiAdapter.Output<TAdapter>>\n      >(({ id, name }, options) => {\n        // eslint-disable-next-line\n        const { model, body, ...rest } = options;\n\n        const modelCopy = { ...model };\n\n        // Allow the model to mutate options and body for this call\n        options.model.onCall?.(modelCopy, options.body);\n\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.AiGateway,\n          displayName: name ?? id,\n          opts: {\n            type: \"step.ai.infer\",\n            url: modelCopy.url,\n            headers: modelCopy.headers,\n            auth_key: modelCopy.authKey,\n            format: modelCopy.format,\n            // eslint-disable-next-line\n            body,\n            // eslint-disable-next-line\n            ...rest,\n          },\n          userland: { id },\n        };\n      }),\n\n      /**\n       * Use this tool to wrap AI models and other AI-related tasks. Each call\n       * to `wrap` will be retried individually, meaning you can compose complex\n       * workflows that safely retry dependent asynchronous actions.\n       *\n       * Input is also tracked for this tool, meaning you can pass input to the\n       * function and it will be displayed and editable in the UI.\n       */\n      wrap: createStepRun(\"step.ai.wrap\"),\n\n      /**\n       * Models for AI inference and other AI-related tasks.\n       */\n      models: {\n        ...models,\n      },\n    },\n\n    /**\n     * Wait a specified amount of time before continuing.\n     *\n     * The time to wait can be specified using a `number` of milliseconds or an\n     * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n     *\n     * {@link https://npm.im/ms}\n     *\n     * To wait until a particular date, use `sleepUntil` instead.\n     */\n    sleep: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The amount of time to wait before continuing.\n         */\n        time: number | string | Temporal.DurationLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      /**\n       * The presence of this operation in the returned stack indicates that the\n       * sleep is over and we should continue execution.\n       */\n      const msTimeStr: string = timeStr(\n        Temporal.isTemporalDuration(time)\n          ? time.total({ unit: \"milliseconds\" })\n          : (time as number | string),\n      );\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.Sleep,\n        name: msTimeStr,\n        displayName: name ?? id,\n        userland: { id },\n      };\n    }),\n\n    /**\n     * Wait until a particular date before continuing by passing a `Date`.\n     *\n     * To wait for a particular amount of time from now, always use `sleep`\n     * instead.\n     */\n    sleepUntil: createTool<\n      (\n        idOrOptions: StepOptionsOrId,\n\n        /**\n         * The date to wait until before continuing.\n         */\n        time: Date | string | Temporal.InstantLike | Temporal.ZonedDateTimeLike,\n      ) => Promise<void>\n    >(({ id, name }, time) => {\n      try {\n        const iso = Temporal.getISOString(time);\n\n        /**\n         * The presence of this operation in the returned stack indicates that the\n         * sleep is over and we should continue execution.\n         */\n        return {\n          id,\n          mode: StepMode.Async,\n          op: StepOpCode.Sleep,\n          name: iso,\n          displayName: name ?? id,\n          userland: { id },\n        };\n      } catch (err) {\n        /**\n         * If we're here, it's because the date is invalid. We'll throw a custom\n         * error here to standardise this response.\n         */\n        // TODO PrettyError\n        console.warn(\n          \"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\",\n          err,\n        );\n\n        // TODO PrettyError\n        throw new Error(\n          `Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n            time\n          }`,\n        );\n      }\n    }),\n\n    /**\n     * Invoke a passed Inngest `function` with the given `data`. Returns the\n     * result of the returned value of the function or `null` if the function\n     * does not return a value.\n     *\n     * A string ID can also be passed to reference functions outside of the\n     * current app.\n     */\n    invoke: createTool<\n      <TFunction extends InvokeTargetFunctionDefinition>(\n        idOrOptions: StepOptionsOrId,\n        opts: InvocationOpts<TFunction>,\n      ) => InvocationResult<GetFunctionOutput<TFunction>>\n    >(({ id, name }, invokeOpts) => {\n      // Create a discriminated union to operate on based on the input types\n      // available for this tool.\n      const optsSchema = invokePayloadSchema.extend({\n        timeout: z.union([z.number(), z.string(), z.date()]).optional(),\n      });\n\n      const parsedFnOpts = optsSchema\n        .extend({\n          _type: z.literal(\"fullId\").optional().default(\"fullId\"),\n          function: z.string().min(1),\n        })\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n            function: z.instanceof(InngestFunction),\n          }),\n        )\n        .or(\n          optsSchema.extend({\n            _type: z.literal(\"refInstance\").optional().default(\"refInstance\"),\n            function: z.instanceof(InngestFunctionReference),\n          }),\n        )\n        .safeParse(invokeOpts);\n\n      if (!parsedFnOpts.success) {\n        throw new Error(\n          `Invalid invocation options passed to invoke; must include either a function or functionId.`,\n        );\n      }\n\n      const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n      const payload = { data, user, v } satisfies MinimalEventPayload;\n      const opts: {\n        payload: MinimalEventPayload;\n        function_id: string;\n        timeout?: string;\n      } = {\n        payload,\n        function_id: \"\",\n        timeout: typeof timeout === \"undefined\" ? undefined : timeStr(timeout),\n      };\n\n      switch (_type) {\n        case \"fnInstance\":\n          opts.function_id = fn.id(fn[\"client\"].id);\n          break;\n\n        case \"fullId\":\n          console.warn(\n            `${logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`,\n          );\n          opts.function_id = fn;\n          break;\n\n        case \"refInstance\":\n          opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n            .filter(Boolean)\n            .join(\"-\");\n          break;\n      }\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.InvokeFunction,\n        displayName: name ?? id,\n        opts,\n        userland: { id },\n      };\n    }),\n\n    /**\n     * `step.fetch` is a Fetch-API-compatible function that can be used to make\n     * any HTTP code durable if it's called within an Inngest function.\n     *\n     * It will gracefully fall back to the global `fetch` if called outside of\n     * this context, and a custom fallback can be set using the `config` method.\n     */\n    fetch: stepFetch,\n  };\n\n  // Add an uptyped gateway\n  (tools as unknown as InternalStepTools)[gatewaySymbol] = createTool(\n    ({ id, name }, input, init) => {\n      const url = input instanceof Request ? input.url : input.toString();\n\n      const headers: Record<string, string> = {};\n      if (input instanceof Request) {\n        input.headers.forEach((value, key) => {\n          headers[key] = value;\n        });\n      } else if (init?.headers) {\n        const h = new Headers(init.headers);\n        h.forEach((value, key) => {\n          headers[key] = value;\n        });\n      }\n\n      return {\n        id,\n        mode: StepMode.Async,\n        op: StepOpCode.Gateway,\n        displayName: name ?? id,\n        opts: {\n          url,\n          method: init?.method ?? \"GET\",\n          headers,\n          body: init?.body,\n        },\n        userland: { id },\n      };\n    },\n  );\n\n  return tools;\n};\n\n/**\n * A generic set of step tools, without typing information about the client used\n * to create them.\n */\nexport type GenericStepTools = GetStepTools<Inngest.Any>;\n\nexport const gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n\nexport type InternalStepTools = GetStepTools<Inngest.Any> & {\n  [gatewaySymbol]: (\n    idOrOptions: StepOptionsOrId,\n    ...args: Parameters<typeof fetch>\n  ) => Promise<{\n    status: number;\n    headers: Record<string, string>;\n    body: string;\n  }>;\n};\n\n/**\n * A generic set of step tools that can be used without typing information about\n * the client used to create them.\n *\n * These tools use AsyncLocalStorage to track the context in which they are\n * used, and will throw an error if used outside of an Inngest context.\n *\n * The intention of these high-level tools is to allow usage of Inngest step\n * tools within API endpoints, though they can still be used within regular\n * Inngest functions as well.\n */\nexport const step: GenericStepTools = {\n  // TODO Support `step.fetch` (this is already kinda half way deferred)\n  fetch: null as unknown as GenericStepTools[\"fetch\"],\n  ai: {\n    infer: (...args) =>\n      getDeferredStepTooling().then((tools) => tools.ai.infer(...args)),\n    wrap: (...args) =>\n      getDeferredStepTooling().then((tools) => tools.ai.wrap(...args)),\n    models: {\n      ...models,\n    },\n  },\n  invoke: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.invoke(...args)),\n  run: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.run(...args)),\n  sendEvent: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sendEvent(...args)),\n  sendSignal: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sendSignal(...args)),\n  sleep: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sleep(...args)),\n  sleepUntil: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.sleepUntil(...args)),\n  waitForEvent: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.waitForEvent(...args)),\n  waitForSignal: (...args) =>\n    getDeferredStepTooling().then((tools) => tools.waitForSignal(...args)),\n};\n\n/**\n * An internal function used to retrieve or create step tooling for the current\n * execution context.\n *\n * Note that this requires an existing context to create the step tooling;\n * something must declare the Inngest execution context before this can be used.\n */\nconst getDeferredStepTooling = async (): Promise<GenericStepTools> => {\n  const ctx = await getAsyncCtx();\n  if (!ctx) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no context was found\",\n    );\n  }\n\n  if (!ctx.app) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no Inngest client was found in the execution context\",\n    );\n  }\n\n  if (!ctx.execution) {\n    throw new Error(\n      \"`step` tools can only be used within Inngest function executions; no execution context was found\",\n    );\n  }\n\n  // If we're here, we're in the context of a function execution already and\n  // we can return the existing step tooling.\n  return ctx.execution.ctx.step;\n};\n\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexport const invokePayloadSchema = z.object({\n  data: z.record(z.any()).optional(),\n  user: z.record(z.any()).optional(),\n  v: z.string().optional(),\n});\n\ntype InvocationTargetOpts<TFunction extends InvokeTargetFunctionDefinition> = {\n  function: TFunction;\n};\n\ntype InvocationOpts<TFunction extends InvokeTargetFunctionDefinition> =\n  InvocationTargetOpts<TFunction> &\n    Omit<TriggerEventFromFunction<TFunction>, \"id\"> & {\n      /**\n       * The step function will wait for the invocation to finish for a maximum\n       * of this time, at which point the retured promise will be rejected\n       * instead of resolved with the output of the invoked function.\n       *\n       * Note that the invoked function will continue to run even if this step\n       * times out.\n       *\n       * The time to wait can be specified using a `number` of milliseconds, an\n       * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`,\n       * or a `Date` object.\n       *\n       * {@link https://npm.im/ms}\n       */\n      timeout?: number | string | Date;\n    };\n\n/**\n * A set of parameters given to a `sendSignal` call.\n */\ntype SendSignalOpts = {\n  /**\n   * The signal to send.\n   */\n  signal: string;\n\n  /**\n   * The data to send with the signal.\n   */\n  data?: unknown;\n};\n\n/**\n * A set of parameters given to a `waitForSignal` call.\n */\ntype WaitForSignalOpts = {\n  /**\n   * The signal to wait for.\n   */\n  signal: string;\n\n  /**\n   * The step function will wait for the signal for a maximum of this time, at\n   * which point the signal will be returned as `null` instead of any signal\n   * data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n\n  /**\n   * When this `step.waitForSignal()` call is made, choose whether an existing\n   * wait for the same signal should be replaced, or whether this run should\n   * fail.\n   *\n   * `\"replace\"` will replace any existing wait with this one, and the existing\n   * wait will remain pending until it reaches its timeout.\n   *\n   * `\"fail\"` will cause this run to fail if there is already a wait for the\n   * same signal.\n   */\n  onConflict: \"replace\" | \"fail\";\n};\n\n/**\n * A set of optional parameters given to a `waitForEvent` call to control how\n * the event is handled.\n */\ntype WaitForEventOpts<\n  Events extends Record<string, EventPayload>,\n  IncomingEvent extends keyof Events,\n> = {\n  event: IncomingEvent;\n\n  /**\n   * The step function will wait for the event for a maximum of this time, at\n   * which point the event will be returned as `null` instead of any event data.\n   *\n   * The time to wait can be specified using a `number` of milliseconds, an\n   * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`, or\n   * a `Date` object.\n   *\n   * {@link https://npm.im/ms}\n   */\n  timeout: number | string | Date;\n} & ExclusiveKeys<\n  {\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * particular criteria. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * It must be a string of a dot-notation field name within both events to\n     * compare, e.g. `\"data.id\"` or `\"user.email\"`.\n     *\n     * ```\n     * // Wait for an event where the `user.email` field matches\n     * match: \"user.email\"\n     * ```\n     *\n     * All of these are helpers for the `if` option, which allows you to specify\n     * a custom condition to check. This can be useful if you need to compare\n     * multiple fields or use a more complex condition.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     *\n     * @deprecated Use `if` instead.\n     */\n    match?: string;\n\n    /**\n     * If provided, the step function will wait for the incoming event to match\n     * the given condition. If the event does not match, it will be ignored and\n     * the step function will wait for another event.\n     *\n     * The condition is a string of Google's Common Expression Language. For most\n     * simple cases, you might prefer to use `match` instead.\n     *\n     * See the Inngest expressions docs for more information.\n     *\n     * {@link https://www.inngest.com/docs/functions/expressions}\n     */\n    if?: string;\n  },\n  \"match\",\n  \"if\"\n>;\n\n/**\n * Options for `step.ai.infer()`.\n */\ntype AiInferOpts<TModel extends AiAdapter> = {\n  /**\n   * The model to use for the inference. Create a model by importing from\n   * `\"inngest\"` or by using `step.ai.models.*`.\n   *\n   * @example Import `openai()`\n   * ```ts\n   * import { openai } from \"inngest\";\n   *\n   * const model = openai({ model: \"gpt-4\" });\n   * ```\n   *\n   * @example Use a model from `step.ai.models`\n   * ```ts\n   * async ({ step }) => {\n   *            const model = step.ai.models.openai({ model: \"gpt-4\" });\n   * }\n   * ```\n   */\n  model: TModel;\n\n  /**\n   * The input to pass to the model.\n   */\n  body: AiAdapter.Input<TModel>;\n};\n"],"mappings":"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"}