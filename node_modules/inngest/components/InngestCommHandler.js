import { getAsyncCtx } from "./execution/als.js";
import { version } from "../version.js";
import { ExecutionVersion, debugPrefix, defaultInngestApiBaseUrl, defaultInngestEventBaseUrl, defaultMaxRetries, dummyEventKey, envKeys, forwardedHeaders, headerKeys, logPrefix, probe, queryKeys, syncKind } from "../helpers/consts.js";
import { AsyncResponseType, StepMode, StepOpCode, functionConfigSchema, inBandSyncRequestBodySchema, logLevels } from "../types.js";
import { PREFERRED_EXECUTION_VERSION } from "./execution/InngestExecution.js";
import { rethrowError, serializeError } from "../helpers/errors.js";
import { fetchAllFnData, parseFnData, undefinedToNull } from "../helpers/functions.js";
import { hashEventKey, hashSigningKey, stringify } from "../helpers/strings.js";
import { Mode, allProcessEnv, devServerHost, getFetch, getMode, getPlatformName, inngestHeaders, parseAsBoolean, platformSupportsStreaming } from "../helpers/env.js";
import { devServerAvailable, devServerUrl } from "../helpers/devserver.js";
import { enumFromValue } from "../helpers/enum.js";
import { fetchWithAuthFallback, signDataWithKey } from "../helpers/net.js";
import { runAsPromise } from "../helpers/promises.js";
import { ServerTiming } from "../helpers/ServerTiming.js";
import { createStream } from "../helpers/stream.js";
import { InngestFunction } from "./InngestFunction.js";
import { _internals } from "./execution/v1.js";
import Debug from "debug";
import { ulid } from "ulid";
import { z } from "zod/v3";

//#region src/components/InngestCommHandler.ts
/**
* A schema for the response from Inngest when registering.
*/
const registerResSchema = z.object({
	status: z.number().default(200),
	skipped: z.boolean().optional().default(false),
	modified: z.boolean().optional().default(false),
	error: z.string().default("Successfully registered")
});
/**
* `InngestCommHandler` is a class for handling incoming requests from Inngest (or
* Inngest's tooling such as the dev server or CLI) and taking appropriate
* action for any served functions.
*
* All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using
* this class; the exposed `serve` function will - most commonly - create an
* instance of `InngestCommHandler` and then return `instance.createHandler()`.
*
* See individual parameter details for more information, or see the
* source code for an existing handler, e.g.
* {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}
*
* @example
* ```
* // my-custom-handler.ts
* import {
*   InngestCommHandler,
*   type ServeHandlerOptions,
* } from "./components/InngestCommHandler";
*
* export const serve = (options: ServeHandlerOptions) => {
*   const handler = new InngestCommHandler({
*     frameworkName: "my-custom-handler",
*     ...options,
*     handler: (req: Request) => {
*       return {
*         body: () => req.json(),
*         headers: (key) => req.headers.get(key),
*         method: () => req.method,
*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
*         transformResponse: ({ body, status, headers }) => {
*           return new Response(body, { status, headers });
*         },
*       };
*     },
*   });
*
*   return handler.createHandler();
* };
* ```
*
* @public
*/
var InngestCommHandler = class {
	/**
	* The ID of this serve handler, e.g. `"my-app"`. It's recommended that this
	* value represents the overarching app/service that this set of functions is
	* being served from.
	*/
	id;
	/**
	* The handler specified during instantiation of the class.
	*/
	handler;
	/**
	* The URL of the Inngest function registration endpoint.
	*/
	inngestRegisterUrl;
	/**
	* The name of the framework this handler is designed for. Should be
	* lowercase, alphanumeric characters inclusive of `-` and `/`.
	*/
	frameworkName;
	/**
	* The signing key used to validate requests from Inngest. This is
	* intentionally mutable so that we can pick up the signing key from the
	* environment during execution if needed.
	*/
	signingKey;
	/**
	* The same as signingKey, except used as a fallback when auth fails using the
	* primary signing key.
	*/
	signingKeyFallback;
	/**
	* A property that can be set to indicate whether we believe we are in
	* production mode.
	*
	* Should be set every time a request is received.
	*/
	_mode;
	/**
	* The localized `fetch` implementation used by this handler.
	*/
	fetch;
	/**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/
	_serveHost;
	/**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*/
	_servePath;
	/**
	* The minimum level to log from the Inngest serve handler.
	*/
	logLevel;
	streaming;
	/**
	* A private collection of just Inngest functions, as they have been passed
	* when instantiating the class.
	*/
	rawFns;
	client;
	/**
	* A private collection of functions that are being served. This map is used
	* to find and register functions when interacting with Inngest Cloud.
	*/
	fns = {};
	env = allProcessEnv();
	allowExpiredSignatures;
	_options;
	skipSignatureValidation;
	constructor(options) {
		this._options = options;
		/**
		* v2 -> v3 migration error.
		*
		* If a serve handler is passed a client as the first argument, it'll be
		* spread in to these options. We should be able to detect this by picking
		* up a unique property on the object.
		*/
		if (Object.hasOwn(options, "eventKey")) throw new Error(`${logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \`client\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);
		this.frameworkName = options.frameworkName;
		this.client = options.client;
		if (options.id) console.warn(`${logPrefix} The \`id\` serve option is deprecated and will be removed in v4`);
		this.id = options.id || this.client.id;
		this.handler = options.handler;
		/**
		* Provide a hidden option to allow expired signatures to be accepted during
		* testing.
		*/
		this.allowExpiredSignatures = Boolean(arguments["0"]?.__testingAllowExpiredSignatures);
		this.rawFns = options.functions?.filter(Boolean) ?? [];
		if (this.rawFns.length !== (options.functions ?? []).length) console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);
		this.fns = this.rawFns.reduce((acc, fn) => {
			const configs = fn["getConfig"]({
				baseUrl: new URL("https://example.com"),
				appPrefix: this.id
			});
			const fns = configs.reduce((acc$1, { id }, index) => {
				return {
					...acc$1,
					[id]: {
						fn,
						onFailure: Boolean(index)
					}
				};
			}, {});
			configs.forEach(({ id }) => {
				if (acc[id]) throw new Error(`Duplicate function ID "${id}"; please change a function's name or provide an explicit ID to avoid conflicts.`);
			});
			return {
				...acc,
				...fns
			};
		}, {});
		this.inngestRegisterUrl = new URL("/fn/register", this.apiBaseUrl);
		this.signingKey = options.signingKey;
		this.signingKeyFallback = options.signingKeyFallback;
		this._serveHost = options.serveHost || this.env[envKeys.InngestServeHost];
		this._servePath = options.servePath || this.env[envKeys.InngestServePath];
		this.skipSignatureValidation = options.skipSignatureValidation || false;
		const defaultLogLevel = "info";
		this.logLevel = z.enum(logLevels).default(defaultLogLevel).catch((ctx) => {
			this.log("warn", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);
			return defaultLogLevel;
		}).parse(options.logLevel || this.env[envKeys.InngestLogLevel]);
		if (this.logLevel === "debug") {
			/**
			* `debug` is an old library; sometimes its runtime detection doesn't work
			* for newer pairings of framework/runtime.
			*
			* One silly symptom of this is that `Debug()` returns an anonymous
			* function with no extra properties instead of a `Debugger` instance if
			* the wrong code is consumed following a bad detection. This results in
			* the following `.enable()` call failing, so we just try carefully to
			* enable it here.
			*/
			if (Debug.enable && typeof Debug.enable === "function") Debug.enable(`${debugPrefix}:*`);
		}
		const defaultStreamingOption = false;
		this.streaming = z.union([z.enum(["allow", "force"]), z.literal(false)]).default(defaultStreamingOption).catch((ctx) => {
			this.log("warn", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);
			return defaultStreamingOption;
		}).parse(options.streaming || this.env[envKeys.InngestStreaming]);
		this.fetch = options.fetch ? getFetch(options.fetch) : this.client["fetch"];
	}
	/**
	* Get the API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the API base URL
	* each time it's accessed, as it may change during execution.
	*/
	get apiBaseUrl() {
		return this._options.baseUrl || this.env[envKeys.InngestApiBaseUrl] || this.env[envKeys.InngestBaseUrl] || this.client.apiBaseUrl || defaultInngestApiBaseUrl;
	}
	/**
	* Get the event API base URL for the Inngest API.
	*
	* This is a getter to encourage checking the environment for the event API
	* base URL each time it's accessed, as it may change during execution.
	*/
	get eventApiBaseUrl() {
		return this._options.baseUrl || this.env[envKeys.InngestEventApiBaseUrl] || this.env[envKeys.InngestBaseUrl] || this.client.eventBaseUrl || defaultInngestEventBaseUrl;
	}
	/**
	* The host used to access the Inngest serve endpoint, e.g.:
	*
	*     "https://myapp.com"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom hostname here to ensure that the path is reported
	* correctly when registering functions with Inngest.
	*
	* To also provide a custom path, use `servePath`.
	*/
	get serveHost() {
		return this._serveHost || this.env[envKeys.InngestServeHost];
	}
	/**
	* The path to the Inngest serve endpoint. e.g.:
	*
	*     "/some/long/path/to/inngest/endpoint"
	*
	* By default, the library will try to infer this using request details such
	* as the "Host" header and request path, but sometimes this isn't possible
	* (e.g. when running in a more controlled environments such as AWS Lambda or
	* when dealing with proxies/redirects).
	*
	* Provide the custom path (excluding the hostname) here to ensure that the
	* path is reported correctly when registering functions with Inngest.
	*
	* To also provide a custom hostname, use `serveHost`.
	*
	* This is a getter to encourage checking the environment for the serve path
	* each time it's accessed, as it may change during execution.
	*/
	get servePath() {
		return this._servePath || this.env[envKeys.InngestServePath];
	}
	get hashedEventKey() {
		if (!this.client["eventKey"] || this.client["eventKey"] === dummyEventKey) return;
		return hashEventKey(this.client["eventKey"]);
	}
	get hashedSigningKey() {
		if (!this.signingKey) return;
		return hashSigningKey(this.signingKey);
	}
	get hashedSigningKeyFallback() {
		if (!this.signingKeyFallback) return;
		return hashSigningKey(this.signingKeyFallback);
	}
	/**
	* Returns a `boolean` representing whether this handler will stream responses
	* or not. Takes into account the user's preference and the platform's
	* capabilities.
	*/
	async shouldStream(actions) {
		if (await actions.queryStringWithDefaults("testing for probe", queryKeys.Probe) !== void 0) return false;
		if (!actions.transformStreamingResponse) return false;
		if (this.streaming === "force") return true;
		return this.streaming === "allow" && platformSupportsStreaming(this.frameworkName, this.env);
	}
	async isInngestReq(actions) {
		const reqMessage = `checking if this is an Inngest request`;
		const [runId, signature] = await Promise.all([actions.headers(reqMessage, headerKeys.InngestRunId), actions.headers(reqMessage, headerKeys.Signature)]);
		return Boolean(runId && typeof signature === "string");
	}
	/**
	* Start handling a request, setting up environments, modes, and returning
	* some helpers.
	*/
	async initRequest(...args) {
		const timer = new ServerTiming();
		const actions = await this.getActions(timer, ...args);
		const [env, expectedServerKind] = await Promise.all([actions.env?.("starting to handle request"), actions.headers("checking expected server kind", headerKeys.InngestServerKind)]);
		this.env = {
			...allProcessEnv(),
			...env
		};
		const headerPromises = forwardedHeaders.map(async (header) => {
			return {
				header,
				value: await actions.headers(`fetching ${header} for forwarding`, header)
			};
		});
		const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders) => {
			return fetchedHeaders.reduce((acc, { header, value }) => {
				if (value) acc[header] = value;
				return acc;
			}, {});
		});
		const getHeaders = async () => ({
			...inngestHeaders({
				env: this.env,
				framework: this.frameworkName,
				client: this.client,
				expectedServerKind: expectedServerKind || void 0,
				extras: { "Server-Timing": timer.getHeader() }
			}),
			...await headersToForwardP
		});
		const assumedMode = getMode({
			env: this.env,
			client: this.client
		});
		if (assumedMode.isExplicit) this._mode = assumedMode;
		else {
			const serveIsProd = await actions.isProduction?.("starting to handle request");
			if (typeof serveIsProd === "boolean") this._mode = new Mode({
				type: serveIsProd ? "cloud" : "dev",
				isExplicit: false
			});
			else this._mode = assumedMode;
		}
		this.upsertKeysFromEnv();
		return {
			timer,
			actions,
			getHeaders
		};
	}
	/**
	* `createSyncHandler` should be used to return a type-equivalent version of
	* the `handler` specified during instantiation.
	*/
	createSyncHandler() {
		return (handler) => {
			return this.wrapHandler((async (...args) => {
				const reqInit = await this.initRequest(...args);
				const fn = new InngestFunction(this.client, {
					id: this._options.syncOptions?.functionId ?? "",
					retries: this._options.syncOptions?.retries ?? defaultMaxRetries
				}, () => handler(...args));
				if (await this.isInngestReq(reqInit.actions)) return this.handleAsyncRequest({
					...reqInit,
					forceExecution: true,
					args,
					fns: [fn]
				});
				return this.handleSyncRequest({
					...reqInit,
					args,
					asyncMode: this._options.syncOptions?.asyncResponse ?? AsyncResponseType.Redirect,
					fn
				});
			}));
		};
	}
	/**
	* `createHandler` should be used to return a type-equivalent version of the
	* `handler` specified during instantiation.
	*
	* @example
	* ```
	* // my-custom-handler.ts
	* import {
	*   InngestCommHandler,
	*   type ServeHandlerOptions,
	* } from "./components/InngestCommHandler";
	*
	* export const serve = (options: ServeHandlerOptions) => {
	*   const handler = new InngestCommHandler({
	*     frameworkName: "my-custom-handler",
	*     ...options,
	*     handler: (req: Request) => {
	*       return {
	*         body: () => req.json(),
	*         headers: (key) => req.headers.get(key),
	*         method: () => req.method,
	*         url: () => new URL(req.url, `https://${req.headers.get("host") || ""}`),
	*         transformResponse: ({ body, status, headers }) => {
	*           return new Response(body, { status, headers });
	*         },
	*       };
	*     },
	*   });
	*
	*   return handler.createHandler();
	* };
	* ```
	*/
	createHandler() {
		return this.wrapHandler((async (...args) => {
			return this.handleAsyncRequest({
				...await this.initRequest(...args),
				args
			});
		}));
	}
	/**
	* Given a set of actions that let us access the incoming request, create a
	* `http/run.started` event that repesents a run starting from an HTTP
	* request.
	*/
	async createHttpEvent(actions, fn) {
		const reason = "creating sync event";
		const contentTypePromise = actions.headers(reason, headerKeys.ContentType).then((v) => v ?? "");
		const ipPromise = actions.headers(reason, headerKeys.ForwardedFor).then((v) => {
			if (v) return v;
			return actions.headers(reason, headerKeys.RealIp).then((v$1) => v$1 ?? "");
		});
		const methodPromise = actions.method(reason);
		const urlPromise = actions.url(reason).then((v) => this.reqUrl(v));
		const domainPromise = urlPromise.then((url) => `${url.protocol}//${url.host}`);
		const pathPromise = urlPromise.then((url) => url.pathname);
		const queryParamsPromise = urlPromise.then((url) => url.searchParams.toString());
		const bodyPromise = actions.textBody(reason).then((body$1) => {
			return typeof body$1 === "string" ? body$1 : stringify(body$1);
		});
		const [contentType, domain, ip, method, path, queryParams, body] = await Promise.all([
			contentTypePromise,
			domainPromise,
			ipPromise,
			methodPromise,
			pathPromise,
			queryParamsPromise,
			bodyPromise
		]);
		return {
			name: "http/run.started",
			data: {
				content_type: contentType,
				domain,
				ip,
				method,
				path,
				query_params: queryParams,
				body,
				fn: fn.id()
			}
		};
	}
	async handleSyncRequest({ timer, actions, fn, asyncMode, args }) {
		if (!actions.experimentalTransformSyncResponse) throw new Error("This platform does not support synchronous Inngest function executions.");
		if (await getAsyncCtx()) throw new Error("We already seem to be in the context of an Inngest execution, but didn't expect to be. Did you already wrap this handler?");
		const runId = ulid();
		const event = await this.createHttpEvent(actions, fn);
		const exeVersion = PREFERRED_EXECUTION_VERSION;
		const result = await fn["createExecution"]({
			version: exeVersion,
			partialOptions: {
				client: this.client,
				data: {
					runId,
					event,
					attempt: 0,
					events: [event],
					maxAttempts: fn.opts.retries ?? defaultMaxRetries
				},
				runId,
				headers: {},
				reqArgs: args,
				stepCompletionOrder: [],
				stepState: {},
				disableImmediateExecution: false,
				isFailureHandler: false,
				timer,
				createResponse: (data) => actions.experimentalTransformSyncResponse("creating sync execution", data).then((res) => ({
					...res,
					version: exeVersion
				})),
				stepMode: StepMode.Sync
			}
		}).start();
		const resultHandler = {
			"step-not-found": () => {
				throw new Error("We should not get the result 'step-not-found' when checkpointing. This is a bug in the `inngest` SDK");
			},
			"steps-found": () => {
				throw new Error("We should not get the result 'steps-found' when checkpointing. This is a bug in the `inngest` SDK");
			},
			"step-ran": () => {
				throw new Error("We should not get the result 'step-ran' when checkpointing. This is a bug in the `inngest` SDK");
			},
			"function-rejected": () => {
				throw new Error("We should not get the result 'function-rejected' when checkpointing. This is a bug in the `inngest` SDK");
			},
			"function-resolved": ({ data }) => {
				return data;
			},
			"change-mode": async ({ token }) => {
				switch (asyncMode) {
					case AsyncResponseType.Redirect: return actions.transformResponse("creating sync->async redirect response", {
						status: 302,
						headers: { [headerKeys.Location]: await this.client["inngestApi"]["getTargetUrl"](`/v1/http/runs/${runId}/output?token=${token}`).then((url) => url.toString()) },
						version: exeVersion,
						body: ""
					});
					case AsyncResponseType.Token: return actions.transformResponse("creating sync->async token response", {
						status: 200,
						headers: {},
						version: exeVersion,
						body: stringify({
							run_id: runId,
							token
						})
					});
					default: break;
				}
				throw new Error("Not implemented: change-mode");
			}
		}[result.type];
		if (!resultHandler) throw new Error(`No handler for execution result type: ${result.type}. This is a bug in the \`inngest\` SDK`);
		return resultHandler(result);
	}
	async handleAsyncRequest({ timer, actions, args, getHeaders, forceExecution, fns }) {
		if (forceExecution && !actions.experimentalTransformSyncResponse) throw new Error("This platform does not support async executions in Inngest for APIs.");
		const methodP = actions.method("starting to handle request");
		const contentLength = await actions.headers("checking signature for request", headerKeys.ContentLength).then((value) => {
			if (!value) return;
			return Number.parseInt(value, 10);
		});
		const [signature, method, body] = await Promise.all([
			actions.headers("checking signature for request", headerKeys.Signature).then((headerSignature) => {
				return headerSignature ?? void 0;
			}),
			methodP,
			methodP.then((method$1) => {
				if (method$1 === "POST" || method$1 === "PUT") {
					if (!contentLength) return "";
					return actions.body(`checking body for request signing as method is ${method$1}`);
				}
				return "";
			})
		]);
		const signatureValidation = this.validateSignature(signature, body);
		const actionRes = timer.wrap("action", () => this.handleAction({
			actions,
			timer,
			getHeaders,
			reqArgs: args,
			signatureValidation,
			body,
			method,
			forceExecution: Boolean(forceExecution),
			fns
		}));
		/**
		* Prepares an action response by merging returned data to provide
		* trailing information such as `Server-Timing` headers.
		*
		* It should always prioritize the headers returned by the action, as they
		* may contain important information such as `Content-Type`.
		*/
		const prepareActionRes = async (res) => {
			const headers = {
				...await getHeaders(),
				...res.headers,
				...res.version === null ? {} : { [headerKeys.RequestVersion]: (res.version ?? PREFERRED_EXECUTION_VERSION).toString() }
			};
			let signature$1;
			try {
				signature$1 = await signatureValidation.then((result) => {
					if (!result.success || !result.keyUsed) return;
					return this.getResponseSignature(result.keyUsed, res.body);
				});
			} catch (err) {
				return {
					...res,
					headers,
					body: stringify(serializeError(err)),
					status: 500
				};
			}
			if (signature$1) headers[headerKeys.Signature] = signature$1;
			return {
				...res,
				headers
			};
		};
		if (await this.shouldStream(actions)) {
			if (await actions.method("starting streaming response") === "POST") {
				const { stream, finalize } = await createStream();
				/**
				* Errors are handled by `handleAction` here to ensure that an
				* appropriate response is always given.
				*/
				actionRes.then((res) => {
					return finalize(prepareActionRes(res));
				});
				return timer.wrap("res", async () => {
					return actions.transformStreamingResponse?.("starting streaming response", {
						status: 201,
						headers: await getHeaders(),
						body: stream,
						version: null
					});
				});
			}
		}
		return timer.wrap("res", async () => {
			return actionRes.then(prepareActionRes).then((actionRes$1) => {
				return actions.transformResponse("sending back response", actionRes$1);
			});
		});
	}
	async getActions(timer, ...args) {
		/**
		* Used for testing, allow setting action overrides externally when
		* calling the handler. Always search the final argument.
		*/
		const lastArg = args[args.length - 1];
		const actionOverrides = typeof lastArg === "object" && lastArg !== null && "actionOverrides" in lastArg && typeof lastArg["actionOverrides"] === "object" && lastArg["actionOverrides"] !== null ? lastArg["actionOverrides"] : {};
		/**
		* We purposefully `await` the handler, as it could be either sync or
		* async.
		*/
		const rawActions = {
			...await timer.wrap("handler", () => this.handler(...args)).catch(rethrowError("Serve handler failed to run")),
			...actionOverrides
		};
		/**
		* Mapped promisified handlers from userland `serve()` function mixed in
		* with some helpers.
		*/
		const actions = {
			...Object.entries(rawActions).reduce((acc, [key, value]) => {
				if (typeof value !== "function") return acc;
				return {
					...acc,
					[key]: (reason, ...args$1) => {
						const errMessage = [`Failed calling \`${key}\` from serve handler`, reason].filter(Boolean).join(" when ");
						const fn = () => value(...args$1);
						return runAsPromise(fn).catch(rethrowError(errMessage)).catch((err) => {
							this.log("error", err);
							throw err;
						});
					}
				};
			}, {}),
			queryStringWithDefaults: async (reason, key) => {
				const url = await actions.url(reason);
				return await actions.queryString?.(reason, key, url) || url.searchParams.get(key) || void 0;
			},
			...actionOverrides
		};
		return actions;
	}
	wrapHandler(handler) {
		/**
		* Some platforms check (at runtime) the length of the function being used
		* to handle an endpoint. If this is a variadic function, it will fail that
		* check.
		*
		* Therefore, we expect the arguments accepted to be the same length as the
		* `handler` function passed internally.
		*
		* We also set a name to avoid a common useless name in tracing such as
		* `"anonymous"` or `"bound function"`.
		*
		* https://github.com/getsentry/sentry-javascript/issues/3284
		*/
		Object.defineProperties(handler, {
			name: { value: "InngestHandler" },
			length: { value: this.handler.length }
		});
		return handler;
	}
	get mode() {
		return this._mode;
	}
	set mode(m) {
		this._mode = m;
		if (m) this.client["mode"] = m;
	}
	/**
	* Given a set of functions to check if an action is available from the
	* instance's handler, enact any action that is found.
	*
	* This method can fetch varying payloads of data, but ultimately is the place
	* where _decisions_ are made regarding functionality.
	*
	* For example, if we find that we should be viewing the UI, this function
	* will decide whether the UI should be visible based on the payload it has
	* found (e.g. env vars, options, etc).
	*/
	async handleAction({ actions, timer, getHeaders, reqArgs, signatureValidation, body: rawBody, method, forceExecution, fns }) {
		const isMissingBody = rawBody === void 0;
		let body = rawBody;
		try {
			let url = await actions.url("starting to handle request");
			if (method === "POST" || forceExecution) {
				if (!forceExecution && isMissingBody) {
					this.log("error", "Missing body when executing, possibly due to missing request body middleware");
					return {
						status: 500,
						headers: { "Content-Type": "application/json" },
						body: stringify(serializeError(/* @__PURE__ */ new Error("Missing request body when executing, possibly due to missing request body middleware"))),
						version: void 0
					};
				}
				const validationResult = await signatureValidation;
				if (!validationResult.success) return {
					status: 401,
					headers: { "Content-Type": "application/json" },
					body: stringify(serializeError(validationResult.err)),
					version: void 0
				};
				let fn;
				let fnId;
				let stepId;
				if (forceExecution) {
					fn = fns?.length && fns[0] ? {
						fn: fns[0],
						onFailure: false
					} : Object.values(this.fns)[0];
					fnId = fn?.fn.id();
					stepId = "step";
					body = {
						event: {},
						events: [],
						steps: {},
						version: PREFERRED_EXECUTION_VERSION,
						ctx: {
							attempt: 0,
							disable_immediate_execution: false,
							use_api: true,
							max_attempts: 3,
							run_id: await actions.headers("getting run ID for forced execution", headerKeys.InngestRunId),
							stack: {
								stack: [],
								current: 0
							}
						}
					};
				} else {
					const rawProbe = await actions.queryStringWithDefaults("testing for probe", queryKeys.Probe);
					if (rawProbe) {
						const probe$1 = enumFromValue(probe, rawProbe);
						if (!probe$1) return {
							status: 400,
							headers: { "Content-Type": "application/json" },
							body: stringify(serializeError(/* @__PURE__ */ new Error(`Unknown probe "${rawProbe}"`))),
							version: void 0
						};
						return { [probe.Trust]: () => ({
							status: 200,
							headers: { "Content-Type": "application/json" },
							body: "",
							version: void 0
						}) }[probe$1]();
					}
					fnId = await actions.queryStringWithDefaults("processing run request", queryKeys.FnId);
					if (!fnId) throw new Error("No function ID found in async request");
					fn = this.fns[fnId];
					stepId = await actions.queryStringWithDefaults("processing run request", queryKeys.StepId) || null;
				}
				if (typeof fnId === "undefined" || !fn) throw new Error("No function ID found in request");
				const { version: version$1, result } = this.runStep({
					functionId: fnId,
					data: body,
					stepId,
					timer,
					reqArgs,
					headers: await getHeaders(),
					fn,
					forceExecution,
					actions
				});
				const stepOutput = await result;
				/**
				* Functions can return `undefined`, but we'll always convert this to
				* `null`, as this is appropriately serializable by JSON.
				*/
				const opDataUndefinedToNull = (op) => {
					op.data = undefinedToNull(op.data);
					return op;
				};
				const handler = {
					"function-rejected": (result$1) => {
						return {
							status: result$1.retriable ? 500 : 400,
							headers: {
								"Content-Type": "application/json",
								[headerKeys.NoRetry]: result$1.retriable ? "false" : "true",
								...typeof result$1.retriable === "string" ? { [headerKeys.RetryAfter]: result$1.retriable } : {}
							},
							body: stringify(undefinedToNull(result$1.error)),
							version: version$1
						};
					},
					"function-resolved": (result$1) => {
						if (forceExecution) {
							const runCompleteOp = {
								id: _internals.hashId("complete"),
								op: StepOpCode.RunComplete,
								data: undefinedToNull(result$1.data)
							};
							return {
								status: 206,
								headers: { "Content-Type": "application/json" },
								body: stringify(runCompleteOp),
								version: version$1
							};
						}
						return {
							status: 200,
							headers: { "Content-Type": "application/json" },
							body: stringify(undefinedToNull(result$1.data)),
							version: version$1
						};
					},
					"step-not-found": (result$1) => {
						return {
							status: 500,
							headers: {
								"Content-Type": "application/json",
								[headerKeys.NoRetry]: "false"
							},
							body: stringify({ error: `Could not find step "${result$1.step.displayName || result$1.step.id}" to run; timed out` }),
							version: version$1
						};
					},
					"step-ran": (result$1) => {
						const step = opDataUndefinedToNull(result$1.step);
						return {
							status: 206,
							headers: {
								"Content-Type": "application/json",
								...typeof result$1.retriable !== "undefined" ? {
									[headerKeys.NoRetry]: result$1.retriable ? "false" : "true",
									...typeof result$1.retriable === "string" ? { [headerKeys.RetryAfter]: result$1.retriable } : {}
								} : {}
							},
							body: stringify([step]),
							version: version$1
						};
					},
					"steps-found": (result$1) => {
						const steps = result$1.steps.map(opDataUndefinedToNull);
						return {
							status: 206,
							headers: { "Content-Type": "application/json" },
							body: stringify(steps),
							version: version$1
						};
					},
					"change-mode": (result$1) => {
						return {
							status: 500,
							headers: {
								"Content-Type": "application/json",
								[headerKeys.NoRetry]: "true"
							},
							body: stringify({ error: `We wanted to change mode to "${result$1.to}", but this is not supported within the InngestCommHandler. This is a bug in the Inngest SDK.` }),
							version: version$1
						};
					}
				}[stepOutput.type];
				try {
					return await handler(stepOutput);
				} catch (err) {
					this.log("error", "Error handling execution result", err);
					throw err;
				}
			}
			const env = (await getHeaders())[headerKeys.Environment] ?? null;
			if (method === "GET") return {
				status: 200,
				body: stringify(await this.introspectionBody({
					actions,
					env,
					signatureValidation,
					url
				})),
				headers: { "Content-Type": "application/json" },
				version: void 0
			};
			if (method === "PUT") {
				const [deployId, inBandSyncRequested] = await Promise.all([actions.queryStringWithDefaults("processing deployment request", queryKeys.DeployId).then((deployId$1) => {
					return deployId$1 === "undefined" ? void 0 : deployId$1;
				}), Promise.resolve(parseAsBoolean(this.env[envKeys.InngestAllowInBandSync])).then((allowInBandSync) => {
					if (allowInBandSync !== void 0 && !allowInBandSync) return syncKind.OutOfBand;
					return actions.headers("processing deployment request", headerKeys.InngestSyncKind);
				}).then((kind) => {
					return kind === syncKind.InBand;
				})]);
				if (inBandSyncRequested) {
					if (isMissingBody) {
						this.log("error", "Missing body when syncing, possibly due to missing request body middleware");
						return {
							status: 500,
							headers: { "Content-Type": "application/json" },
							body: stringify(serializeError(/* @__PURE__ */ new Error("Missing request body when syncing, possibly due to missing request body middleware"))),
							version: void 0
						};
					}
					if (!(await signatureValidation).success) return {
						status: 401,
						body: stringify({ code: "sig_verification_failed" }),
						headers: { "Content-Type": "application/json" },
						version: void 0
					};
					const res = inBandSyncRequestBodySchema.safeParse(body);
					if (!res.success) return {
						status: 400,
						body: stringify({
							code: "invalid_request",
							message: res.error.message
						}),
						headers: { "Content-Type": "application/json" },
						version: void 0
					};
					url = this.reqUrl(new URL(res.data.url));
					return {
						status: 200,
						body: stringify(await this.inBandRegisterBody({
							actions,
							deployId,
							env,
							signatureValidation,
							url
						})),
						headers: {
							"Content-Type": "application/json",
							[headerKeys.InngestSyncKind]: syncKind.InBand
						},
						version: void 0
					};
				}
				const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getHeaders);
				return {
					status,
					body: stringify({
						message,
						modified
					}),
					headers: {
						"Content-Type": "application/json",
						[headerKeys.InngestSyncKind]: syncKind.OutOfBand
					},
					version: void 0
				};
			}
		} catch (err) {
			return {
				status: 500,
				body: stringify({
					type: "internal",
					...serializeError(err)
				}),
				headers: { "Content-Type": "application/json" },
				version: void 0
			};
		}
		return {
			status: 405,
			body: JSON.stringify({
				message: "No action found; request was likely not POST, PUT, or GET",
				mode: this._mode
			}),
			headers: {},
			version: void 0
		};
	}
	runStep({ actions, functionId, stepId, data, timer, reqArgs, headers, fn, forceExecution }) {
		if (!fn) throw new Error(`Could not find function with ID "${functionId}"`);
		const immediateFnData = parseFnData(data);
		let { version: version$1 } = immediateFnData;
		if (version$1 === ExecutionVersion.V1 && fn.fn["shouldOptimizeParallelism"]?.()) version$1 = ExecutionVersion.V2;
		const result = runAsPromise(async () => {
			const anyFnData = await fetchAllFnData({
				data: immediateFnData,
				api: this.client["inngestApi"],
				version: version$1
			});
			if (!anyFnData.ok) throw new Error(anyFnData.error);
			const createResponse = forceExecution && actions.experimentalTransformSyncResponse ? (data$1) => actions.experimentalTransformSyncResponse("created sync->async response", data$1).then((res) => ({
				...res,
				version: version$1
			})) : void 0;
			const executionOptions = await ((s) => s)({
				[ExecutionVersion.V0]: ({ event, events, steps, ctx, version: version$2 }) => {
					const stepState = Object.entries(steps ?? {}).reduce((acc, [id, data$1]) => {
						return {
							...acc,
							[id]: {
								id,
								data: data$1
							}
						};
					}, {});
					return {
						version: version$2,
						partialOptions: {
							client: this.client,
							runId: ctx?.run_id || "",
							stepMode: StepMode.Async,
							data: {
								event,
								events,
								runId: ctx?.run_id || "",
								attempt: ctx?.attempt ?? 0
							},
							stepState,
							requestedRunStep: stepId === "step" ? void 0 : stepId || void 0,
							timer,
							isFailureHandler: fn.onFailure,
							stepCompletionOrder: ctx?.stack?.stack ?? [],
							reqArgs,
							headers,
							createResponse
						}
					};
				},
				[ExecutionVersion.V1]: ({ event, events, steps, ctx, version: version$2 }) => {
					const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1]) => {
						return {
							...acc,
							[id]: result$1.type === "data" ? {
								id,
								data: result$1.data
							} : result$1.type === "input" ? {
								id,
								input: result$1.input
							} : {
								id,
								error: result$1.error
							}
						};
					}, {});
					const requestedRunStep = stepId === "step" ? void 0 : stepId || void 0;
					return {
						version: version$2,
						partialOptions: {
							client: this.client,
							runId: ctx?.run_id || "",
							stepMode: fn.fn["shouldAsyncCheckpoint"](requestedRunStep, ctx?.fn_id, Boolean(ctx?.disable_immediate_execution)) ? StepMode.AsyncCheckpointing : StepMode.Async,
							data: {
								event,
								events,
								runId: ctx?.run_id || "",
								attempt: ctx?.attempt ?? 0,
								maxAttempts: ctx?.max_attempts
							},
							internalFnId: ctx?.fn_id,
							queueItemId: ctx?.qi_id,
							stepState,
							requestedRunStep,
							timer,
							isFailureHandler: fn.onFailure,
							disableImmediateExecution: ctx?.disable_immediate_execution,
							stepCompletionOrder: ctx?.stack?.stack ?? [],
							reqArgs,
							headers,
							createResponse
						}
					};
				},
				[ExecutionVersion.V2]: ({ event, events, steps, ctx, version: version$2 }) => {
					const stepState = Object.entries(steps ?? {}).reduce((acc, [id, result$1]) => {
						return {
							...acc,
							[id]: result$1.type === "data" ? {
								id,
								data: result$1.data
							} : result$1.type === "input" ? {
								id,
								input: result$1.input
							} : {
								id,
								error: result$1.error
							}
						};
					}, {});
					const requestedRunStep = stepId === "step" ? void 0 : stepId || void 0;
					return {
						version: version$2,
						partialOptions: {
							client: this.client,
							runId: ctx?.run_id || "",
							stepMode: fn.fn["shouldAsyncCheckpoint"](requestedRunStep, ctx?.fn_id, Boolean(ctx?.disable_immediate_execution)) ? StepMode.AsyncCheckpointing : StepMode.Async,
							data: {
								event,
								events,
								runId: ctx?.run_id || "",
								attempt: ctx?.attempt ?? 0,
								maxAttempts: ctx?.max_attempts
							},
							internalFnId: ctx?.fn_id,
							queueItemId: ctx?.qi_id,
							stepState,
							requestedRunStep,
							timer,
							isFailureHandler: fn.onFailure,
							disableImmediateExecution: ctx?.disable_immediate_execution,
							stepCompletionOrder: ctx?.stack?.stack ?? [],
							reqArgs,
							headers,
							createResponse
						}
					};
				}
			})[version$1](anyFnData.value);
			return fn.fn["createExecution"](executionOptions).start();
		});
		return {
			version: version$1,
			result
		};
	}
	configs(url) {
		const configs = Object.values(this.rawFns).reduce((acc, fn) => [...acc, ...fn["getConfig"]({
			baseUrl: url,
			appPrefix: this.id
		})], []);
		for (const config of configs) {
			const check = functionConfigSchema.safeParse(config);
			if (!check.success) {
				const errors = check.error.errors.map((err) => err.message).join("; ");
				this.log("warn", `Config invalid for function "${config.id}" : ${errors}`);
			}
		}
		return configs;
	}
	/**
	* Return an Inngest serve endpoint URL given a potential `path` and `host`.
	*
	* Will automatically use the `serveHost` and `servePath` if they have been
	* set when registering.
	*/
	reqUrl(url) {
		let ret = new URL(url);
		const serveHost = this.serveHost || this.env[envKeys.InngestServeHost];
		const servePath = this.servePath || this.env[envKeys.InngestServePath];
		if (servePath) ret.pathname = servePath;
		if (serveHost) ret = new URL(ret.pathname + ret.search, serveHost);
		return ret;
	}
	registerBody({ url, deployId }) {
		return {
			url: url.href,
			deployType: "ping",
			framework: this.frameworkName,
			appName: this.id,
			functions: this.configs(url),
			sdk: `js:v${version}`,
			v: "0.1",
			deployId: deployId || void 0,
			capabilities: {
				trust_probe: "v1",
				connect: "v1"
			},
			appVersion: this.client.appVersion
		};
	}
	async inBandRegisterBody({ actions, deployId, env, signatureValidation, url }) {
		const registerBody = this.registerBody({
			deployId,
			url
		});
		const introspectionBody = await this.introspectionBody({
			actions,
			env,
			signatureValidation,
			url
		});
		const body = {
			app_id: this.id,
			appVersion: this.client.appVersion,
			capabilities: registerBody.capabilities,
			env,
			framework: registerBody.framework,
			functions: registerBody.functions,
			inspection: introspectionBody,
			platform: getPlatformName({
				...allProcessEnv(),
				...this.env
			}),
			sdk_author: "inngest",
			sdk_language: "",
			sdk_version: "",
			sdk: registerBody.sdk,
			url: registerBody.url
		};
		if (introspectionBody.authentication_succeeded) {
			body.sdk_language = introspectionBody.sdk_language;
			body.sdk_version = introspectionBody.sdk_version;
		}
		return body;
	}
	async introspectionBody({ actions, env, signatureValidation, url }) {
		const registerBody = this.registerBody({
			url: this.reqUrl(url),
			deployId: null
		});
		if (!this._mode) throw new Error("No mode set; cannot introspect without mode");
		let introspection = {
			authentication_succeeded: null,
			extra: { is_mode_explicit: this._mode.isExplicit },
			has_event_key: this.client["eventKeySet"](),
			has_signing_key: Boolean(this.signingKey),
			function_count: registerBody.functions.length,
			mode: this._mode.type,
			schema_version: "2024-05-24"
		};
		if (this._mode.type === "cloud") try {
			if (!(await signatureValidation).success) throw new Error("Signature validation failed");
			introspection = {
				...introspection,
				authentication_succeeded: true,
				api_origin: this.apiBaseUrl,
				app_id: this.id,
				capabilities: {
					trust_probe: "v1",
					connect: "v1"
				},
				env,
				event_api_origin: this.eventApiBaseUrl,
				event_key_hash: this.hashedEventKey ?? null,
				extra: {
					...introspection.extra,
					is_streaming: await this.shouldStream(actions)
				},
				framework: this.frameworkName,
				sdk_language: "js",
				sdk_version: version,
				serve_origin: this.serveHost ?? null,
				serve_path: this.servePath ?? null,
				signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,
				signing_key_hash: this.hashedSigningKey ?? null
			};
		} catch {
			introspection = {
				...introspection,
				authentication_succeeded: false
			};
		}
		return introspection;
	}
	async register(url, deployId, getHeaders) {
		const body = this.registerBody({
			url,
			deployId
		});
		let res;
		let registerURL = new URL(this.inngestRegisterUrl.href);
		if (this._mode && this._mode.isInferred && this._mode.isDev) {
			const host = devServerHost(this.env);
			if (await devServerAvailable(host, this.fetch)) registerURL = devServerUrl(host, "/fn/register");
		} else if (this._mode?.explicitDevUrl) registerURL = devServerUrl(this._mode.explicitDevUrl.href, "/fn/register");
		if (deployId) registerURL.searchParams.set(queryKeys.DeployId, deployId);
		try {
			res = await fetchWithAuthFallback({
				authToken: this.hashedSigningKey,
				authTokenFallback: this.hashedSigningKeyFallback,
				fetch: this.fetch,
				url: registerURL.href,
				options: {
					method: "POST",
					body: stringify(body),
					headers: {
						...await getHeaders(),
						[headerKeys.InngestSyncKind]: syncKind.OutOfBand
					},
					redirect: "follow"
				}
			});
		} catch (err) {
			this.log("error", err);
			return {
				status: 500,
				message: `Failed to register${err instanceof Error ? `; ${err.message}` : ""}`,
				modified: false
			};
		}
		const raw = await res.text();
		let data = {};
		try {
			data = JSON.parse(raw);
		} catch (err) {
			this.log("warn", "Couldn't unpack register response:", err);
			let message = "Failed to register";
			if (err instanceof Error) message += `; ${err.message}`;
			message += `; status code: ${res.status}`;
			return {
				status: 500,
				message,
				modified: false
			};
		}
		let status;
		let error;
		let skipped;
		let modified;
		try {
			({status, error, skipped, modified} = registerResSchema.parse(data));
		} catch (err) {
			this.log("warn", "Invalid register response schema:", err);
			let message = "Failed to register";
			if (err instanceof Error) message += `; ${err.message}`;
			message += `; status code: ${res.status}`;
			return {
				status: 500,
				message,
				modified: false
			};
		}
		if (!skipped) this.log("debug", "registered inngest functions:", res.status, res.statusText, data);
		return {
			status,
			message: error,
			modified
		};
	}
	/**
	* Given an environment, upsert any missing keys. This is useful in
	* situations where environment variables are passed directly to handlers or
	* are otherwise difficult to access during initialization.
	*/
	upsertKeysFromEnv() {
		if (this.env[envKeys.InngestSigningKey]) {
			if (!this.signingKey) this.signingKey = String(this.env[envKeys.InngestSigningKey]);
			this.client["inngestApi"].setSigningKey(this.signingKey);
		}
		if (this.env[envKeys.InngestSigningKeyFallback]) {
			if (!this.signingKeyFallback) this.signingKeyFallback = String(this.env[envKeys.InngestSigningKeyFallback]);
			this.client["inngestApi"].setSigningKeyFallback(this.signingKeyFallback);
		}
		if (!this.client["eventKeySet"]() && this.env[envKeys.InngestEventKey]) this.client.setEventKey(String(this.env[envKeys.InngestEventKey]));
		if (this.env[envKeys.InngestDevServerUrl]) this.log("warn", `Use of ${envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);
	}
	/**
	* Validate the signature of a request and return the signing key used to
	* validate it.
	*/
	async validateSignature(sig, body) {
		try {
			if (this.skipSignatureValidation) return {
				success: true,
				keyUsed: ""
			};
			if (this._mode && !this._mode.isCloud) return {
				success: true,
				keyUsed: ""
			};
			if (!this.signingKey) throw new Error(`No signing key found in client options or ${envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);
			if (!sig) throw new Error(`No ${headerKeys.Signature} provided`);
			return {
				success: true,
				keyUsed: new RequestSignature(sig).verifySignature({
					body,
					allowExpiredSignatures: this.allowExpiredSignatures,
					signingKey: this.signingKey,
					signingKeyFallback: this.signingKeyFallback
				})
			};
		} catch (err) {
			return {
				success: false,
				err
			};
		}
	}
	getResponseSignature(key, body) {
		const now = Date.now();
		return `t=${now}&s=${signDataWithKey(body, key, now.toString())}`;
	}
	/**
	* Log to stdout/stderr if the log level is set to include the given level.
	* The default log level is `"info"`.
	*
	* This is an abstraction over `console.log` and will try to use the correct
	* method for the given log level.  For example, `log("error", "foo")` will
	* call `console.error("foo")`.
	*/
	log(level, ...args) {
		const logLevels$1 = [
			"debug",
			"info",
			"warn",
			"error",
			"fatal",
			"silent"
		];
		const logLevelSetting = logLevels$1.indexOf(this.logLevel);
		if (logLevels$1.indexOf(level) >= logLevelSetting) {
			let logger = console.log;
			if (Object.hasOwn(console, level)) logger = console[level];
			logger(`${logPrefix} ${level} -`, ...args);
		}
	}
};
var RequestSignature = class {
	timestamp;
	signature;
	constructor(sig) {
		const params = new URLSearchParams(sig);
		this.timestamp = params.get("t") || "";
		this.signature = params.get("s") || "";
		if (!this.timestamp || !this.signature) throw new Error(`Invalid ${headerKeys.Signature} provided`);
	}
	hasExpired(allowExpiredSignatures) {
		if (allowExpiredSignatures) return false;
		return Date.now() - (/* @__PURE__ */ new Date(Number.parseInt(this.timestamp) * 1e3)).valueOf() > 1e3 * 60 * 5;
	}
	#verifySignature({ body, signingKey, allowExpiredSignatures }) {
		if (this.hasExpired(allowExpiredSignatures)) throw new Error("Signature has expired");
		if (signDataWithKey(body, signingKey, this.timestamp) !== this.signature) throw new Error("Invalid signature");
	}
	verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures }) {
		try {
			this.#verifySignature({
				body,
				signingKey,
				allowExpiredSignatures
			});
			return signingKey;
		} catch (err) {
			if (!signingKeyFallback) throw err;
			this.#verifySignature({
				body,
				signingKey: signingKeyFallback,
				allowExpiredSignatures
			});
			return signingKeyFallback;
		}
	}
};

//#endregion
export { InngestCommHandler };
//# sourceMappingURL=InngestCommHandler.js.map