{"version":3,"file":"InngestCommHandler.js","names":["acc","defaultLogLevel: typeof this.logLevel","debug","defaultStreamingOption: typeof this.streaming","v","body","method","headers: Record<string, string>","signature: string | undefined","signature","actionRes","actions: HandlerResponseWithErrors","args","fn: { fn: InngestFunction.Any; onFailure: boolean } | undefined","fnId: string | undefined","stepId: string | null | undefined","probe","probeEnum","result","runCompleteOp: OutgoingOp","deployId","version","data","body: InBandRegisterRequest","introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection","res: globalThis.Response","err: unknown","data: z.input<typeof registerResSchema>","status: number","error: string","skipped: boolean","modified: boolean","logLevels: LogLevel[]","logLevels","#verifySignature"],"sources":["../../src/components/InngestCommHandler.ts"],"sourcesContent":["import debug from \"debug\";\nimport { ulid } from \"ulid\";\nimport { z } from \"zod/v3\";\nimport { getAsyncCtx } from \"../experimental\";\nimport {\n  debugPrefix,\n  defaultInngestApiBaseUrl,\n  defaultInngestEventBaseUrl,\n  defaultMaxRetries,\n  dummyEventKey,\n  ExecutionVersion,\n  envKeys,\n  forwardedHeaders,\n  headerKeys,\n  logPrefix,\n  probe as probeEnum,\n  queryKeys,\n  syncKind,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable, devServerUrl } from \"../helpers/devserver.ts\";\nimport { enumFromValue } from \"../helpers/enum.ts\";\nimport {\n  allProcessEnv,\n  devServerHost,\n  type Env,\n  getFetch,\n  getMode,\n  getPlatformName,\n  inngestHeaders,\n  Mode,\n  parseAsBoolean,\n  platformSupportsStreaming,\n} from \"../helpers/env.ts\";\nimport { rethrowError, serializeError } from \"../helpers/errors.ts\";\nimport {\n  type FnData,\n  fetchAllFnData,\n  parseFnData,\n  undefinedToNull,\n} from \"../helpers/functions.ts\";\nimport { fetchWithAuthFallback, signDataWithKey } from \"../helpers/net.ts\";\nimport { runAsPromise } from \"../helpers/promises.ts\";\nimport { ServerTiming } from \"../helpers/ServerTiming.ts\";\nimport { createStream } from \"../helpers/stream.ts\";\nimport { hashEventKey, hashSigningKey, stringify } from \"../helpers/strings.ts\";\nimport type { MaybePromise } from \"../helpers/types.ts\";\nimport {\n  type APIStepPayload,\n  AsyncResponseType,\n  type AsyncResponseValue,\n  type AuthenticatedIntrospection,\n  type EventPayload,\n  type FunctionConfig,\n  functionConfigSchema,\n  type InBandRegisterRequest,\n  inBandSyncRequestBodySchema,\n  type LogLevel,\n  logLevels,\n  type OutgoingOp,\n  type RegisterOptions,\n  type RegisterRequest,\n  StepMode,\n  StepOpCode,\n  type SupportedFrameworkName,\n  type UnauthenticatedIntrospection,\n} from \"../types.ts\";\nimport { version } from \"../version.ts\";\nimport {\n  type ExecutionResult,\n  type ExecutionResultHandler,\n  type ExecutionResultHandlers,\n  type InngestExecutionOptions,\n  PREFERRED_EXECUTION_VERSION,\n} from \"./execution/InngestExecution.ts\";\nimport { _internals } from \"./execution/v1\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport {\n  type CreateExecutionOptions,\n  InngestFunction,\n} from \"./InngestFunction.ts\";\n\n/**\n * A set of options that can be passed to a serve handler, intended to be used\n * by internal and custom serve handlers to provide a consistent interface.\n *\n * @public\n */\nexport interface ServeHandlerOptions extends RegisterOptions {\n  /**\n   * The `Inngest` instance used to declare all functions.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions: readonly InngestFunction.Like[];\n}\n\nexport interface SyncHandlerOptions extends RegisterOptions {\n  /**\n   * The `Inngest` instance used to declare all functions.\n   */\n  client: Inngest.Like;\n\n  /**\n   * The type of response you wish to return to an API endpoint when using steps\n   * within it and we must transition to {@link StepMode.Async}.\n   *\n   * In most cases, this defaults to {@link AsyncResponseType.Redirect}.\n   */\n  asyncResponse?: AsyncResponseValue;\n\n  /**\n   * If defined, this sets the function ID that represents this endpoint.\n   * Without this set, it defaults to using the detected method and path of the\n   * request, for example: `GET /api/my-endpoint`.\n   */\n  functionId?: string;\n\n  /**\n   * Specifies the maximum number of retries for all steps.\n   *\n   * Can be a number from `0` to `20`. Defaults to `3`.\n   */\n  retries?:\n    | 0\n    | 1\n    | 2\n    | 3\n    | 4\n    | 5\n    | 6\n    | 7\n    | 8\n    | 9\n    | 10\n    | 11\n    | 12\n    | 13\n    | 14\n    | 15\n    | 16\n    | 17\n    | 18\n    | 19\n    | 20;\n}\n\nexport interface InternalServeHandlerOptions extends ServeHandlerOptions {\n  /**\n   * Can be used to override the framework name given to a particular serve\n   * handler.\n   */\n  frameworkName?: string;\n\n  /**\n   * Can be used to force the handler to always execute functions regardless of\n   * the request method or other factors.\n   *\n   * This is primarily intended for use with Inngest in APIs, where requests may\n   * not have the usual shape of an Inngest payload, but we want to pull data\n   * and execute.\n   */\n  // forceExecution?: boolean;\n}\n\ninterface InngestCommHandlerOptions<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> extends RegisterOptions {\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   *\n   * This should never be defined by the user; a {@link ServeHandler} should\n   * abstract this.\n   */\n  frameworkName: string;\n\n  /**\n   * The name of this serve handler, e.g. `\"My App\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   *\n   * This can also be an `Inngest` client, in which case the name given when\n   * instantiating the client is used. This is useful if you're sending and\n   * receiving events from the same service, as you can reuse a single\n   * definition of Inngest.\n   */\n  client: Inngest.Like;\n\n  /**\n   * An array of the functions to serve and register with Inngest.\n   */\n  functions?: readonly InngestFunction.Like[];\n\n  /**\n   * The `handler` is the function that will be called with your framework's\n   * request arguments and returns a set of functions that the SDK will use to\n   * access various parts of the request, such as the body, headers, and query\n   * string parameters.\n   *\n   * It also defines how to transform a response from the SDK into a response\n   * that your framework can understand, ensuring headers, status codes, and\n   * body are all set correctly.\n   *\n   * @example\n   * ```ts\n   * function handler (req: Request, res: Response) {\n   *   return {\n   *     method: () => req.method,\n   *     body: () => req.json(),\n   *     headers: (key) => req.headers.get(key),\n   *     url: () => req.url,\n   *     transformResponse: ({ body, headers, status }) => {\n   *       return new Response(body, { status, headers });\n   *     },\n   *   };\n   * };\n   * ```\n   *\n   * See any existing handler for a full example.\n   */\n  handler: Handler<Input, Output, StreamOutput>;\n\n  skipSignatureValidation?: boolean;\n\n  /**\n   * Options for when this comm handler executes a synchronous (API) function.\n   */\n  syncOptions?: SyncHandlerOptions;\n}\n\n/**\n * Capturing the global type of fetch so that we can reliably access it below.\n */\ntype FetchT = typeof fetch;\n\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = z.object({\n  status: z.number().default(200),\n  skipped: z.boolean().optional().default(false),\n  modified: z.boolean().optional().default(false),\n  error: z.string().default(\"Successfully registered\"),\n});\n\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nexport class InngestCommHandler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> {\n  /**\n   * The ID of this serve handler, e.g. `\"my-app\"`. It's recommended that this\n   * value represents the overarching app/service that this set of functions is\n   * being served from.\n   */\n  public readonly id: string;\n\n  /**\n   * The handler specified during instantiation of the class.\n   */\n  public readonly handler: Handler;\n\n  /**\n   * The URL of the Inngest function registration endpoint.\n   */\n  private readonly inngestRegisterUrl: URL;\n\n  /**\n   * The name of the framework this handler is designed for. Should be\n   * lowercase, alphanumeric characters inclusive of `-` and `/`.\n   */\n  protected readonly frameworkName: string;\n\n  /**\n   * The signing key used to validate requests from Inngest. This is\n   * intentionally mutable so that we can pick up the signing key from the\n   * environment during execution if needed.\n   */\n  protected signingKey: string | undefined;\n\n  /**\n   * The same as signingKey, except used as a fallback when auth fails using the\n   * primary signing key.\n   */\n  protected signingKeyFallback: string | undefined;\n\n  /**\n   * A property that can be set to indicate whether we believe we are in\n   * production mode.\n   *\n   * Should be set every time a request is received.\n   */\n  protected _mode: Mode | undefined;\n\n  /**\n   * The localized `fetch` implementation used by this handler.\n   */\n  private readonly fetch: FetchT;\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  private readonly _serveHost: string | undefined;\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   */\n  private readonly _servePath: string | undefined;\n\n  /**\n   * The minimum level to log from the Inngest serve handler.\n   */\n  protected readonly logLevel: LogLevel;\n\n  protected readonly streaming: RegisterOptions[\"streaming\"];\n\n  /**\n   * A private collection of just Inngest functions, as they have been passed\n   * when instantiating the class.\n   */\n  private readonly rawFns: InngestFunction.Any[];\n\n  private readonly client: Inngest.Any;\n\n  /**\n   * A private collection of functions that are being served. This map is used\n   * to find and register functions when interacting with Inngest Cloud.\n   */\n  private readonly fns: Record<\n    string,\n    { fn: InngestFunction.Any; onFailure: boolean }\n  > = {};\n\n  private env: Env = allProcessEnv();\n\n  private allowExpiredSignatures: boolean;\n\n  private readonly _options: InngestCommHandlerOptions<\n    Input,\n    Output,\n    StreamOutput\n  >;\n\n  private readonly skipSignatureValidation: boolean;\n\n  constructor(options: InngestCommHandlerOptions<Input, Output, StreamOutput>) {\n    // Set input options directly so we can reference them later\n    this._options = options;\n\n    /**\n     * v2 -> v3 migration error.\n     *\n     * If a serve handler is passed a client as the first argument, it'll be\n     * spread in to these options. We should be able to detect this by picking\n     * up a unique property on the object.\n     */\n    if (Object.hasOwn(options, \"eventKey\")) {\n      throw new Error(\n        `${logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n\n    this.frameworkName = options.frameworkName;\n    this.client = options.client as Inngest.Any;\n\n    if (options.id) {\n      console.warn(\n        `${logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`,\n      );\n    }\n    this.id = options.id || this.client.id;\n\n    this.handler = options.handler as Handler;\n\n    /**\n     * Provide a hidden option to allow expired signatures to be accepted during\n     * testing.\n     */\n    this.allowExpiredSignatures = Boolean(\n      // biome-ignore lint/complexity/noArguments: <explanation>\n      arguments[\"0\"]?.__testingAllowExpiredSignatures,\n    );\n\n    // Ensure we filter any undefined functions in case of missing imports.\n    this.rawFns = (options.functions?.filter(Boolean) ??\n      []) as InngestFunction.Any[];\n\n    if (this.rawFns.length !== (options.functions ?? []).length) {\n      // TODO PrettyError\n      console.warn(\n        `Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`,\n      );\n    }\n\n    this.fns = this.rawFns.reduce<\n      Record<string, { fn: InngestFunction.Any; onFailure: boolean }>\n    >((acc, fn) => {\n      const configs = fn[\"getConfig\"]({\n        baseUrl: new URL(\"https://example.com\"),\n        appPrefix: this.id,\n      });\n\n      const fns = configs.reduce((acc, { id }, index) => {\n        return { ...acc, [id]: { fn, onFailure: Boolean(index) } };\n      }, {});\n\n      // biome-ignore lint/complexity/noForEach: <explanation>\n      configs.forEach(({ id }) => {\n        if (acc[id]) {\n          // TODO PrettyError\n          throw new Error(\n            `Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`,\n          );\n        }\n      });\n\n      return {\n        ...acc,\n        ...fns,\n      };\n    }, {});\n\n    this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n\n    this.signingKey = options.signingKey;\n    this.signingKeyFallback = options.signingKeyFallback;\n    this._serveHost = options.serveHost || this.env[envKeys.InngestServeHost];\n    this._servePath = options.servePath || this.env[envKeys.InngestServePath];\n\n    this.skipSignatureValidation = options.skipSignatureValidation || false;\n\n    const defaultLogLevel: typeof this.logLevel = \"info\";\n    this.logLevel = z\n      .enum(logLevels)\n      .default(defaultLogLevel)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown log level passed: ${String(\n            ctx.input,\n          )}; defaulting to ${defaultLogLevel}`,\n        );\n\n        return defaultLogLevel;\n      })\n      .parse(options.logLevel || this.env[envKeys.InngestLogLevel]);\n\n    if (this.logLevel === \"debug\") {\n      /**\n       * `debug` is an old library; sometimes its runtime detection doesn't work\n       * for newer pairings of framework/runtime.\n       *\n       * One silly symptom of this is that `Debug()` returns an anonymous\n       * function with no extra properties instead of a `Debugger` instance if\n       * the wrong code is consumed following a bad detection. This results in\n       * the following `.enable()` call failing, so we just try carefully to\n       * enable it here.\n       */\n      if (debug.enable && typeof debug.enable === \"function\") {\n        debug.enable(`${debugPrefix}:*`);\n      }\n    }\n\n    const defaultStreamingOption: typeof this.streaming = false;\n    this.streaming = z\n      .union([z.enum([\"allow\", \"force\"]), z.literal(false)])\n      .default(defaultStreamingOption)\n      .catch((ctx) => {\n        this.log(\n          \"warn\",\n          `Unknown streaming option passed: ${String(\n            ctx.input,\n          )}; defaulting to ${String(defaultStreamingOption)}`,\n        );\n\n        return defaultStreamingOption;\n      })\n      .parse(options.streaming || this.env[envKeys.InngestStreaming]);\n\n    this.fetch = options.fetch ? getFetch(options.fetch) : this.client[\"fetch\"];\n  }\n\n  /**\n   * Get the API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the API base URL\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get apiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.apiBaseUrl ||\n      defaultInngestApiBaseUrl\n    );\n  }\n\n  /**\n   * Get the event API base URL for the Inngest API.\n   *\n   * This is a getter to encourage checking the environment for the event API\n   * base URL each time it's accessed, as it may change during execution.\n   */\n  protected get eventApiBaseUrl(): string {\n    return (\n      this._options.baseUrl ||\n      this.env[envKeys.InngestEventApiBaseUrl] ||\n      this.env[envKeys.InngestBaseUrl] ||\n      this.client.eventBaseUrl ||\n      defaultInngestEventBaseUrl\n    );\n  }\n\n  /**\n   * The host used to access the Inngest serve endpoint, e.g.:\n   *\n   *     \"https://myapp.com\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom hostname here to ensure that the path is reported\n   * correctly when registering functions with Inngest.\n   *\n   * To also provide a custom path, use `servePath`.\n   */\n  protected get serveHost(): string | undefined {\n    return this._serveHost || this.env[envKeys.InngestServeHost];\n  }\n\n  /**\n   * The path to the Inngest serve endpoint. e.g.:\n   *\n   *     \"/some/long/path/to/inngest/endpoint\"\n   *\n   * By default, the library will try to infer this using request details such\n   * as the \"Host\" header and request path, but sometimes this isn't possible\n   * (e.g. when running in a more controlled environments such as AWS Lambda or\n   * when dealing with proxies/redirects).\n   *\n   * Provide the custom path (excluding the hostname) here to ensure that the\n   * path is reported correctly when registering functions with Inngest.\n   *\n   * To also provide a custom hostname, use `serveHost`.\n   *\n   * This is a getter to encourage checking the environment for the serve path\n   * each time it's accessed, as it may change during execution.\n   */\n  protected get servePath(): string | undefined {\n    return this._servePath || this.env[envKeys.InngestServePath];\n  }\n\n  private get hashedEventKey(): string | undefined {\n    if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === dummyEventKey) {\n      return undefined;\n    }\n    return hashEventKey(this.client[\"eventKey\"]);\n  }\n\n  // hashedSigningKey creates a sha256 checksum of the signing key with the\n  // same signing key prefix.\n  private get hashedSigningKey(): string | undefined {\n    if (!this.signingKey) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedSigningKeyFallback(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return undefined;\n    }\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  /**\n   * Returns a `boolean` representing whether this handler will stream responses\n   * or not. Takes into account the user's preference and the platform's\n   * capabilities.\n   */\n  private async shouldStream(\n    actions: HandlerResponseWithErrors,\n  ): Promise<boolean> {\n    const rawProbe = await actions.queryStringWithDefaults(\n      \"testing for probe\",\n      queryKeys.Probe,\n    );\n    if (rawProbe !== undefined) {\n      return false;\n    }\n\n    // We must be able to stream responses to continue.\n    if (!actions.transformStreamingResponse) {\n      return false;\n    }\n\n    // If the user has forced streaming, we should always stream.\n    if (this.streaming === \"force\") {\n      return true;\n    }\n\n    // If the user has allowed streaming, we should stream if the platform\n    // supports it.\n    return (\n      this.streaming === \"allow\" &&\n      platformSupportsStreaming(\n        this.frameworkName as SupportedFrameworkName,\n        this.env,\n      )\n    );\n  }\n\n  private async isInngestReq(\n    actions: HandlerResponseWithErrors,\n  ): Promise<boolean> {\n    const reqMessage = `checking if this is an Inngest request`;\n\n    const [runId, signature] = await Promise.all([\n      actions.headers(reqMessage, headerKeys.InngestRunId),\n      actions.headers(reqMessage, headerKeys.Signature),\n    ]);\n\n    // Note that the signature just has to be present; in Dev it'll be empty,\n    // but still set to `\"\"`.\n    return Boolean(runId && typeof signature === \"string\");\n  }\n\n  /**\n   * Start handling a request, setting up environments, modes, and returning\n   * some helpers.\n   */\n  private async initRequest(...args: Input): Promise<{\n    timer: ServerTiming;\n    actions: HandlerResponseWithErrors;\n    getHeaders: () => Promise<Record<string, string>>;\n  }> {\n    const timer = new ServerTiming();\n    const actions = await this.getActions(timer, ...args);\n\n    const [env, expectedServerKind] = await Promise.all([\n      actions.env?.(\"starting to handle request\"),\n      actions.headers(\n        \"checking expected server kind\",\n        headerKeys.InngestServerKind,\n      ),\n    ]);\n\n    // Always make sure to merge whatever env we've been given with\n    // `process.env`; some platforms may not provide all the necessary\n    // environment variables or may use two sources.\n    this.env = {\n      ...allProcessEnv(),\n      ...env,\n    };\n\n    const headerPromises = forwardedHeaders.map(async (header) => {\n      const value = await actions.headers(\n        `fetching ${header} for forwarding`,\n        header,\n      );\n\n      return { header, value };\n    });\n\n    const headersToForwardP = Promise.all(headerPromises).then(\n      (fetchedHeaders) => {\n        return fetchedHeaders.reduce<Record<string, string>>(\n          (acc, { header, value }) => {\n            if (value) {\n              acc[header] = value;\n            }\n\n            return acc;\n          },\n          {},\n        );\n      },\n    );\n\n    const getHeaders = async (): Promise<Record<string, string>> => ({\n      ...inngestHeaders({\n        env: this.env,\n        framework: this.frameworkName,\n        client: this.client,\n        expectedServerKind: expectedServerKind || undefined,\n        extras: {\n          \"Server-Timing\": timer.getHeader(),\n        },\n      }),\n      ...(await headersToForwardP),\n    });\n\n    const assumedMode = getMode({ env: this.env, client: this.client });\n\n    if (assumedMode.isExplicit) {\n      this._mode = assumedMode;\n    } else {\n      const serveIsProd = await actions.isProduction?.(\n        \"starting to handle request\",\n      );\n      if (typeof serveIsProd === \"boolean\") {\n        this._mode = new Mode({\n          type: serveIsProd ? \"cloud\" : \"dev\",\n          isExplicit: false,\n        });\n      } else {\n        this._mode = assumedMode;\n      }\n    }\n\n    this.upsertKeysFromEnv();\n\n    return {\n      timer,\n      actions,\n      getHeaders,\n    };\n  }\n\n  /**\n   * `createSyncHandler` should be used to return a type-equivalent version of\n   * the `handler` specified during instantiation.\n   */\n  public createSyncHandler<\n    THandler extends (...args: Input) => Promise<Awaited<Output>>,\n  >(): (handler: THandler) => THandler {\n    // Return a function that can be used to wrap endpoints\n    return (handler) => {\n      return this.wrapHandler((async (...args) => {\n        const reqInit = await this.initRequest(...args);\n\n        const fn = new InngestFunction(\n          this.client,\n          {\n            id: this._options.syncOptions?.functionId ?? \"\",\n            retries: this._options.syncOptions?.retries ?? defaultMaxRetries,\n          },\n          () => handler(...args),\n        );\n\n        // Decide if this request looks like an Inngest request. If it does,\n        // we'll just use the regular `serve()` handler for this request, as\n        // it's async.\n        if (await this.isInngestReq(reqInit.actions)) {\n          // If we have a run ID, we can just use the normal serve path\n          // return this.createHandler()(...args);\n          return this.handleAsyncRequest({\n            ...reqInit,\n            forceExecution: true,\n            args,\n            fns: [fn],\n          });\n        }\n\n        // Otherwise, we know this is a sync request, so we can proceed with\n        // creating a sync request to Inngest.\n        return this.handleSyncRequest({\n          ...reqInit,\n          args,\n          asyncMode:\n            this._options.syncOptions?.asyncResponse ??\n            AsyncResponseType.Redirect,\n          fn,\n        });\n      }) as THandler);\n    };\n  }\n\n  /**\n   * `createHandler` should be used to return a type-equivalent version of the\n   * `handler` specified during instantiation.\n   *\n   * @example\n   * ```\n   * // my-custom-handler.ts\n   * import {\n   *   InngestCommHandler,\n   *   type ServeHandlerOptions,\n   * } from \"./components/InngestCommHandler\";\n   *\n   * export const serve = (options: ServeHandlerOptions) => {\n   *   const handler = new InngestCommHandler({\n   *     frameworkName: \"my-custom-handler\",\n   *     ...options,\n   *     handler: (req: Request) => {\n   *       return {\n   *         body: () => req.json(),\n   *         headers: (key) => req.headers.get(key),\n   *         method: () => req.method,\n   *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n   *         transformResponse: ({ body, status, headers }) => {\n   *           return new Response(body, { status, headers });\n   *         },\n   *       };\n   *     },\n   *   });\n   *\n   *   return handler.createHandler();\n   * };\n   * ```\n   */\n  public createHandler<\n    THandler extends (...args: Input) => Promise<Awaited<Output>>,\n  >(): THandler {\n    return this.wrapHandler((async (...args) => {\n      return this.handleAsyncRequest({\n        ...(await this.initRequest(...args)),\n        args,\n      });\n    }) as THandler);\n  }\n\n  /**\n   * Given a set of actions that let us access the incoming request, create a\n   * `http/run.started` event that repesents a run starting from an HTTP\n   * request.\n   */\n  private async createHttpEvent(\n    actions: HandlerResponseWithErrors,\n    fn: InngestFunction.Any,\n  ): Promise<APIStepPayload> {\n    const reason = \"creating sync event\";\n\n    const contentTypePromise = actions\n      .headers(reason, headerKeys.ContentType)\n      .then((v) => v ?? \"\");\n\n    const ipPromise = actions\n      .headers(reason, headerKeys.ForwardedFor)\n      .then((v) => {\n        if (v) return v;\n\n        return actions.headers(reason, headerKeys.RealIp).then((v) => v ?? \"\");\n      });\n\n    const methodPromise = actions.method(reason);\n\n    const urlPromise = actions.url(reason).then((v) => this.reqUrl(v));\n\n    const domainPromise = urlPromise.then(\n      (url) => `${url.protocol}//${url.host}`,\n    );\n\n    const pathPromise = urlPromise.then((url) => url.pathname);\n\n    const queryParamsPromise = urlPromise.then((url) =>\n      url.searchParams.toString(),\n    );\n\n    // TODO For body, we can add `textBody()` to the actions\n    const bodyPromise = actions.textBody!(reason).then((body) => {\n      return typeof body === \"string\" ? body : stringify(body);\n    });\n\n    const [contentType, domain, ip, method, path, queryParams, body] =\n      await Promise.all([\n        contentTypePromise,\n        domainPromise,\n        ipPromise,\n        methodPromise,\n        pathPromise,\n        queryParamsPromise,\n        bodyPromise,\n      ]);\n\n    return {\n      name: \"http/run.started\",\n      data: {\n        content_type: contentType,\n        domain,\n        ip,\n        method,\n        path,\n        query_params: queryParams,\n        body,\n        fn: fn.id(),\n      },\n    };\n  }\n\n  private async handleSyncRequest({\n    timer,\n    actions,\n    fn,\n    asyncMode,\n    args,\n  }: {\n    timer: ServerTiming;\n    actions: HandlerResponseWithErrors;\n    fn: InngestFunction.Any;\n    asyncMode: AsyncResponseValue;\n    args: unknown[];\n  }): Promise<Awaited<Output>> {\n    // Do we have actions for handling sync requests? We must!\n    if (!actions.experimentalTransformSyncResponse) {\n      throw new Error(\n        \"This platform does not support synchronous Inngest function executions.\",\n      );\n    }\n\n    // Check we're not in a context already...\n    const ctx = await getAsyncCtx();\n    if (ctx) {\n      throw new Error(\n        \"We already seem to be in the context of an Inngest execution, but didn't expect to be. Did you already wrap this handler?\",\n      );\n    }\n\n    // We create a new run ID here in the SDK.\n    const runId = ulid();\n    const event = await this.createHttpEvent(actions, fn);\n\n    // TODO Nope. Should be v2, so we now have two preferred versions...\n    const exeVersion = PREFERRED_EXECUTION_VERSION;\n\n    const exe = fn[\"createExecution\"]({\n      version: exeVersion,\n      partialOptions: {\n        client: this.client,\n        data: {\n          runId,\n          event,\n          attempt: 0,\n          events: [event],\n          maxAttempts: fn.opts.retries ?? defaultMaxRetries,\n        },\n        runId,\n        headers: {},\n        reqArgs: args,\n        stepCompletionOrder: [],\n        stepState: {},\n        disableImmediateExecution: false,\n        isFailureHandler: false,\n        timer,\n        createResponse: (data: unknown) =>\n          actions.experimentalTransformSyncResponse!(\n            \"creating sync execution\",\n            data,\n          ).then((res) => ({\n            ...res,\n            version: exeVersion,\n          })),\n        stepMode: StepMode.Sync,\n      },\n    });\n\n    const result = await exe.start();\n\n    const resultHandlers: ExecutionResultHandlers<unknown> = {\n      \"step-not-found\": () => {\n        throw new Error(\n          \"We should not get the result 'step-not-found' when checkpointing. This is a bug in the `inngest` SDK\",\n        );\n      },\n      \"steps-found\": () => {\n        throw new Error(\n          \"We should not get the result 'steps-found' when checkpointing. This is a bug in the `inngest` SDK\",\n        );\n      },\n      \"step-ran\": () => {\n        throw new Error(\n          \"We should not get the result 'step-ran' when checkpointing. This is a bug in the `inngest` SDK\",\n        );\n      },\n      \"function-rejected\": () => {\n        throw new Error(\n          \"We should not get the result 'function-rejected' when checkpointing. This is a bug in the `inngest` SDK\",\n        );\n      },\n      \"function-resolved\": ({ data }) => {\n        // We're done and we didn't call any step tools, so just return the\n        // response.\n        return data;\n      },\n      \"change-mode\": async ({ token }) => {\n        switch (asyncMode) {\n          case AsyncResponseType.Redirect: {\n            return actions.transformResponse(\n              \"creating sync->async redirect response\",\n              {\n                status: 302,\n                headers: {\n                  [headerKeys.Location]: await this.client[\"inngestApi\"]\n                    [\"getTargetUrl\"](\n                      `/v1/http/runs/${runId}/output?token=${token}`,\n                    )\n                    .then((url) => url.toString()),\n                },\n                version: exeVersion,\n                body: \"\",\n              },\n            );\n          }\n\n          case AsyncResponseType.Token: {\n            return actions.transformResponse(\n              \"creating sync->async token response\",\n              {\n                status: 200,\n                headers: {},\n                version: exeVersion,\n                body: stringify({ run_id: runId, token }),\n              },\n            );\n          }\n\n          default: {\n            // TODO user-provided hook mate, incl. req args\n            break;\n          }\n        }\n\n        throw new Error(\"Not implemented: change-mode\");\n      },\n    };\n\n    const resultHandler = resultHandlers[\n      result.type\n    ] as ExecutionResultHandler<unknown>;\n    if (!resultHandler) {\n      throw new Error(\n        `No handler for execution result type: ${result.type}. This is a bug in the \\`inngest\\` SDK`,\n      );\n    }\n\n    return resultHandler(result) as Awaited<Output>;\n  }\n\n  private async handleAsyncRequest({\n    timer,\n    actions,\n    args,\n    getHeaders,\n    forceExecution,\n    fns,\n  }: {\n    timer: ServerTiming;\n    actions: HandlerResponseWithErrors;\n    args: Input;\n    getHeaders: () => Promise<Record<string, string>>;\n    forceExecution?: boolean;\n    fns?: InngestFunction.Any[];\n  }): Promise<Awaited<Output>> {\n    if (forceExecution && !actions.experimentalTransformSyncResponse) {\n      throw new Error(\n        \"This platform does not support async executions in Inngest for APIs.\",\n      );\n    }\n\n    const methodP = actions.method(\"starting to handle request\");\n\n    const contentLength = await actions\n      .headers(\"checking signature for request\", headerKeys.ContentLength)\n      .then((value) => {\n        if (!value) {\n          return undefined;\n        }\n        return Number.parseInt(value, 10);\n      });\n\n    const [signature, method, body] = await Promise.all([\n      actions\n        .headers(\"checking signature for request\", headerKeys.Signature)\n        .then((headerSignature) => {\n          return headerSignature ?? undefined;\n        }),\n      methodP,\n      methodP.then((method) => {\n        if (method === \"POST\" || method === \"PUT\") {\n          if (!contentLength) {\n            // Return empty string because req.json() will throw an error.\n            return \"\";\n          }\n\n          return actions.body(\n            `checking body for request signing as method is ${method}`,\n          );\n        }\n\n        return \"\";\n      }),\n    ]);\n\n    const signatureValidation = this.validateSignature(signature, body);\n\n    const actionRes = timer.wrap(\"action\", () =>\n      this.handleAction({\n        actions,\n        timer,\n        getHeaders,\n        reqArgs: args,\n        signatureValidation,\n        body,\n        method,\n        forceExecution: Boolean(forceExecution),\n        fns,\n      }),\n    );\n\n    /**\n     * Prepares an action response by merging returned data to provide\n     * trailing information such as `Server-Timing` headers.\n     *\n     * It should always prioritize the headers returned by the action, as they\n     * may contain important information such as `Content-Type`.\n     */\n    const prepareActionRes = async (\n      res: ActionResponse,\n    ): Promise<ActionResponse> => {\n      const headers: Record<string, string> = {\n        ...(await getHeaders()),\n        ...res.headers,\n        ...(res.version === null\n          ? {}\n          : {\n              [headerKeys.RequestVersion]: (\n                res.version ?? PREFERRED_EXECUTION_VERSION\n              ).toString(),\n            }),\n      };\n\n      let signature: string | undefined;\n\n      try {\n        signature = await signatureValidation.then((result) => {\n          if (!result.success || !result.keyUsed) {\n            return undefined;\n          }\n\n          return this.getResponseSignature(result.keyUsed, res.body);\n        });\n      } catch (err) {\n        // If we fail to sign, retun a 500 with the error.\n        return {\n          ...res,\n          headers,\n          body: stringify(serializeError(err)),\n          status: 500,\n        };\n      }\n\n      if (signature) {\n        headers[headerKeys.Signature] = signature;\n      }\n\n      return {\n        ...res,\n        headers,\n      };\n    };\n\n    if (await this.shouldStream(actions)) {\n      const method = await actions.method(\"starting streaming response\");\n\n      if (method === \"POST\") {\n        const { stream, finalize } = await createStream();\n\n        /**\n         * Errors are handled by `handleAction` here to ensure that an\n         * appropriate response is always given.\n         */\n        void actionRes.then((res) => {\n          return finalize(prepareActionRes(res));\n        });\n\n        return timer.wrap(\"res\", async () => {\n          return actions.transformStreamingResponse?.(\n            \"starting streaming response\",\n            {\n              status: 201,\n              headers: await getHeaders(),\n              body: stream,\n              version: null,\n            },\n          );\n        });\n      }\n    }\n\n    return timer.wrap(\"res\", async () => {\n      return actionRes.then(prepareActionRes).then((actionRes) => {\n        return actions.transformResponse(\"sending back response\", actionRes);\n      });\n    });\n  }\n\n  private async getActions(\n    timer: ServerTiming,\n    ...args: Input\n  ): Promise<HandlerResponseWithErrors> {\n    /**\n     * Used for testing, allow setting action overrides externally when\n     * calling the handler. Always search the final argument.\n     */\n    const lastArg = args[args.length - 1] as unknown;\n    const actionOverrides =\n      typeof lastArg === \"object\" &&\n      lastArg !== null &&\n      \"actionOverrides\" in lastArg &&\n      typeof lastArg[\"actionOverrides\"] === \"object\" &&\n      lastArg[\"actionOverrides\"] !== null\n        ? lastArg[\"actionOverrides\"]\n        : {};\n\n    /**\n     * We purposefully `await` the handler, as it could be either sync or\n     * async.\n     */\n    const rawActions = {\n      ...(await timer\n        .wrap(\"handler\", () => this.handler(...args))\n        .catch(rethrowError(\"Serve handler failed to run\"))),\n      ...actionOverrides,\n    };\n\n    /**\n     * Map over every `action` in `rawActions` and create a new `actions`\n     * object where each function is safely promisified with each access\n     * requiring a reason.\n     *\n     * This helps us provide high quality errors about what's going wrong for\n     * each access without having to wrap every access in a try/catch.\n     */\n    const promisifiedActions: ActionHandlerResponseWithErrors = Object.entries(\n      rawActions,\n    ).reduce((acc, [key, value]) => {\n      if (typeof value !== \"function\") {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [key]: (reason: string, ...args: unknown[]) => {\n          const errMessage = [\n            `Failed calling \\`${key}\\` from serve handler`,\n            reason,\n          ]\n            .filter(Boolean)\n            .join(\" when \");\n\n          const fn = () => (value as (...args: unknown[]) => unknown)(...args);\n\n          return runAsPromise(fn)\n            .catch(rethrowError(errMessage))\n            .catch((err) => {\n              this.log(\"error\", err);\n              throw err;\n            });\n        },\n      };\n    }, {} as ActionHandlerResponseWithErrors);\n\n    /**\n     * Mapped promisified handlers from userland `serve()` function mixed in\n     * with some helpers.\n     */\n    const actions: HandlerResponseWithErrors = {\n      ...promisifiedActions,\n      queryStringWithDefaults: async (\n        reason: string,\n        key: string,\n      ): Promise<string | undefined> => {\n        const url = await actions.url(reason);\n\n        const ret =\n          (await actions.queryString?.(reason, key, url)) ||\n          url.searchParams.get(key) ||\n          undefined;\n\n        return ret;\n      },\n      ...actionOverrides,\n    };\n\n    return actions;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: any fn\n  private wrapHandler<THandler extends (...args: any[]) => any>(\n    handler: THandler,\n  ): THandler {\n    /**\n     * Some platforms check (at runtime) the length of the function being used\n     * to handle an endpoint. If this is a variadic function, it will fail that\n     * check.\n     *\n     * Therefore, we expect the arguments accepted to be the same length as the\n     * `handler` function passed internally.\n     *\n     * We also set a name to avoid a common useless name in tracing such as\n     * `\"anonymous\"` or `\"bound function\"`.\n     *\n     * https://github.com/getsentry/sentry-javascript/issues/3284\n     */\n    Object.defineProperties(handler, {\n      name: {\n        value: \"InngestHandler\",\n      },\n      length: {\n        value: this.handler.length,\n      },\n    });\n\n    return handler;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private get mode(): Mode | undefined {\n    return this._mode;\n  }\n\n  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: used in the SDK\n  private set mode(m) {\n    this._mode = m;\n\n    if (m) {\n      this.client[\"mode\"] = m;\n    }\n  }\n\n  /**\n   * Given a set of functions to check if an action is available from the\n   * instance's handler, enact any action that is found.\n   *\n   * This method can fetch varying payloads of data, but ultimately is the place\n   * where _decisions_ are made regarding functionality.\n   *\n   * For example, if we find that we should be viewing the UI, this function\n   * will decide whether the UI should be visible based on the payload it has\n   * found (e.g. env vars, options, etc).\n   */\n  private async handleAction({\n    actions,\n    timer,\n    getHeaders,\n    reqArgs,\n    signatureValidation,\n    body: rawBody,\n    method,\n    forceExecution,\n    fns,\n  }: {\n    actions: HandlerResponseWithErrors;\n    timer: ServerTiming;\n    getHeaders: () => Promise<Record<string, string>>;\n    reqArgs: unknown[];\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    body: unknown;\n    method: string;\n    forceExecution: boolean;\n    fns?: InngestFunction.Any[];\n  }): Promise<ActionResponse> {\n    // This is when the request body is completely missing; it does not\n    // include an empty body. This commonly happens when the HTTP framework\n    // doesn't have body parsing middleware.\n    const isMissingBody = rawBody === undefined;\n    let body = rawBody;\n\n    try {\n      let url = await actions.url(\"starting to handle request\");\n\n      if (method === \"POST\" || forceExecution) {\n        if (!forceExecution && isMissingBody) {\n          this.log(\n            \"error\",\n            \"Missing body when executing, possibly due to missing request body middleware\",\n          );\n\n          return {\n            status: 500,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(\n              serializeError(\n                new Error(\n                  \"Missing request body when executing, possibly due to missing request body middleware\",\n                ),\n              ),\n            ),\n            version: undefined,\n          };\n        }\n\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          return {\n            status: 401,\n            headers: {\n              \"Content-Type\": \"application/json\",\n            },\n            body: stringify(serializeError(validationResult.err)),\n            version: undefined,\n          };\n        }\n\n        let fn: { fn: InngestFunction.Any; onFailure: boolean } | undefined;\n        let fnId: string | undefined;\n        let stepId: string | null | undefined;\n\n        if (forceExecution) {\n          fn =\n            fns?.length && fns[0]\n              ? { fn: fns[0], onFailure: false }\n              : Object.values(this.fns)[0];\n          fnId = fn?.fn.id();\n          stepId = \"step\"; // Checkpointed runs are never parallel atm, so this is hardcoded\n          body = {\n            event: {},\n            events: [],\n            steps: {},\n            version: PREFERRED_EXECUTION_VERSION,\n            ctx: {\n              attempt: 0,\n              disable_immediate_execution: false,\n              use_api: true,\n              max_attempts: 3,\n              run_id: await actions.headers(\n                \"getting run ID for forced execution\",\n                headerKeys.InngestRunId,\n              ),\n              // TODO We need this to be given to us or the API to return it\n              stack: { stack: [], current: 0 },\n            },\n          } as Extract<FnData, { version: typeof PREFERRED_EXECUTION_VERSION }>;\n        } else {\n          const rawProbe = await actions.queryStringWithDefaults(\n            \"testing for probe\",\n            queryKeys.Probe,\n          );\n          if (rawProbe) {\n            const probe = enumFromValue(probeEnum, rawProbe);\n            if (!probe) {\n              // If we're here, we've received a probe that we don't recognize.\n              // Fail.\n              return {\n                status: 400,\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                body: stringify(\n                  serializeError(new Error(`Unknown probe \"${rawProbe}\"`)),\n                ),\n                version: undefined,\n              };\n            }\n\n            // Provide actions for every probe available.\n            const probeActions: Record<\n              probeEnum,\n              () => MaybePromise<ActionResponse>\n            > = {\n              [probeEnum.Trust]: () => ({\n                status: 200,\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                body: \"\",\n                version: undefined,\n              }),\n            };\n\n            return probeActions[probe]();\n          }\n\n          fnId = await actions.queryStringWithDefaults(\n            \"processing run request\",\n            queryKeys.FnId,\n          );\n          if (!fnId) {\n            // TODO PrettyError\n            throw new Error(\"No function ID found in async request\");\n          }\n\n          fn = this.fns[fnId];\n\n          stepId =\n            (await actions.queryStringWithDefaults(\n              \"processing run request\",\n              queryKeys.StepId,\n            )) || null;\n        }\n\n        if (typeof fnId === \"undefined\" || !fn) {\n          throw new Error(\"No function ID found in request\");\n        }\n\n        const { version, result } = this.runStep({\n          functionId: fnId,\n          data: body,\n          stepId,\n          timer,\n          reqArgs,\n          headers: await getHeaders(),\n          fn,\n          forceExecution,\n          actions,\n        });\n        const stepOutput = await result;\n\n        /**\n         * Functions can return `undefined`, but we'll always convert this to\n         * `null`, as this is appropriately serializable by JSON.\n         */\n        const opDataUndefinedToNull = (op: OutgoingOp) => {\n          op.data = undefinedToNull(op.data);\n          return op;\n        };\n\n        const resultHandlers: ExecutionResultHandlers<ActionResponse> = {\n          \"function-rejected\": (result) => {\n            return {\n              status: result.retriable ? 500 : 400,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                ...(typeof result.retriable === \"string\"\n                  ? { [headerKeys.RetryAfter]: result.retriable }\n                  : {}),\n              },\n              body: stringify(undefinedToNull(result.error)),\n              version,\n            };\n          },\n          \"function-resolved\": (result) => {\n            if (forceExecution) {\n              const runCompleteOp: OutgoingOp = {\n                id: _internals.hashId(\"complete\"),\n                op: StepOpCode.RunComplete,\n                data: undefinedToNull(result.data),\n              };\n\n              return {\n                status: 206,\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                body: stringify(runCompleteOp),\n                version,\n              };\n            }\n\n            return {\n              status: 200,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(undefinedToNull(result.data)),\n              version,\n            };\n          },\n          \"step-not-found\": (result) => {\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: \"false\",\n              },\n              body: stringify({\n                error: `Could not find step \"${\n                  result.step.displayName || result.step.id\n                }\" to run; timed out`,\n              }),\n              version,\n            };\n          },\n          \"step-ran\": (result) => {\n            const step = opDataUndefinedToNull(result.step);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                ...(typeof result.retriable !== \"undefined\"\n                  ? {\n                      [headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\",\n                      ...(typeof result.retriable === \"string\"\n                        ? { [headerKeys.RetryAfter]: result.retriable }\n                        : {}),\n                    }\n                  : {}),\n              },\n              body: stringify([step]),\n              version,\n            };\n          },\n          \"steps-found\": (result) => {\n            const steps = result.steps.map(opDataUndefinedToNull);\n\n            return {\n              status: 206,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(steps),\n              version,\n            };\n          },\n          \"change-mode\": (result) => {\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n                [headerKeys.NoRetry]: \"true\",\n              },\n              body: stringify({\n                error: `We wanted to change mode to \"${result.to}\", but this is not supported within the InngestCommHandler. This is a bug in the Inngest SDK.`,\n              }),\n              version,\n            };\n          },\n        };\n\n        const handler = resultHandlers[\n          stepOutput.type\n        ] as ExecutionResultHandler<ActionResponse>;\n\n        try {\n          return await handler(stepOutput);\n        } catch (err) {\n          this.log(\"error\", \"Error handling execution result\", err);\n          throw err;\n        }\n      }\n\n      // TODO: This feels hacky, so we should probably make it not hacky.\n      const env = (await getHeaders())[headerKeys.Environment] ?? null;\n\n      if (method === \"GET\") {\n        return {\n          status: 200,\n          body: stringify(\n            await this.introspectionBody({\n              actions,\n              env,\n              signatureValidation,\n              url,\n            }),\n          ),\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          version: undefined,\n        };\n      }\n\n      if (method === \"PUT\") {\n        const [deployId, inBandSyncRequested] = await Promise.all([\n          actions\n            .queryStringWithDefaults(\n              \"processing deployment request\",\n              queryKeys.DeployId,\n            )\n            .then((deployId) => {\n              return deployId === \"undefined\" ? undefined : deployId;\n            }),\n\n          Promise.resolve(\n            parseAsBoolean(this.env[envKeys.InngestAllowInBandSync]),\n          )\n            .then((allowInBandSync) => {\n              if (allowInBandSync !== undefined && !allowInBandSync) {\n                return syncKind.OutOfBand;\n              }\n\n              return actions.headers(\n                \"processing deployment request\",\n                headerKeys.InngestSyncKind,\n              );\n            })\n            .then((kind) => {\n              return kind === syncKind.InBand;\n            }),\n        ]);\n\n        if (inBandSyncRequested) {\n          if (isMissingBody) {\n            this.log(\n              \"error\",\n              \"Missing body when syncing, possibly due to missing request body middleware\",\n            );\n\n            return {\n              status: 500,\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              body: stringify(\n                serializeError(\n                  new Error(\n                    \"Missing request body when syncing, possibly due to missing request body middleware\",\n                  ),\n                ),\n              ),\n              version: undefined,\n            };\n          }\n\n          // Validation can be successful if we're in dev mode and did not\n          // actually validate a key. In this case, also check that we did indeed\n          // use a particular key to validate.\n          const sigCheck = await signatureValidation;\n\n          if (!sigCheck.success) {\n            return {\n              status: 401,\n              body: stringify({\n                code: \"sig_verification_failed\",\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          const res = inBandSyncRequestBodySchema.safeParse(body);\n          if (!res.success) {\n            return {\n              status: 400,\n              body: stringify({\n                code: \"invalid_request\",\n                message: res.error.message,\n              }),\n              headers: {\n                \"Content-Type\": \"application/json\",\n              },\n              version: undefined,\n            };\n          }\n\n          // We can trust the URL here because it's coming from\n          // signature-verified request.\n          url = this.reqUrl(new URL(res.data.url));\n\n          // This should be an in-band sync\n          const respBody = await this.inBandRegisterBody({\n            actions,\n            deployId,\n            env,\n            signatureValidation,\n            url,\n          });\n\n          return {\n            status: 200,\n            body: stringify(respBody),\n            headers: {\n              \"Content-Type\": \"application/json\",\n              [headerKeys.InngestSyncKind]: syncKind.InBand,\n            },\n            version: undefined,\n          };\n        }\n\n        // If we're here, this is a legacy out-of-band sync\n        const { status, message, modified } = await this.register(\n          this.reqUrl(url),\n          deployId,\n          getHeaders,\n        );\n\n        return {\n          status,\n          body: stringify({ message, modified }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          version: undefined,\n        };\n      }\n    } catch (err) {\n      return {\n        status: 500,\n        body: stringify({\n          type: \"internal\",\n          ...serializeError(err as Error),\n        }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        version: undefined,\n      };\n    }\n\n    return {\n      status: 405,\n      body: JSON.stringify({\n        message: \"No action found; request was likely not POST, PUT, or GET\",\n        mode: this._mode,\n      }),\n      headers: {},\n      version: undefined,\n    };\n  }\n\n  protected runStep({\n    actions,\n    functionId,\n    stepId,\n    data,\n    timer,\n    reqArgs,\n    headers,\n    fn,\n    forceExecution,\n  }: {\n    actions: HandlerResponseWithErrors;\n    functionId: string;\n    stepId: string | null;\n    data: unknown;\n    timer: ServerTiming;\n    reqArgs: unknown[];\n    headers: Record<string, string>;\n    fn: { fn: InngestFunction.Any; onFailure: boolean };\n    forceExecution: boolean;\n  }): { version: ExecutionVersion; result: Promise<ExecutionResult> } {\n    if (!fn) {\n      // TODO PrettyError\n      throw new Error(`Could not find function with ID \"${functionId}\"`);\n    }\n\n    const immediateFnData = parseFnData(data);\n    let { version } = immediateFnData;\n\n    // Handle opting in to optimized parallelism in v3.\n    if (\n      version === ExecutionVersion.V1 &&\n      fn.fn[\"shouldOptimizeParallelism\"]?.()\n    ) {\n      version = ExecutionVersion.V2;\n    }\n\n    const result = runAsPromise(async () => {\n      const anyFnData = await fetchAllFnData({\n        data: immediateFnData,\n        api: this.client[\"inngestApi\"],\n        version,\n      });\n\n      if (!anyFnData.ok) {\n        throw new Error(anyFnData.error);\n      }\n\n      type ExecutionStarter<V> = (\n        fnData: V extends ExecutionVersion\n          ? Extract<FnData, { version: V }>\n          : FnData,\n      ) => MaybePromise<CreateExecutionOptions>;\n\n      type GenericExecutionStarters = Record<\n        ExecutionVersion,\n        ExecutionStarter<unknown>\n      >;\n\n      type ExecutionStarters = {\n        [V in ExecutionVersion]: ExecutionStarter<V>;\n      };\n\n      const createResponse =\n        forceExecution && actions.experimentalTransformSyncResponse\n          ? (data: unknown) =>\n              actions.experimentalTransformSyncResponse!(\n                \"created sync->async response\",\n                data,\n              ).then((res) => ({\n                ...res,\n                version,\n              }))\n          : undefined;\n\n      const executionStarters = ((s: ExecutionStarters) =>\n        s as GenericExecutionStarters)({\n        [ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, data]) => {\n            return {\n              ...acc,\n\n              [id]: { id, data },\n            };\n          }, {});\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              stepMode: StepMode.Async,\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n              },\n              stepState,\n              requestedRunStep:\n                stepId === \"step\" ? undefined : stepId || undefined,\n              timer,\n              isFailureHandler: fn.onFailure,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n              createResponse,\n            },\n          };\n        },\n        [ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          const requestedRunStep =\n            stepId === \"step\" ? undefined : stepId || undefined;\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              stepMode: fn.fn[\"shouldAsyncCheckpoint\"](\n                requestedRunStep,\n                ctx?.fn_id,\n                Boolean(ctx?.disable_immediate_execution),\n              )\n                ? StepMode.AsyncCheckpointing\n                : StepMode.Async,\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n                maxAttempts: ctx?.max_attempts,\n              },\n              internalFnId: ctx?.fn_id,\n              queueItemId: ctx?.qi_id,\n              stepState,\n              requestedRunStep,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n              createResponse,\n            },\n          };\n        },\n        [ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n          const stepState = Object.entries(steps ?? {}).reduce<\n            InngestExecutionOptions[\"stepState\"]\n          >((acc, [id, result]) => {\n            return {\n              ...acc,\n              [id]:\n                result.type === \"data\"\n                  ? { id, data: result.data }\n                  : result.type === \"input\"\n                    ? { id, input: result.input }\n                    : { id, error: result.error },\n            };\n          }, {});\n\n          const requestedRunStep =\n            stepId === \"step\" ? undefined : stepId || undefined;\n\n          return {\n            version,\n            partialOptions: {\n              client: this.client,\n              runId: ctx?.run_id || \"\",\n              stepMode: fn.fn[\"shouldAsyncCheckpoint\"](\n                requestedRunStep,\n                ctx?.fn_id,\n                Boolean(ctx?.disable_immediate_execution),\n              )\n                ? StepMode.AsyncCheckpointing\n                : StepMode.Async,\n              data: {\n                event: event as EventPayload,\n                events: events as [EventPayload, ...EventPayload[]],\n                runId: ctx?.run_id || \"\",\n                attempt: ctx?.attempt ?? 0,\n                maxAttempts: ctx?.max_attempts,\n              },\n              internalFnId: ctx?.fn_id,\n              queueItemId: ctx?.qi_id,\n              stepState,\n              requestedRunStep,\n              timer,\n              isFailureHandler: fn.onFailure,\n              disableImmediateExecution: ctx?.disable_immediate_execution,\n              stepCompletionOrder: ctx?.stack?.stack ?? [],\n              reqArgs,\n              headers,\n              createResponse,\n            },\n          };\n        },\n      });\n\n      const executionOptions = await executionStarters[version](\n        anyFnData.value,\n      );\n\n      return fn.fn[\"createExecution\"](executionOptions).start();\n    });\n\n    return { version, result };\n  }\n\n  protected configs(url: URL): FunctionConfig[] {\n    const configs = Object.values(this.rawFns).reduce<FunctionConfig[]>(\n      (acc, fn) => [\n        ...acc,\n        ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n      ],\n      [],\n    );\n\n    for (const config of configs) {\n      const check = functionConfigSchema.safeParse(config);\n      if (!check.success) {\n        const errors = check.error.errors.map((err) => err.message).join(\"; \");\n\n        this.log(\n          \"warn\",\n          `Config invalid for function \"${config.id}\" : ${errors}`,\n        );\n      }\n    }\n\n    return configs;\n  }\n\n  /**\n   * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n   *\n   * Will automatically use the `serveHost` and `servePath` if they have been\n   * set when registering.\n   */\n  protected reqUrl(url: URL): URL {\n    let ret = new URL(url);\n\n    const serveHost = this.serveHost || this.env[envKeys.InngestServeHost];\n    const servePath = this.servePath || this.env[envKeys.InngestServePath];\n\n    if (servePath) {\n      ret.pathname = servePath;\n    }\n\n    if (serveHost) {\n      ret = new URL(ret.pathname + ret.search, serveHost);\n    }\n\n    return ret;\n  }\n\n  protected registerBody({\n    url,\n    deployId,\n  }: {\n    url: URL;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n  }): RegisterRequest {\n    const body: RegisterRequest = {\n      url: url.href,\n      deployType: \"ping\",\n      framework: this.frameworkName,\n      appName: this.id,\n      functions: this.configs(url),\n      sdk: `js:v${version}`,\n      v: \"0.1\",\n      deployId: deployId || undefined,\n      capabilities: {\n        trust_probe: \"v1\",\n        connect: \"v1\",\n      },\n      appVersion: this.client.appVersion,\n    };\n\n    return body;\n  }\n\n  protected async inBandRegisterBody({\n    actions,\n    deployId,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n\n    /**\n     * Non-optional to ensure we always consider if we have a deploy ID\n     * available to us to use.\n     */\n    deployId: string | undefined | null;\n\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n\n    url: URL;\n  }): Promise<InBandRegisterRequest> {\n    const registerBody = this.registerBody({ deployId, url });\n    const introspectionBody = await this.introspectionBody({\n      actions,\n      env,\n      signatureValidation,\n      url,\n    });\n\n    const body: InBandRegisterRequest = {\n      app_id: this.id,\n      appVersion: this.client.appVersion,\n      capabilities: registerBody.capabilities,\n      env,\n      framework: registerBody.framework,\n      functions: registerBody.functions,\n      inspection: introspectionBody,\n      platform: getPlatformName({\n        ...allProcessEnv(),\n        ...this.env,\n      }),\n      sdk_author: \"inngest\",\n      sdk_language: \"\",\n      sdk_version: \"\",\n      sdk: registerBody.sdk,\n      url: registerBody.url,\n    };\n\n    if (introspectionBody.authentication_succeeded) {\n      body.sdk_language = introspectionBody.sdk_language;\n      body.sdk_version = introspectionBody.sdk_version;\n    }\n\n    return body;\n  }\n\n  protected async introspectionBody({\n    actions,\n    env,\n    signatureValidation,\n    url,\n  }: {\n    actions: HandlerResponseWithErrors;\n    env: string | null;\n    signatureValidation: ReturnType<InngestCommHandler[\"validateSignature\"]>;\n    url: URL;\n  }): Promise<UnauthenticatedIntrospection | AuthenticatedIntrospection> {\n    const registerBody = this.registerBody({\n      url: this.reqUrl(url),\n      deployId: null,\n    });\n\n    if (!this._mode) {\n      throw new Error(\"No mode set; cannot introspect without mode\");\n    }\n\n    let introspection:\n      | UnauthenticatedIntrospection\n      | AuthenticatedIntrospection = {\n      authentication_succeeded: null,\n      extra: {\n        is_mode_explicit: this._mode.isExplicit,\n      },\n      has_event_key: this.client[\"eventKeySet\"](),\n      has_signing_key: Boolean(this.signingKey),\n      function_count: registerBody.functions.length,\n      mode: this._mode.type,\n      schema_version: \"2024-05-24\",\n    } satisfies UnauthenticatedIntrospection;\n\n    // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n    // signature validation\n    if (this._mode.type === \"cloud\") {\n      try {\n        const validationResult = await signatureValidation;\n        if (!validationResult.success) {\n          throw new Error(\"Signature validation failed\");\n        }\n\n        introspection = {\n          ...introspection,\n          authentication_succeeded: true,\n          api_origin: this.apiBaseUrl,\n          app_id: this.id,\n          capabilities: {\n            trust_probe: \"v1\",\n            connect: \"v1\",\n          },\n          env,\n          event_api_origin: this.eventApiBaseUrl,\n          event_key_hash: this.hashedEventKey ?? null,\n          extra: {\n            ...introspection.extra,\n            is_streaming: await this.shouldStream(actions),\n          },\n          framework: this.frameworkName,\n          sdk_language: \"js\",\n          sdk_version: version,\n          serve_origin: this.serveHost ?? null,\n          serve_path: this.servePath ?? null,\n          signing_key_fallback_hash: this.hashedSigningKeyFallback ?? null,\n          signing_key_hash: this.hashedSigningKey ?? null,\n        } satisfies AuthenticatedIntrospection;\n      } catch {\n        // Swallow signature validation error since we'll just return the\n        // unauthenticated introspection\n        introspection = {\n          ...introspection,\n          authentication_succeeded: false,\n        } satisfies UnauthenticatedIntrospection;\n      }\n    }\n\n    return introspection;\n  }\n\n  protected async register(\n    url: URL,\n    deployId: string | undefined | null,\n    getHeaders: () => Promise<Record<string, string>>,\n  ): Promise<{ status: number; message: string; modified: boolean }> {\n    const body = this.registerBody({ url, deployId });\n\n    let res: globalThis.Response;\n\n    // Whenever we register, we check to see if the dev server is up.  This\n    // is a noop and returns false in production. Clone the URL object to avoid\n    // mutating the property between requests.\n    let registerURL = new URL(this.inngestRegisterUrl.href);\n\n    const inferredDevMode =\n      this._mode && this._mode.isInferred && this._mode.isDev;\n\n    if (inferredDevMode) {\n      const host = devServerHost(this.env);\n      const hasDevServer = await devServerAvailable(host, this.fetch);\n      if (hasDevServer) {\n        registerURL = devServerUrl(host, \"/fn/register\");\n      }\n    } else if (this._mode?.explicitDevUrl) {\n      registerURL = devServerUrl(\n        this._mode.explicitDevUrl.href,\n        \"/fn/register\",\n      );\n    }\n\n    if (deployId) {\n      registerURL.searchParams.set(queryKeys.DeployId, deployId);\n    }\n\n    try {\n      res = await fetchWithAuthFallback({\n        authToken: this.hashedSigningKey,\n        authTokenFallback: this.hashedSigningKeyFallback,\n        fetch: this.fetch,\n        url: registerURL.href,\n        options: {\n          method: \"POST\",\n          body: stringify(body),\n          headers: {\n            ...(await getHeaders()),\n            [headerKeys.InngestSyncKind]: syncKind.OutOfBand,\n          },\n          redirect: \"follow\",\n        },\n      });\n    } catch (err: unknown) {\n      this.log(\"error\", err);\n\n      return {\n        status: 500,\n        message: `Failed to register${\n          err instanceof Error ? `; ${err.message}` : \"\"\n        }`,\n        modified: false,\n      };\n    }\n\n    const raw = await res.text();\n\n    let data: z.input<typeof registerResSchema> = {};\n\n    try {\n      data = JSON.parse(raw);\n    } catch (err) {\n      this.log(\"warn\", \"Couldn't unpack register response:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    let status: number;\n    let error: string;\n    let skipped: boolean;\n    let modified: boolean;\n    try {\n      ({ status, error, skipped, modified } = registerResSchema.parse(data));\n    } catch (err) {\n      this.log(\"warn\", \"Invalid register response schema:\", err);\n\n      let message = \"Failed to register\";\n      if (err instanceof Error) {\n        message += `; ${err.message}`;\n      }\n      message += `; status code: ${res.status}`;\n\n      return {\n        status: 500,\n        message,\n        modified: false,\n      };\n    }\n\n    // The dev server polls this endpoint to register functions every few\n    // seconds, but we only want to log that we've registered functions if\n    // the function definitions change.  Therefore, we compare the body sent\n    // during registration with the body of the current functions and refuse\n    // to register if the functions are the same.\n    if (!skipped) {\n      this.log(\n        \"debug\",\n        \"registered inngest functions:\",\n        res.status,\n        res.statusText,\n        data,\n      );\n    }\n\n    return { status, message: error, modified };\n  }\n\n  /**\n   * Given an environment, upsert any missing keys. This is useful in\n   * situations where environment variables are passed directly to handlers or\n   * are otherwise difficult to access during initialization.\n   */\n  private upsertKeysFromEnv() {\n    if (this.env[envKeys.InngestSigningKey]) {\n      if (!this.signingKey) {\n        this.signingKey = String(this.env[envKeys.InngestSigningKey]);\n      }\n\n      this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n    }\n\n    if (this.env[envKeys.InngestSigningKeyFallback]) {\n      if (!this.signingKeyFallback) {\n        this.signingKeyFallback = String(\n          this.env[envKeys.InngestSigningKeyFallback],\n        );\n      }\n\n      this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n    }\n\n    if (!this.client[\"eventKeySet\"]() && this.env[envKeys.InngestEventKey]) {\n      this.client.setEventKey(String(this.env[envKeys.InngestEventKey]));\n    }\n\n    // v2 -> v3 migration warnings\n    if (this.env[envKeys.InngestDevServerUrl]) {\n      this.log(\n        \"warn\",\n        `Use of ${envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`,\n      );\n    }\n  }\n\n  /**\n   * Validate the signature of a request and return the signing key used to\n   * validate it.\n   */\n\n  protected async validateSignature(\n    sig: string | undefined,\n    body: unknown,\n  ): Promise<\n    { success: true; keyUsed: string } | { success: false; err: Error }\n  > {\n    try {\n      // Skip signature validation if requested (used by connect)\n      if (this.skipSignatureValidation) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // Never validate signatures outside of prod. Make sure to check the mode\n      // exists here instead of using nullish coalescing to confirm that the check\n      // has been completed.\n      if (this._mode && !this._mode.isCloud) {\n        return { success: true, keyUsed: \"\" };\n      }\n\n      // If we're here, we're in production; lack of a signing key is an error.\n      if (!this.signingKey) {\n        // TODO PrettyError\n        throw new Error(\n          `No signing key found in client options or ${envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`,\n        );\n      }\n\n      // If we're here, we're in production; lack of a req signature is an error.\n      if (!sig) {\n        // TODO PrettyError\n        throw new Error(`No ${headerKeys.Signature} provided`);\n      }\n\n      // Validate the signature\n      return {\n        success: true,\n        keyUsed: new RequestSignature(sig).verifySignature({\n          body,\n          allowExpiredSignatures: this.allowExpiredSignatures,\n          signingKey: this.signingKey,\n          signingKeyFallback: this.signingKeyFallback,\n        }),\n      };\n    } catch (err) {\n      return { success: false, err: err as Error };\n    }\n  }\n\n  protected getResponseSignature(key: string, body: string): string {\n    const now = Date.now();\n    const mac = signDataWithKey(body, key, now.toString());\n\n    return `t=${now}&s=${mac}`;\n  }\n\n  /**\n   * Log to stdout/stderr if the log level is set to include the given level.\n   * The default log level is `\"info\"`.\n   *\n   * This is an abstraction over `console.log` and will try to use the correct\n   * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n   * call `console.error(\"foo\")`.\n   */\n  protected log(level: LogLevel, ...args: unknown[]) {\n    const logLevels: LogLevel[] = [\n      \"debug\",\n      \"info\",\n      \"warn\",\n      \"error\",\n      \"fatal\",\n      \"silent\",\n    ];\n\n    const logLevelSetting = logLevels.indexOf(this.logLevel);\n    const currentLevel = logLevels.indexOf(level);\n\n    if (currentLevel >= logLevelSetting) {\n      let logger = console.log;\n\n      if (Object.hasOwn(console, level)) {\n        logger = console[level as keyof typeof console] as typeof logger;\n      }\n\n      logger(`${logPrefix} ${level as string} -`, ...args);\n    }\n  }\n}\n\nclass RequestSignature {\n  public timestamp: string;\n  public signature: string;\n\n  constructor(sig: string) {\n    const params = new URLSearchParams(sig);\n    this.timestamp = params.get(\"t\") || \"\";\n    this.signature = params.get(\"s\") || \"\";\n\n    if (!this.timestamp || !this.signature) {\n      // TODO PrettyError\n      throw new Error(`Invalid ${headerKeys.Signature} provided`);\n    }\n  }\n\n  private hasExpired(allowExpiredSignatures?: boolean) {\n    if (allowExpiredSignatures) {\n      return false;\n    }\n\n    const delta =\n      Date.now() - new Date(Number.parseInt(this.timestamp) * 1000).valueOf();\n    return delta > 1000 * 60 * 5;\n  }\n\n  #verifySignature({\n    body,\n    signingKey,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    allowExpiredSignatures: boolean;\n  }): void {\n    if (this.hasExpired(allowExpiredSignatures)) {\n      // TODO PrettyError\n      throw new Error(\"Signature has expired\");\n    }\n\n    const mac = signDataWithKey(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n      // TODO PrettyError\n      throw new Error(\"Invalid signature\");\n    }\n  }\n\n  public verifySignature({\n    body,\n    signingKey,\n    signingKeyFallback,\n    allowExpiredSignatures,\n  }: {\n    body: unknown;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    allowExpiredSignatures: boolean;\n  }): string {\n    try {\n      this.#verifySignature({ body, signingKey, allowExpiredSignatures });\n\n      return signingKey;\n    } catch (err) {\n      if (!signingKeyFallback) {\n        throw err;\n      }\n\n      this.#verifySignature({\n        body,\n        signingKey: signingKeyFallback,\n        allowExpiredSignatures,\n      });\n\n      return signingKeyFallback;\n    }\n  }\n}\n\n/**\n * The broad definition of a handler passed when instantiating an\n * {@link InngestCommHandler} instance.\n */\nexport type Handler<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Input extends any[] = any[],\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  Output = any,\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  StreamOutput = any,\n> = (...args: Input) => HandlerResponse<Output, StreamOutput>;\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\nexport type HandlerResponse<Output = any, StreamOutput = any> = {\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  body: () => MaybePromise<any>;\n  textBody?: (() => MaybePromise<string>) | null; // TODO Make this required | null\n  env?: () => MaybePromise<Env | undefined>;\n  headers: (key: string) => MaybePromise<string | null | undefined>;\n\n  /**\n   * Whether the current environment is production. This is used to determine\n   * some functionality like whether to connect to the dev server or whether to\n   * show debug logging.\n   *\n   * If this is not provided--or is provided and returns `undefined`--we'll try\n   * to automatically detect whether we're in production by checking various\n   * environment variables.\n   */\n  isProduction?: () => MaybePromise<boolean | undefined>;\n  method: () => MaybePromise<string>;\n  queryString?: (\n    key: string,\n    url: URL,\n  ) => MaybePromise<string | null | undefined>;\n  url: () => MaybePromise<URL>;\n\n  /**\n   * The `transformResponse` function receives the output of the Inngest SDK and\n   * can decide how to package up that information to appropriately return the\n   * information to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and a stringified `body`. This ensures\n   * you can appropriately handle the response, including use of any required\n   * parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformResponse: (res: ActionResponse<string>) => Output;\n\n  /**\n   * The `transformStreamingResponse` function, if defined, declares that this\n   * handler supports streaming responses back to Inngest. This is useful for\n   * functions that are expected to take a long time, as edge streaming can\n   * often circumvent restrictive request timeouts and other limitations.\n   *\n   * If your handler does not support streaming, do not define this function.\n   *\n   * It receives the output of the Inngest SDK and can decide how to package\n   * up that information to appropriately return the information in a stream\n   * to Inngest.\n   *\n   * Mostly, this is taking the given parameters and returning a new `Response`.\n   *\n   * The function is passed an {@link ActionResponse}, an object containing a\n   * `status` code, a `headers` object, and `body`, a `ReadableStream`. This\n   * ensures you can appropriately handle the response, including use of any\n   * required parameters such as `res` in Express-/Connect-like frameworks.\n   */\n  transformStreamingResponse?: (\n    res: ActionResponse<ReadableStream>,\n  ) => StreamOutput;\n\n  /**\n   * TODO Needed to give folks a chance to wrap arguments if they need to in\n   * order to extract the request body so that it can be sent back to Inngest\n   * during either sync or async calls.\n   *\n   * This is because usually they do not interact directly with e.g. the\n   * `Response` object, but with sync mode they do, so we need to provide hooks\n   * to let us access the body.\n   */\n  experimentalTransformSyncRequest?: (\n    ...args: unknown[]\n  ) => MaybePromise<unknown>;\n\n  /**\n   * TODO Needed to give folks a chance to transform the response from their own\n   * code to an Inngestish response. This is only needed so that sync mode can\n   * checkpoint the response if we've gone through the entire run with no\n   * interruptions.\n   *\n   * Because of its location when being specified, we have scoped access to the\n   * `reqArgs` (e.g. `req` and `res`), so we don't need to pass them here.\n   */\n  experimentalTransformSyncResponse?: (\n    data: unknown,\n  ) => MaybePromise<Omit<ActionResponse, \"version\">>;\n};\n\n/**\n * The response from the Inngest SDK before it is transformed in to a\n * framework-compatible response by an {@link InngestCommHandler} instance.\n */\nexport interface ActionResponse<\n  TBody extends string | ReadableStream = string,\n> {\n  /**\n   * The HTTP status code to return.\n   */\n  status: number;\n\n  /**\n   * The headers to return in the response.\n   */\n  headers: Record<string, string>;\n\n  /**\n   * A stringified body to return.\n   */\n  body: TBody;\n\n  /**\n   * The version of the execution engine that was used to run this action.\n   *\n   * If the action didn't use the execution engine (for example, a GET request\n   * as a health check) or would have but errored before reaching it, this will\n   * be `undefined`.\n   *\n   * If the version should be entirely omitted from the response (for example,\n   * when sending preliminary headers when streaming), this will be `null`.\n   */\n  version: ExecutionVersion | null | undefined;\n}\n\n/**\n * A version of {@link HandlerResponse} where each function is safely\n * promisified and requires a reason for each access.\n *\n * This enables us to provide accurate errors for each access without having to\n * wrap every access in a try/catch.\n */\nexport type ActionHandlerResponseWithErrors = {\n  [K in keyof HandlerResponse]: NonNullable<HandlerResponse[K]> extends (\n    ...args: infer Args\n  ) => infer R\n    ? R extends MaybePromise<infer PR>\n      ? (errMessage: string, ...args: Args) => Promise<PR>\n      : (errMessage: string, ...args: Args) => Promise<R>\n    : HandlerResponse[K];\n};\n\n/**\n * A version of {@link ActionHandlerResponseWithErrors} that includes helper\n * functions that provide sensible defaults on top of the direct access given\n * from the bare response.\n */\nexport interface HandlerResponseWithErrors\n  extends ActionHandlerResponseWithErrors {\n  /**\n   * Fetch a query string value from the request. If no `querystring` action has\n   * been provided by the `serve()` handler, this will fall back to using the\n   * provided URL present in the request to parse the query string from instead.\n   */\n  queryStringWithDefaults: (\n    reason: string,\n    key: string,\n  ) => Promise<string | undefined>;\n}\n"],"mappings":"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"}