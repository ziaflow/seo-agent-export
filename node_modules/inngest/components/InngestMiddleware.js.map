{"version":3,"file":"InngestMiddleware.js","names":["key","hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n}"],"sources":["../../src/components/InngestMiddleware.ts"],"sourcesContent":["import { cacheFn, waterfall } from \"../helpers/functions.ts\";\nimport type {\n  Await,\n  MaybePromise,\n  ObjectAssign,\n  PartialK,\n  Simplify,\n} from \"../helpers/types.ts\";\nimport type {\n  BaseContext,\n  EventPayload,\n  IncomingOp,\n  OutgoingOp,\n  SendEventBaseOutput,\n  TriggersFromClient,\n} from \"../types.ts\";\nimport type { Inngest } from \"./Inngest.ts\";\nimport type { InngestFunction } from \"./InngestFunction.ts\";\n\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nexport class InngestMiddleware<TOpts extends MiddlewareOptions>\n  implements InngestMiddleware.Like\n{\n  get [Symbol.toStringTag](): typeof InngestMiddleware.Tag {\n    return InngestMiddleware.Tag;\n  }\n\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  public readonly name: TOpts[\"name\"];\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  public readonly init: TOpts[\"init\"];\n\n  constructor({ name, init }: TOpts) {\n    this.name = name;\n    this.init = init;\n  }\n}\n\nexport namespace InngestMiddleware {\n  export const Tag = \"Inngest.Middleware\" as const;\n\n  export type Any = InngestMiddleware<MiddlewareOptions>;\n  export interface Like {\n    readonly [Symbol.toStringTag]: typeof InngestMiddleware.Tag;\n  }\n  export type Stack = [InngestMiddleware.Like, ...InngestMiddleware.Like[]];\n}\n\ntype FnsWithSameInputAsOutput<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = {\n  [K in keyof TRecord as Await<TRecord[K]> extends Parameters<TRecord[K]>[0]\n    ? K\n    : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n      Await<TRecord[K]> extends undefined | void\n      ? // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n        Parameters<TRecord[K]>[0] extends undefined | void\n        ? K\n        : never\n      : never]: TRecord[K];\n};\n\ntype PromisifiedFunctionRecord<\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TRecord extends Record<string, (arg: any) => any>,\n> = Pick<\n  Partial<{\n    [K in keyof TRecord]: (\n      ...args: Parameters<TRecord[K]>\n    ) => Promise<Await<TRecord[K]>>;\n  }>,\n  keyof FnsWithSameInputAsOutput<TRecord>\n> &\n  Omit<\n    Partial<{\n      [K in keyof TRecord]: (\n        ...args: Parameters<TRecord[K]>\n      ) => Promise<Parameters<TRecord[K]>[0]>;\n    }>,\n    keyof FnsWithSameInputAsOutput<TRecord>\n  >;\n\nexport type RunHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onFunctionRun\"]>\n>;\n\nexport type SendEventHookStack = PromisifiedFunctionRecord<\n  Await<MiddlewareRegisterReturn[\"onSendEvent\"]>\n>;\n\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nexport const getHookStack = async <\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  TMiddleware extends Record<string, (arg: any) => any>,\n  TKey extends keyof TMiddleware,\n  TResult extends Await<TMiddleware[TKey]>,\n  TRet extends\n    PromisifiedFunctionRecord<TResult> = PromisifiedFunctionRecord<TResult>,\n>(\n  /**\n   * The stack of middleware that will be used to run hooks.\n   */\n  middleware: Promise<TMiddleware[]>,\n\n  /**\n   * The hook type to initialize.\n   */\n  key: TKey,\n\n  /**\n   * Arguments for the initial hook.\n   */\n  arg: Parameters<TMiddleware[TKey]>[0],\n\n  transforms: PartialK<\n    {\n      [K in keyof TResult]-?: (\n        prev: Parameters<TResult[K]>[0],\n        output: Await<TResult[K]>,\n      ) => Parameters<TResult[K]>[0];\n    },\n    keyof {\n      [K in keyof TResult as Await<TResult[K]> extends Parameters<TResult[K]>[0]\n        ? K\n        : // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n          Await<TResult[K]> extends undefined | void\n          ? K\n          : never]: undefined;\n    }\n  >,\n): Promise<TRet> => {\n  // Get directions of hooks before we start running the middleware.\n  const hookDirs = hookDirections[key as keyof typeof hookDirections];\n  if (!hookDirs) {\n    throw new Error(\n      `No hook directions found for key \"${String(key)}\". This is likely a bug in the Inngest SDK.`,\n    );\n  }\n\n  // Wait for middleware to initialize\n  const mwStack = await middleware;\n\n  // Step through each middleware and get the hook for the given key\n  const keyFns = mwStack.reduce(\n    (acc, mw) => {\n      const fn = mw[key];\n\n      if (fn) {\n        return [...acc, fn];\n      }\n\n      return acc;\n    },\n    [] as NonNullable<TMiddleware[TKey]>[],\n  );\n\n  // Run each hook found in sequence and collect the results\n  const hooksRegistered = await keyFns.reduce<\n    Promise<Await<TMiddleware[TKey]>[]>\n  >(async (acc, fn) => {\n    return [...(await acc), await fn(arg)];\n  }, Promise.resolve([]));\n\n  // Prepare the return object - mutating this instead of using reduce as it\n  // results in cleaner code.\n  const ret = {} as TRet;\n\n  // Step through each hook result and create a waterfall joining each key\n  for (const hook of hooksRegistered) {\n    const hookKeys = Object.keys(hook) as (keyof TRet)[];\n\n    for (const key of hookKeys) {\n      let fns = [hook[key]];\n\n      const existingWaterfall = ret[key];\n      if (existingWaterfall) {\n        if (hookDirs[key as keyof typeof hookDirs] === \"forward\") {\n          fns = [existingWaterfall, hook[key]];\n        } else {\n          // For backward hooks, put the new hook before the existing waterfall\n          // This creates the proper onion pattern: [foo, bar] -> [bar, foo] for after* hooks\n          fns = [hook[key], existingWaterfall];\n        }\n      }\n\n      const transform = transforms[key as keyof typeof transforms] as (\n        arg: Await<(typeof fns)[number]>,\n      ) => Parameters<(typeof fns)[number]>;\n\n      ret[key] = waterfall(fns, transform) as TRet[keyof TRet];\n    }\n  }\n\n  // Cache each function in the stack to ensure each can only be called once\n  for (const k of Object.keys(ret)) {\n    const key = k as keyof typeof ret;\n\n    ret[key] = cacheFn(\n      ret[key] as (...args: unknown[]) => unknown,\n    ) as unknown as TRet[keyof TRet];\n  }\n\n  return ret;\n};\n\n/**\n * Options passed to new {@link InngestMiddleware} instance.\n *\n * @public\n */\nexport interface MiddlewareOptions {\n  /**\n   * The name of this middleware. Used primarily for debugging and logging\n   * purposes.\n   */\n  name: string;\n\n  /**\n   * This function is used to initialize your middleware and register any hooks\n   * you want to use. It will be called once when the SDK is initialized, and\n   * should be used to store any state you want to use in other parts of your\n   * middleware.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Multiple clients could be used in the same application with differing\n   * middleware, so do not store state in global variables or assume that your\n   * middleware will only be used once.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  init: MiddlewareRegisterFn;\n}\n\n/**\n * @public\n */\nexport type MiddlewareRegisterReturn = {\n  /**\n   * This hook is called for every function execution and allows you to hook\n   * into various stages of a run's lifecycle. Use this to store any state you\n   * want to use for the entirety of a particular run.\n   *\n   * It can be synchronous or asynchronous, in which case the client will wait\n   * for it to resolve before continuing to initialize the next middleware.\n   *\n   * Must return an object detailing the hooks you want to register.\n   */\n  onFunctionRun?: (ctx: InitialRunInfo) => MaybePromise<{\n    /**\n     * The `input` hook is called once the input for the function has been\n     * properly set up. This is where you can modify the input before the\n     * function starts to memoize or execute by returning an object containing\n     * changes to the context.\n     *\n     * For example, to add `foo` to the context, you'd return\n     * `{ ctx: { foo: \"bar\" } }`.\n     *\n     * @param ctx - The context for the incoming request.\n     * @param steps - The step data in state. Does not include internal IDs.\n     */\n    transformInput?: MiddlewareRunInput;\n\n    /**\n     * The `beforeMemoization` hook is called before the function starts to\n     * memoize.\n     */\n    beforeMemoization?: BlankHook;\n\n    /**\n     * The `afterMemoization` hook is called after the function has finished\n     * memoizing.\n     */\n    afterMemoization?: BlankHook;\n\n    /**\n     * The `beforeExecution` hook is called before the function starts to\n     * execute. Execution here means that new code is being seen/run for the\n     * first time.\n     */\n    beforeExecution?: BlankHook;\n\n    /**\n     * The `afterExecution` hook is called after the function has finished\n     * executing.\n     */\n    afterExecution?: BlankHook;\n\n    /**\n     * The `output` hook is called after the function has finished executing\n     * and before the response is sent back to Inngest. This is where you\n     * can modify the output before it's sent back to Inngest by returning\n     * an object containing changes.\n     *\n     * @param err - The raw error that was thrown by the function, if any, so\n     * that you can capture exact error messages and stack traces.\n     *\n     * @param data - The prepared-but-unserialized data that was returned by\n     * the function, if any, so that you can modify the output.\n     */\n    transformOutput?: MiddlewareRunOutput;\n\n    /**\n     * The `finished` hook is called when the function has finished executing\n     * and has returned a final response that will end the run, either a\n     * successful or error response. In the case of an error response, further\n     * retries may be attempted and call this hook again.\n     *\n     * The output provided will be after `transformOutput` has been applied.\n     *\n     * This is not guaranteed to be called on every execution, and may be called\n     * multiple times if many parallel executions reach the end of the function;\n     * for a guaranteed single execution, create a function with an event\n     * trigger of `\"inngest/function.finished\"`.\n     */\n    finished?: MiddlewareRunFinished;\n\n    /**\n     * The `beforeResponse` hook is called after the output has been set and\n     * before the response is sent back to Inngest. This is where you can\n     * perform any final actions before the response is sent back to Inngest and\n     * is the final hook called.\n     */\n    beforeResponse?: BlankHook;\n  }>;\n\n  /**\n   * The `sendEvent` hook is called every time an event is sent to Inngest.\n   */\n  onSendEvent?: () => MaybePromise<{\n    /**\n     * The `input` hook is called before the event is sent to Inngest. This\n     * is where you can modify the event before it's sent to Inngest by\n     * returning an object containing changes.\n     */\n    transformInput?: MiddlewareSendEventInput;\n\n    /**\n     * The `output` hook is called after the event has been sent to Inngest.\n     * This is where you can perform any final actions after the event has\n     * been sent to Inngest and can modify the output the SDK sees.\n     */\n    transformOutput?: MiddlewareSendEventOutput;\n  }>;\n};\n\n/**\n * The direction of each hook that exists in the middleware lifecycle.\n * This is used to determine whether hooks found in a stack run forwards or\n * backwards, creating onion-like behaviour.\n */\nconst hookDirections: {\n  [K in keyof MiddlewareRegisterReturn]: Record<\n    keyof Await<NonNullable<MiddlewareRegisterReturn[K]>>,\n    \"forward\" | \"backward\"\n  >;\n} = {\n  onFunctionRun: {\n    transformInput: \"forward\",\n    beforeMemoization: \"forward\",\n    afterMemoization: \"backward\",\n    beforeExecution: \"forward\",\n    afterExecution: \"backward\",\n    transformOutput: \"backward\",\n    beforeResponse: \"forward\",\n    finished: \"forward\",\n  },\n  onSendEvent: {\n    transformInput: \"forward\",\n    transformOutput: \"backward\",\n  },\n};\n\n/**\n * @public\n */\nexport type MiddlewareRegisterFn = (ctx: {\n  /**\n   * The client this middleware is being registered on.\n   */\n  client: Inngest.Any;\n\n  /**\n   * If defined, this middleware has been applied directly to an Inngest\n   * function rather than on the client.\n   */\n  fn?: InngestFunction.Any;\n}) => MaybePromise<MiddlewareRegisterReturn>;\n\n/**\n * A blank, no-op hook that passes nothing and expects nothing in return.\n *\n * @internal\n */\ntype BlankHook = () => MaybePromise<void>;\n\n/**\n * Arguments sent to some `run` lifecycle hooks of a middleware.\n *\n * @internal\n */\ntype MiddlewareRunArgs = Readonly<{\n  /**\n   * The context object that will be passed to the function. This contains\n   * event data, some contextual data such as the run's ID, and step tooling.\n   */\n  ctx: Record<string, unknown> &\n    Readonly<BaseContext<Inngest.Any, TriggersFromClient<Inngest.Any>>>; // TODO Acceptable?\n\n  /**\n   * The step data that will be passed to the function.\n   */\n  steps: Readonly<IncomingOp>[];\n\n  /**\n   * The function that is being executed.\n   */\n  fn: InngestFunction.Any;\n\n  /**\n   * The raw arguments given to serve handler being used to execute the\n   * function.\n   */\n  reqArgs: Readonly<unknown[]>;\n}>;\n\n/**\n * The specific arguments sent to the `run` hook when an execution has begun.\n * Differs from {@link MiddlewareRunArgs} in that we don't have a complete\n * context yet.\n *\n * @internal\n */\ntype InitialRunInfo = Readonly<\n  Simplify<\n    Omit<MiddlewareRunArgs, \"ctx\"> & {\n      /**\n       * A partial context object that will be passed to the function. Does not\n       * necessarily contain all the data that will be passed to the function.\n       */\n      ctx: Readonly<{\n        event: EventPayload;\n        runId: string;\n      }>;\n    }\n  >\n>;\n\n/**\n * The shape of an `input` hook within a `run`, optionally returning change to\n * the context or steps.\n *\n * @internal\n */\ntype MiddlewareRunInput = (ctx: MiddlewareRunArgs) => MaybePromise<\n  | {\n      ctx?: Record<string, unknown>;\n      steps?: Pick<IncomingOp, \"data\">[];\n      // We need these in the future to allow users to specify their own complex\n      // types for transforming data above using just inference. e.g. every field\n      // ending with \"_at\" is transformed to a Date.\n      //\n      // transformEvent?: (event: EventPayload) => unknown;\n      // transformStep?: (data: unknown) => unknown;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventInput hook\n *\n * @internal\n */\ntype MiddlewareSendEventInputArgs = Readonly<{\n  payloads: ReadonlyArray<EventPayload>;\n}>;\n\n/**\n * The shape of an `input` hook within a `sendEvent`, optionally returning\n * change to the payloads.\n *\n * @internal\n */\ntype MiddlewareSendEventInput = (\n  ctx: MiddlewareSendEventInputArgs,\n) => MaybePromise<\n  | {\n      payloads?: EventPayload[];\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\n/**\n * Arguments for the SendEventOutput hook\n *\n * @internal\n */\ntype MiddlewareSendEventOutputArgs = { result: Readonly<SendEventBaseOutput> };\n\n/**\n * The shape of an `output` hook within a `sendEvent`, optionally returning a\n * change to the result value.\n */\ntype MiddlewareSendEventOutput = (\n  ctx: MiddlewareSendEventOutputArgs,\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n) => MaybePromise<{ result?: Record<string, unknown> } | undefined | void>;\n\n/**\n * @internal\n */\ntype MiddlewareRunOutput = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n  step?: Readonly<Omit<OutgoingOp, \"id\">>;\n}) => MaybePromise<\n  | {\n      result?: Partial<Pick<OutgoingOp, \"data\" | \"error\">>;\n    }\n  | undefined\n  // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n  | void\n>;\n\ntype MiddlewareRunFinished = (ctx: {\n  result: Readonly<Pick<OutgoingOp, \"error\" | \"data\">>;\n}) => MaybePromise<void>;\n\n/**\n * @internal\n */\ntype GetMiddlewareRunInputMutation<TMiddleware extends InngestMiddleware.Like> =\n  TMiddleware extends InngestMiddleware<infer TOpts>\n    ? TOpts[\"init\"] extends MiddlewareRegisterFn\n      ? Await<\n          Await<Await<TOpts[\"init\"]>[\"onFunctionRun\"]>[\"transformInput\"]\n        > extends {\n          ctx: infer TCtx;\n        }\n        ? {\n            [K in keyof TCtx]: TCtx[K];\n          }\n        : {}\n      : {}\n    : {};\n\n/**\n * @internal\n */\ntype GetMiddlewareSendEventOutputMutation<\n  TMiddleware extends InngestMiddleware.Like,\n> = TMiddleware extends InngestMiddleware<infer TOpts>\n  ? TOpts[\"init\"] extends MiddlewareRegisterFn\n    ? Await<\n        Await<Await<TOpts[\"init\"]>[\"onSendEvent\"]>[\"transformOutput\"]\n      > extends {\n        result: infer TResult;\n      }\n      ? {\n          [K in keyof TResult]: TResult[K];\n        }\n      : {}\n    : {}\n  : {};\n\n/**\n * @internal\n */\nexport type MiddlewareStackSendEventOutputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareSendEventOutputMutation<\n      TMiddleware[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackRunInputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\nexport type ExtendSendEventWithMiddleware<\n  TMiddlewareStacks extends InngestMiddleware.Stack[],\n  TContext = {},\n> = ObjectAssign<\n  {\n    [K in keyof TMiddlewareStacks]: MiddlewareStackSendEventOutputMutation<\n      {},\n      TMiddlewareStacks[K]\n    >;\n  },\n  TContext\n>;\n\n/**\n * @internal\n */\nexport type MiddlewareStackRunInputMutation<\n  TContext,\n  TMiddleware extends InngestMiddleware.Stack,\n> = ObjectAssign<\n  {\n    [K in keyof TMiddleware]: GetMiddlewareRunInputMutation<TMiddleware[K]>;\n  },\n  TContext\n>;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AA0CA,IAAa,oBAAb,MAAa,kBAEb;CACE,KAAK,OAAO,eAA6C;AACvD,SAAO,kBAAkB;;;;;;CAO3B,AAAgB;;;;;;;;;;;;;;;;CAiBhB,AAAgB;CAEhB,YAAY,EAAE,MAAM,QAAe;AACjC,OAAK,OAAO;AACZ,OAAK,OAAO;;;;0BAKK;;;;;;;;;AA2DrB,MAAa,eAAe,OAW1B,YAKA,KAKA,KAEA,eAgBkB;CAElB,MAAM,WAAW,eAAe;AAChC,KAAI,CAAC,SACH,OAAM,IAAI,MACR,qCAAqC,OAAO,IAAI,CAAC,6CAClD;CAqBH,MAAM,kBAAkB,OAjBR,MAAM,YAGC,QACpB,KAAK,OAAO;EACX,MAAM,KAAK,GAAG;AAEd,MAAI,GACF,QAAO,CAAC,GAAG,KAAK,GAAG;AAGrB,SAAO;IAET,EAAE,CACH,CAGoC,OAEnC,OAAO,KAAK,OAAO;AACnB,SAAO,CAAC,GAAI,MAAM,KAAM,MAAM,GAAG,IAAI,CAAC;IACrC,QAAQ,QAAQ,EAAE,CAAC,CAAC;CAIvB,MAAM,MAAM,EAAE;AAGd,MAAK,MAAM,QAAQ,iBAAiB;EAClC,MAAM,WAAW,OAAO,KAAK,KAAK;AAElC,OAAK,MAAMA,SAAO,UAAU;GAC1B,IAAI,MAAM,CAAC,KAAKA,OAAK;GAErB,MAAM,oBAAoB,IAAIA;AAC9B,OAAI,kBACF,KAAI,SAASA,WAAkC,UAC7C,OAAM,CAAC,mBAAmB,KAAKA,OAAK;OAIpC,OAAM,CAAC,KAAKA,QAAM,kBAAkB;GAIxC,MAAM,YAAY,WAAWA;AAI7B,OAAIA,SAAO,UAAU,KAAK,UAAU;;;AAKxC,MAAK,MAAM,KAAK,OAAO,KAAK,IAAI,EAAE;EAChC,MAAMA,QAAM;AAEZ,MAAIA,SAAO,QACT,IAAIA,OACL;;AAGH,QAAO;;;;;;;AAsJT,MAAMC,iBAKF;CACF,eAAe;EACb,gBAAgB;EAChB,mBAAmB;EACnB,kBAAkB;EAClB,iBAAiB;EACjB,gBAAgB;EAChB,iBAAiB;EACjB,gBAAgB;EAChB,UAAU;EACX;CACD,aAAa;EACX,gBAAgB;EAChB,iBAAiB;EAClB;CACF"}