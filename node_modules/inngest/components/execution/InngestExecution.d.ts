import { ExecutionVersion } from "../../helpers/consts.js";
import { MaybePromise, Simplify } from "../../helpers/types.js";
import { ServerTiming } from "../../helpers/ServerTiming.js";
import { InngestFunction } from "../InngestFunction.js";
import { Context, IncomingOp, OutgoingOp, StepMode } from "../../types.js";
import { Inngest } from "../Inngest.js";
import { ActionResponse } from "../InngestCommHandler.js";
import { Debugger } from "debug";

//#region src/components/execution/InngestExecution.d.ts
declare namespace InngestExecution_d_exports {
  export { ExecutionResult, ExecutionResultHandler, ExecutionResultHandlers, ExecutionResults, ExecutionVersion, IInngestExecution, InngestExecution, InngestExecutionFactory, InngestExecutionOptions, MemoizedOp, PREFERRED_EXECUTION_VERSION };
}
/**
 * The possible results of an execution.
 */
interface ExecutionResults {
  "function-resolved": {
    data: unknown;
  };
  "step-ran": {
    step: OutgoingOp;
    retriable?: boolean | string;
  };
  "function-rejected": {
    error: unknown;
    retriable: boolean | string;
  };
  "steps-found": {
    steps: [OutgoingOp, ...OutgoingOp[]];
  };
  "step-not-found": {
    step: OutgoingOp;
  };
  /**
   * Indicates that we need to relinquish control back to Inngest in order to
   * change step modes.
   */
  "change-mode": {
    to: StepMode;
    token: string;
  };
}
type ExecutionResult = { [K in keyof ExecutionResults]: Simplify<{
  type: K;
  ctx: Context.Any;
  ops: Record<string, MemoizedOp>;
} & ExecutionResults[K]> }[keyof ExecutionResults];
type ExecutionResultHandler<T = ActionResponse> = (result: ExecutionResult) => MaybePromise<T>;
type ExecutionResultHandlers<T = ActionResponse> = { [E in ExecutionResult as E["type"]]: (result: E) => MaybePromise<T> };
interface MemoizedOp extends IncomingOp {
  /**
   * If the step has been hit during this run, these will be the arguments
   * passed to it.
   */
  rawArgs?: unknown[];
  fulfilled?: boolean;
  /**
   * The promise that has been returned to userland code.
   */
  promise?: Promise<unknown>;
  seen?: boolean;
}
/**
 * The preferred execution version that will be used by the SDK when handling
 * brand new runs where the Executor is allowing us to choose.
 *
 * Changing this should not ever be a breaking change, as this will only change
 * new runs, not existing ones.
 */
declare const PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;
/**
 * Options for creating a new {@link InngestExecution} instance.
 */
interface InngestExecutionOptions {
  client: Inngest.Any;
  fn: InngestFunction.Any;
  /**
   * The UUID that represents this function in Inngest.
   *
   * This is used to reference the function during async checkpointing, when we
   * know the function/run already exists and just wish to reference it
   * directly.
   */
  internalFnId?: string;
  reqArgs: unknown[];
  runId: string;
  data: Omit<Context.Any, "step">;
  stepState: Record<string, MemoizedOp>;
  stepCompletionOrder: string[];
  stepMode: StepMode;
  /**
   * If this execution is being run from a queue job, this will be an identifier
   * used to reference this execution in Inngest. SDKs are expected to parrot
   * this back in some responses to correctly attribute actions to this queue
   * item.
   */
  queueItemId?: string;
  /**
   * Headers to be sent with any request to Inngest during this execution.
   */
  headers: Record<string, string>;
  requestedRunStep?: string;
  timer?: ServerTiming;
  isFailureHandler?: boolean;
  disableImmediateExecution?: boolean;
  /**
   * Provide the ability to transform the context passed to the function before
   * the execution starts.
   */
  transformCtx?: (ctx: Readonly<Context.Any>) => Context.Any;
  /**
   * A hook that is called to create an {@link ActionResponse} from the returned
   * value of an execution.
   *
   * This is required for checkpointing executions.
   */
  createResponse?: (data: unknown) => MaybePromise<ActionResponse>;
}
type InngestExecutionFactory = (options: InngestExecutionOptions) => IInngestExecution;
declare class InngestExecution {
  protected options: InngestExecutionOptions;
  protected debug: Debugger;
  constructor(options: InngestExecutionOptions);
}
interface IInngestExecution {
  version: ExecutionVersion;
  start(): Promise<ExecutionResult>;
}
//#endregion
export { ExecutionResult, IInngestExecution, InngestExecution, InngestExecutionFactory, InngestExecutionOptions, InngestExecution_d_exports, MemoizedOp };
//# sourceMappingURL=InngestExecution.d.ts.map