{"version":3,"file":"InngestExecution.js","names":["options: InngestExecutionOptions"],"sources":["../../../src/components/execution/InngestExecution.ts"],"sourcesContent":["import Debug, { type Debugger } from \"debug\";\nimport { debugPrefix, ExecutionVersion } from \"../../helpers/consts.ts\";\nimport type { ServerTiming } from \"../../helpers/ServerTiming.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport type { Context, IncomingOp, OutgoingOp, StepMode } from \"../../types.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport type { ActionResponse } from \"../InngestCommHandler.ts\";\nimport type { InngestFunction } from \"../InngestFunction.ts\";\n\n// Re-export ExecutionVersion so it's correctly recognized as an enum and not\n// just a type. This can be lost when bundling if we don't re-export it here.\n// See `pnpm run test:dist`.\nexport { ExecutionVersion };\n\n/**\n * The possible results of an execution.\n */\nexport interface ExecutionResults {\n  \"function-resolved\": { data: unknown };\n  \"step-ran\": { step: OutgoingOp; retriable?: boolean | string };\n  \"function-rejected\": { error: unknown; retriable: boolean | string };\n  \"steps-found\": { steps: [OutgoingOp, ...OutgoingOp[]] };\n  \"step-not-found\": { step: OutgoingOp };\n\n  /**\n   * Indicates that we need to relinquish control back to Inngest in order to\n   * change step modes.\n   */\n  \"change-mode\": {\n    to: StepMode;\n    token: string;\n  };\n}\n\nexport type ExecutionResult = {\n  [K in keyof ExecutionResults]: Simplify<\n    {\n      type: K;\n      ctx: Context.Any;\n      ops: Record<string, MemoizedOp>;\n    } & ExecutionResults[K]\n  >;\n}[keyof ExecutionResults];\n\nexport type ExecutionResultHandler<T = ActionResponse> = (\n  result: ExecutionResult,\n) => MaybePromise<T>;\n\nexport type ExecutionResultHandlers<T = ActionResponse> = {\n  [E in ExecutionResult as E[\"type\"]]: (result: E) => MaybePromise<T>;\n};\n\nexport interface MemoizedOp extends IncomingOp {\n  /**\n   * If the step has been hit during this run, these will be the arguments\n   * passed to it.\n   */\n  rawArgs?: unknown[];\n  fulfilled?: boolean;\n\n  /**\n   * The promise that has been returned to userland code.\n   */\n  promise?: Promise<unknown>;\n  seen?: boolean;\n}\n\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexport const PREFERRED_EXECUTION_VERSION =\n  ExecutionVersion.V1 satisfies ExecutionVersion;\n\n/**\n * Options for creating a new {@link InngestExecution} instance.\n */\nexport interface InngestExecutionOptions {\n  client: Inngest.Any;\n  fn: InngestFunction.Any;\n\n  /**\n   * The UUID that represents this function in Inngest.\n   *\n   * This is used to reference the function during async checkpointing, when we\n   * know the function/run already exists and just wish to reference it\n   * directly.\n   */\n  internalFnId?: string;\n  reqArgs: unknown[];\n  runId: string;\n  data: Omit<Context.Any, \"step\">;\n  stepState: Record<string, MemoizedOp>;\n  stepCompletionOrder: string[];\n  stepMode: StepMode;\n\n  /**\n   * If this execution is being run from a queue job, this will be an identifier\n   * used to reference this execution in Inngest. SDKs are expected to parrot\n   * this back in some responses to correctly attribute actions to this queue\n   * item.\n   */\n  queueItemId?: string;\n\n  /**\n   * Headers to be sent with any request to Inngest during this execution.\n   */\n  headers: Record<string, string>;\n  requestedRunStep?: string;\n  timer?: ServerTiming;\n  isFailureHandler?: boolean;\n  disableImmediateExecution?: boolean;\n\n  /**\n   * Provide the ability to transform the context passed to the function before\n   * the execution starts.\n   */\n  transformCtx?: (ctx: Readonly<Context.Any>) => Context.Any;\n\n  /**\n   * A hook that is called to create an {@link ActionResponse} from the returned\n   * value of an execution.\n   *\n   * This is required for checkpointing executions.\n   */\n  createResponse?: (data: unknown) => MaybePromise<ActionResponse>;\n}\n\nexport type InngestExecutionFactory = (\n  options: InngestExecutionOptions,\n) => IInngestExecution;\n\nexport class InngestExecution {\n  protected debug: Debugger;\n\n  constructor(protected options: InngestExecutionOptions) {\n    this.debug = Debug(`${debugPrefix}:${this.options.runId}`);\n  }\n}\n\nexport interface IInngestExecution {\n  version: ExecutionVersion;\n  start(): Promise<ExecutionResult>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;AA0EA,MAAa,8BACX,iBAAiB;AA4DnB,IAAa,mBAAb,MAA8B;CAC5B,AAAU;CAEV,YAAY,AAAUA,SAAkC;EAAlC;AACpB,OAAK,QAAQ,MAAM,GAAG,YAAY,GAAG,KAAK,QAAQ,QAAQ"}