{"version":3,"file":"v1.cjs","names":["hashjs","createV1InngestExecution: InngestExecutionFactory","InngestExecution","ExecutionVersion","options: InngestExecutionOptions","StepMode","trace","version","getAsyncLocalStorage","headerKeys","commonCheckpointHandler: CheckpointHandlers[StepMode][\"\"]","StepOpCode","serializeError","syncHandlers: CheckpointHandlers[StepMode.Sync]","step","asyncHandlers: CheckpointHandlers[StepMode.Async]","asyncCheckpointingHandlers: CheckpointHandlers[StepMode.AsyncCheckpointing]","getHookStack","internalEvents","invokePayloadSchema","outgoingOp: OutgoingOp","getAsyncCtx","interval: GoInterval | undefined","goIntervalTiming","runAsPromise","NonRetriableError","retriable: boolean | string","StepError","RetryAfterError","minifyPrettyError","undefinedToNull","createDeferredPromiseWithStack","loop: V1ExecutionState[\"loop\"]","z","jsonErrorSchema","deserializeError","foundStepsToReport: Map<string, FoundStep>","unhandledFoundStepsToReport: Map<string, FoundStep>","expectedNextStepIndexes: Map<string, number>","remainingStepCompletionOrder: string[]","foundStepsReportPromise: Promise<void> | undefined","beforeExecHooksPromise: Promise<void> | undefined","prettyError","ErrCode","extensionPromise: Promise<void>","resolveNextTick","resolveAfterPending","stepHandler: StepHandler","getStepOptions","STEP_INDEXING_SUFFIX","createDeferredPromise","extraOpts: Record<string, unknown> | undefined","step: FoundStep","createStepTools","createTimeoutPromise"],"sources":["../../../src/components/execution/v1.ts"],"sourcesContent":["import { trace } from \"@opentelemetry/api\";\nimport hashjs from \"hash.js\";\nimport { z } from \"zod/v3\";\nimport {\n  ExecutionVersion,\n  headerKeys,\n  internalEvents,\n} from \"../../helpers/consts.ts\";\nimport {\n  deserializeError,\n  ErrCode,\n  minifyPrettyError,\n  prettyError,\n  serializeError,\n} from \"../../helpers/errors.js\";\nimport { undefinedToNull } from \"../../helpers/functions.js\";\nimport {\n  createDeferredPromise,\n  createDeferredPromiseWithStack,\n  createTimeoutPromise,\n  type GoInterval,\n  goIntervalTiming,\n  resolveAfterPending,\n  resolveNextTick,\n  runAsPromise,\n} from \"../../helpers/promises.ts\";\nimport type { MaybePromise, Simplify } from \"../../helpers/types.ts\";\nimport {\n  type APIStepPayload,\n  type BaseContext,\n  type Context,\n  type EventPayload,\n  type FailureEventArgs,\n  type Handler,\n  jsonErrorSchema,\n  type OutgoingOp,\n  StepMode,\n  StepOpCode,\n} from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { getHookStack, type RunHookStack } from \"../InngestMiddleware.ts\";\nimport {\n  createStepTools,\n  type FoundStep,\n  getStepOptions,\n  invokePayloadSchema,\n  STEP_INDEXING_SUFFIX,\n  type StepHandler,\n} from \"../InngestStepTools.ts\";\nimport { NonRetriableError } from \"../NonRetriableError.ts\";\nimport { RetryAfterError } from \"../RetryAfterError.ts\";\nimport { StepError } from \"../StepError.ts\";\nimport { getAsyncCtx, getAsyncLocalStorage } from \"./als.ts\";\nimport {\n  type ExecutionResult,\n  type IInngestExecution,\n  InngestExecution,\n  type InngestExecutionFactory,\n  type InngestExecutionOptions,\n  type MemoizedOp,\n} from \"./InngestExecution.ts\";\nimport { clientProcessorMap } from \"./otel/access.ts\";\n\nconst { sha1 } = hashjs;\n\nexport const createV1InngestExecution: InngestExecutionFactory = (options) => {\n  return new V1InngestExecution(options);\n};\n\nclass V1InngestExecution extends InngestExecution implements IInngestExecution {\n  public version = ExecutionVersion.V1;\n\n  private state: V1ExecutionState;\n  private fnArg: Context.Any;\n  private checkpointHandlers: CheckpointHandlers;\n  private timeoutDuration = 1000 * 10;\n  private execution: Promise<ExecutionResult> | undefined;\n  private userFnToRun: Handler.Any;\n\n  /**\n   * If we're supposed to run a particular step via `requestedRunStep`, this\n   * will be a `Promise` that resolves after no steps have been found for\n   * `timeoutDuration` milliseconds.\n   *\n   * If we're not supposed to run a particular step, this will be `undefined`.\n   */\n  private timeout?: ReturnType<typeof createTimeoutPromise>;\n\n  constructor(rawOptions: InngestExecutionOptions) {\n    const options: InngestExecutionOptions = {\n      ...rawOptions,\n      stepMode: rawOptions.stepMode ?? StepMode.Async,\n    };\n\n    super(options);\n\n    /**\n     * Check we have everything we need for checkpointing\n     */\n    if (this.options.stepMode === StepMode.Sync) {\n      if (!this.options.createResponse) {\n        throw new Error(\"createResponse is required for sync step mode\");\n      }\n    }\n\n    this.userFnToRun = this.getUserFnToRun();\n    this.state = this.createExecutionState();\n    this.fnArg = this.createFnArg();\n    this.checkpointHandlers = this.createCheckpointHandlers();\n    this.initializeTimer(this.state);\n\n    this.debug(\n      \"created new V1 execution for run;\",\n      this.options.requestedRunStep\n        ? `wanting to run step \"${this.options.requestedRunStep}\"`\n        : \"discovering steps\",\n    );\n\n    this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n  }\n\n  /**\n   * Idempotently start the execution of the user's function.\n   */\n  public start() {\n    if (!this.execution) {\n      this.debug(\"starting V1 execution\");\n\n      const tracer = trace.getTracer(\"inngest\", version);\n\n      this.execution = getAsyncLocalStorage().then((als) => {\n        return als.run(\n          {\n            app: this.options.client,\n            execution: {\n              ctx: this.fnArg,\n              instance: this,\n            },\n          },\n          async () => {\n            return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n              clientProcessorMap.get(this.options.client)?.declareStartingSpan({\n                span,\n                runId: this.options.runId,\n                traceparent: this.options.headers[headerKeys.TraceParent],\n                tracestate: this.options.headers[headerKeys.TraceState],\n              });\n\n              return this._start()\n                .then((result) => {\n                  this.debug(\"result:\", result);\n                  return result;\n                })\n                .finally(() => {\n                  span.end();\n                });\n            });\n          },\n        );\n      });\n    }\n\n    return this.execution;\n  }\n\n  /**\n   * Starts execution of the user's function and the core loop.\n   */\n  private async _start(): Promise<ExecutionResult> {\n    try {\n      const allCheckpointHandler = this.getCheckpointHandler(\"\");\n      this.state.hooks = await this.initializeMiddleware();\n      await this.startExecution();\n\n      let i = 0;\n\n      for await (const checkpoint of this.state.loop) {\n        await allCheckpointHandler(checkpoint, i);\n\n        const handler = this.getCheckpointHandler(checkpoint.type);\n        const result = await handler(checkpoint, i++);\n\n        if (result) {\n          return result;\n        }\n      }\n    } catch (error) {\n      return await this.transformOutput({ error });\n    } finally {\n      void this.state.loop.return();\n      await this.state.hooks?.beforeResponse?.();\n    }\n\n    /**\n     * If we're here, the generator somehow finished without returning a value.\n     * This should never happen.\n     */\n    throw new Error(\"Core loop finished without returning a value\");\n  }\n\n  private async checkpoint(steps: OutgoingOp[]): Promise<void> {\n    if (this.options.stepMode === StepMode.Sync) {\n      if (!this.state.checkpointedRun) {\n        // We have to start the run\n        const res = await this.options.client[\"inngestApi\"].checkpointNewRun({\n          runId: this.fnArg.runId,\n          event: this.fnArg.event as APIStepPayload,\n          steps,\n        });\n\n        this.state.checkpointedRun = {\n          appId: res.data.app_id,\n          fnId: res.data.fn_id,\n          token: res.data.token,\n        };\n      } else {\n        await this.options.client[\"inngestApi\"].checkpointSteps({\n          appId: this.state.checkpointedRun.appId,\n          fnId: this.state.checkpointedRun.fnId,\n          runId: this.fnArg.runId,\n          steps,\n        });\n      }\n    } else if (this.options.stepMode === StepMode.AsyncCheckpointing) {\n      if (!this.options.queueItemId) {\n        throw new Error(\n          \"Missing queueItemId for async checkpointing. This is a bug in the Inngest SDK.\",\n        );\n      }\n\n      if (!this.options.internalFnId) {\n        throw new Error(\n          \"Missing internalFnId for async checkpointing. This is a bug in the Inngest SDK.\",\n        );\n      }\n\n      await this.options.client[\"inngestApi\"].checkpointStepsAsync({\n        runId: this.fnArg.runId,\n        fnId: this.options.internalFnId,\n        queueItemId: this.options.queueItemId,\n        steps,\n      });\n    } else {\n      throw new Error(\n        \"Checkpointing is only supported in Sync and AsyncCheckpointing step modes. This is a bug in the Inngest SDK.\",\n      );\n    }\n  }\n\n  private async checkpointAndSwitchToAsync(\n    steps: OutgoingOp[],\n  ): Promise<ExecutionResult> {\n    await this.checkpoint(steps);\n\n    if (!this.state.checkpointedRun?.token) {\n      throw new Error(\"Failed to checkpoint and switch to async mode\");\n    }\n\n    return {\n      type: \"change-mode\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      to: StepMode.Async,\n      token: this.state.checkpointedRun?.token!,\n    };\n  }\n\n  /**\n   * Returns whether we're in the final attempt of execution, or `null` if we\n   * can't determine this in the SDK.\n   */\n  private inFinalAttempt(): boolean | null {\n    if (typeof this.fnArg.maxAttempts !== \"number\") {\n      return null;\n    }\n\n    return this.fnArg.attempt + 1 >= this.fnArg.maxAttempts;\n  }\n\n  /**\n   * Creates a handler for every checkpoint type, defining what to do when we\n   * reach that checkpoint in the core loop.\n   */\n  private createCheckpointHandlers(): CheckpointHandlers {\n    const commonCheckpointHandler: CheckpointHandlers[StepMode][\"\"] = (\n      checkpoint,\n    ) => {\n      this.debug(`${this.options.stepMode} checkpoint:`, checkpoint);\n    };\n\n    const stepRanHandler = async (\n      stepResult: OutgoingOp,\n    ): Promise<ExecutionResult> => {\n      const transformResult = await this.transformOutput(stepResult);\n\n      /**\n       * Transforming output will always return either function rejection or\n       * resolution. In most cases, this can be immediately returned, but in\n       * this particular case we want to handle it differently.\n       */\n      if (transformResult.type === \"function-resolved\") {\n        return {\n          type: \"step-ran\",\n          ctx: transformResult.ctx,\n          ops: transformResult.ops,\n          step: {\n            ...stepResult,\n            data: transformResult.data,\n          },\n        };\n      } else if (transformResult.type === \"function-rejected\") {\n        const stepForResponse = {\n          ...stepResult,\n          error: transformResult.error,\n        };\n\n        if (stepResult.op === StepOpCode.StepFailed) {\n          const ser = serializeError(transformResult.error);\n          stepForResponse.data = {\n            __serialized: true,\n            name: ser.name,\n            message: ser.message,\n            stack: \"\",\n          };\n        }\n\n        return {\n          type: \"step-ran\",\n          ctx: transformResult.ctx,\n          ops: transformResult.ops,\n          retriable: transformResult.retriable,\n          step: stepForResponse,\n        };\n      }\n\n      return transformResult;\n    };\n\n    const maybeReturnNewSteps = async (): Promise<\n      ExecutionResult | undefined\n    > => {\n      const newSteps = await this.filterNewSteps(\n        Array.from(this.state.steps.values()),\n      );\n      if (newSteps) {\n        return {\n          type: \"steps-found\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          steps: newSteps,\n        };\n      }\n\n      return;\n    };\n\n    const syncHandlers: CheckpointHandlers[StepMode.Sync] = {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": commonCheckpointHandler,\n\n      \"function-resolved\": async (checkpoint, i) => {\n        await this.checkpoint([\n          {\n            op: StepOpCode.RunComplete,\n            id: _internals.hashId(\"complete\"), // TODO bad ID\n            data: await this.options.createResponse!(checkpoint.data),\n          },\n        ]);\n\n        // Done - just return the value\n        return {\n          type: \"function-resolved\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          data: checkpoint.data,\n        };\n      },\n\n      \"function-rejected\": (checkpoint) => {\n        // If the function throws during sync execution, we want to switch to\n        // async mode so that we can retry. The exception is that we're already\n        // at max attempts, in which case we do actually want to reject.\n        if (this.inFinalAttempt()) {\n          return {\n            type: \"function-rejected\",\n            ctx: this.fnArg,\n            error: checkpoint.error,\n            ops: this.ops,\n            retriable: false,\n          };\n        }\n\n        // Otherwise, checkpoint the error and switch to async mode\n        return this.checkpointAndSwitchToAsync([\n          {\n            id: _internals.hashId(\"complete\"), // TODO bad ID, bad use of _internals here\n            displayName: \"complete\", // TODO bad display name\n            op: StepOpCode.StepError,\n            error: checkpoint.error,\n          },\n        ]);\n      },\n\n      \"step-not-found\": ({ step }) => {\n        return {\n          type: \"function-rejected\",\n          ctx: this.fnArg,\n          error: new Error(\n            \"Step not found when checkpointing; this should never happen\",\n          ),\n          ops: this.ops,\n          retriable: false,\n        };\n      },\n\n      \"steps-found\": async ({ steps }) => {\n        // If we're entering parallelism or async mode, checkpoint and switch\n        // to async.\n        if (steps.length !== 1 || steps[0].mode !== StepMode.Sync) {\n          return this.checkpointAndSwitchToAsync(\n            steps.map((step) => ({ ...step, id: step.hashedId })),\n          );\n        }\n\n        // Otherwise we're good to start executing things right now.\n        const step = this.state.steps.get(steps[0].id);\n        if (!step) {\n          throw new Error(\n            \"Step not found in memoization state during sync checkpointing; this should never happen and is a bug in the Inngest SDK\",\n          );\n        }\n\n        const result = await this.executeStep(step);\n\n        if (result.error) {\n          return this.checkpointAndSwitchToAsync([result]);\n        }\n\n        return void (await this.checkpoint([\n          this.resumeStepWithResult(result),\n        ]));\n      },\n    };\n\n    const asyncHandlers: CheckpointHandlers[StepMode.Async] = {\n      /**\n       * Run for all checkpoints. Best used for logging or common actions.\n       * Use other handlers to return values and interrupt the core loop.\n       */\n      \"\": commonCheckpointHandler,\n\n      /**\n       * The user's function has completed and returned a value.\n       */\n      \"function-resolved\": async ({ data }) => {\n        // We need to do this even here for async, as we could be returning\n        // data from an API endpoint, even if we were triggered async.\n        if (this.options.createResponse) {\n          data = await this.options.createResponse(data);\n        }\n\n        return await this.transformOutput({ data });\n      },\n\n      /**\n       * The user's function has thrown an error.\n       */\n      \"function-rejected\": async (checkpoint) => {\n        return await this.transformOutput({ error: checkpoint.error });\n      },\n\n      /**\n       * We've found one or more steps. Here we may want to run a step or report\n       * them back to Inngest.\n       */\n      \"steps-found\": async ({ steps }) => {\n        const stepResult = await this.tryExecuteStep(steps);\n        if (stepResult) {\n          return stepRanHandler(stepResult);\n        }\n\n        return maybeReturnNewSteps();\n      },\n\n      /**\n       * While trying to find a step that Inngest has told us to run, we've\n       * timed out or have otherwise decided that it doesn't exist.\n       */\n      \"step-not-found\": ({ step }) => {\n        return {\n          type: \"step-not-found\",\n          ctx: this.fnArg,\n          ops: this.ops,\n          step,\n        };\n      },\n    };\n\n    const asyncCheckpointingHandlers: CheckpointHandlers[StepMode.AsyncCheckpointing] =\n      {\n        \"\": commonCheckpointHandler,\n        \"function-resolved\": async (checkpoint, i) => {\n          const output = await asyncHandlers[\"function-resolved\"](\n            checkpoint,\n            i,\n          );\n          if (output?.type === \"function-resolved\") {\n            return {\n              type: \"steps-found\",\n              ctx: output.ctx,\n              ops: output.ops,\n              steps: [\n                {\n                  op: StepOpCode.RunComplete,\n                  id: _internals.hashId(\"complete\"), // TODO bad ID. bad bad bad\n                  data: output.data,\n                },\n              ],\n            };\n          }\n\n          return;\n        },\n        \"function-rejected\": asyncHandlers[\"function-rejected\"],\n        \"step-not-found\": asyncHandlers[\"step-not-found\"],\n        \"steps-found\": async ({ steps }) => {\n          // If we are targeting a step and we have it, run it immediately and\n          // return end\n          if (this.options.requestedRunStep) {\n            this.debug(\n              \"async checkpointing looking for step to run, so attempting to find it\",\n            );\n\n            const step = steps.find(\n              (s) => s.hashedId === this.options.requestedRunStep && s.fn,\n            );\n            if (step) {\n              const stepResult = await this.executeStep(step);\n              if (stepResult) {\n                return stepRanHandler(stepResult);\n              }\n            }\n          }\n\n          // Break found steps in to { stepsToResume, newSteps }\n          const { stepsToResume, newSteps } = steps.reduce(\n            (acc, step) => {\n              if (!step.hasStepState) {\n                acc.newSteps.push(step);\n              } else if (!step.fulfilled) {\n                acc.stepsToResume.push(step);\n              }\n\n              return acc;\n            },\n            { stepsToResume: [], newSteps: [] } as {\n              stepsToResume: FoundStep[];\n              newSteps: FoundStep[];\n            },\n          );\n\n          this.debug(\"split found steps in to:\", {\n            stepsToResume: stepsToResume.length,\n            newSteps: newSteps.length,\n          });\n\n          // Got new steps? Exit early.\n          if (!this.options.requestedRunStep && newSteps.length) {\n            const stepResult = await this.tryExecuteStep(newSteps);\n            if (stepResult) {\n              this.debug(`executed step \"${stepResult.id}\" successfully`);\n\n              // We executed a step!\n              //\n              // We know that because we're in this mode, we're always free to\n              // checkpoint and continue if we ran a step and it was successful.\n              if (stepResult.error) {\n                // If we failed, go back to the regular async flow.\n                return stepRanHandler(stepResult);\n              }\n\n              this.debug(\"checkpointing and resuming execution after step run\");\n\n              return void (await this.checkpoint([\n                this.resumeStepWithResult(stepResult),\n              ]));\n            }\n\n            return maybeReturnNewSteps();\n          }\n\n          // If we have stepsToResume, resume as many as possible and resume execution\n          if (stepsToResume.length) {\n            this.debug(`resuming ${stepsToResume.length} steps`);\n\n            for (const st of stepsToResume) {\n              this.resumeStepWithResult({\n                ...st,\n                id: st.hashedId,\n              });\n            }\n          }\n\n          return;\n        },\n      };\n\n    return {\n      [StepMode.Async]: asyncHandlers,\n      [StepMode.Sync]: syncHandlers,\n      [StepMode.AsyncCheckpointing]: asyncCheckpointingHandlers,\n    };\n  }\n\n  private getCheckpointHandler(type: keyof CheckpointHandlers[StepMode]) {\n    return this.checkpointHandlers[this.options.stepMode][type] as (\n      checkpoint: Checkpoint,\n      iteration: number,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  }\n\n  private async tryExecuteStep(\n    steps: FoundStep[],\n  ): Promise<OutgoingOp | undefined> {\n    const hashedStepIdToRun =\n      this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n    if (!hashedStepIdToRun) {\n      return;\n    }\n\n    const step = steps.find(\n      (step) => step.hashedId === hashedStepIdToRun && step.fn,\n    );\n\n    if (step) {\n      return await this.executeStep(step);\n    }\n\n    /**\n     * Ensure we reset the timeout if we have a requested run step but couldn't\n     * find it, but also that we don't reset if we found and executed it.\n     */\n    return void this.timeout?.reset();\n  }\n\n  /**\n   * Given a list of outgoing ops, decide if we can execute an op early and\n   * return the ID of the step to execute if we can.\n   */\n  private getEarlyExecRunStep(steps: FoundStep[]): string | undefined {\n    /**\n     * We may have been disabled due to parallelism, in which case we can't\n     * immediately execute unless explicitly requested.\n     */\n    if (this.options.disableImmediateExecution) return;\n\n    const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n    if (unfulfilledSteps.length !== 1) return;\n\n    const op = unfulfilledSteps[0];\n\n    if (\n      op &&\n      op.op === StepOpCode.StepPlanned\n      // TODO We must individually check properties here that we do not want to\n      // execute on, such as retry counts. Nothing exists here that falls in to\n      // this case, but should be accounted for when we add them.\n      // && typeof op.opts === \"undefined\"\n    ) {\n      return op.hashedId;\n    }\n\n    return;\n  }\n\n  private async filterNewSteps(\n    foundSteps: FoundStep[],\n  ): Promise<[OutgoingOp, ...OutgoingOp[]] | undefined> {\n    if (this.options.requestedRunStep) {\n      return;\n    }\n\n    const newSteps = foundSteps.reduce((acc, step) => {\n      if (!step.hasStepState) {\n        acc.push(step);\n      }\n\n      return acc;\n    }, [] as FoundStep[]);\n\n    if (!newSteps.length) {\n      return;\n    }\n\n    /**\n     * We're finishing up; let's trigger the last of the hooks.\n     */\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n    await this.state.hooks?.afterExecution?.();\n\n    const stepList = newSteps.map<OutgoingOp>((step) => ({\n      displayName: step.displayName,\n      op: step.op,\n      id: step.hashedId,\n      name: step.name,\n      opts: step.opts,\n      userland: step.userland,\n    })) as [OutgoingOp, ...OutgoingOp[]];\n\n    /**\n     * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n     * to ensure that their `data` is transformed correctly.\n     */\n    return await this.transformNewSteps(stepList);\n  }\n\n  /**\n   * Using middleware, transform any newly-found steps before returning them to\n   * an Inngest Server.\n   */\n  private async transformNewSteps<T extends [OutgoingOp, ...OutgoingOp[]]>(\n    steps: T,\n  ): Promise<T> {\n    return Promise.all(\n      steps.map(async (step) => {\n        if (step.op !== StepOpCode.InvokeFunction) {\n          return step;\n        }\n\n        const onSendEventHooks = await getHookStack(\n          this.options.fn[\"middleware\"],\n          \"onSendEvent\",\n          undefined,\n          {\n            transformInput: (prev, output) => {\n              return { ...prev, ...output };\n            },\n            transformOutput: (prev, output) => {\n              return {\n                result: { ...prev.result, ...output?.result },\n              };\n            },\n          },\n        );\n\n        /**\n         * For each event being sent, create a new `onSendEvent` hook stack to\n         * process it. We do this as middleware hooks are intended to run once\n         * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n         * is run for every single event.\n         *\n         * This is done because a developer can use this hook to filter out\n         * events entirely; if we batch all of the events together, we can't\n         * tell which ones were filtered out if we're processing >1 invocation\n         * here.\n         */\n        const transformedPayload = await onSendEventHooks.transformInput?.({\n          payloads: [\n            {\n              ...(step.opts?.payload ?? {}),\n              name: internalEvents.FunctionInvoked,\n            },\n          ],\n        });\n\n        const newPayload = invokePayloadSchema.parse(\n          transformedPayload?.payloads?.[0] ?? {},\n        );\n\n        return {\n          ...step,\n          opts: {\n            ...step.opts,\n            payload: {\n              ...(step.opts?.payload ?? {}),\n              ...newPayload,\n            },\n          },\n        };\n      }),\n    ) as Promise<T>;\n  }\n\n  private async executeStep({\n    id,\n    name,\n    opts,\n    fn,\n    displayName,\n    userland,\n    hashedId,\n  }: FoundStep): Promise<OutgoingOp> {\n    this.debug(`preparing to execute step \"${id}\"`);\n\n    this.timeout?.clear();\n    await this.state.hooks?.afterMemoization?.();\n    await this.state.hooks?.beforeExecution?.();\n\n    const outgoingOp: OutgoingOp = {\n      id: hashedId,\n      op: StepOpCode.StepRun,\n      name,\n      opts,\n      displayName,\n      userland,\n    };\n    this.state.executingStep = outgoingOp;\n\n    const store = await getAsyncCtx();\n\n    if (store?.execution) {\n      store.execution.executingStep = {\n        id,\n        name: displayName,\n      };\n    }\n\n    this.debug(`executing step \"${id}\"`);\n\n    let interval: GoInterval | undefined;\n\n    return goIntervalTiming(() => runAsPromise(fn))\n      .finally(async () => {\n        this.debug(`finished executing step \"${id}\"`);\n\n        delete this.state.executingStep;\n        if (store?.execution) {\n          delete store.execution.executingStep;\n        }\n\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then<OutgoingOp>(async ({ resultPromise, interval: _interval }) => {\n        interval = _interval;\n\n        return {\n          ...outgoingOp,\n          data: await resultPromise,\n        };\n      })\n      .catch<OutgoingOp>((error) => {\n        let errorIsRetriable = true;\n\n        if (error instanceof NonRetriableError) {\n          errorIsRetriable = false;\n        } else if (\n          this.fnArg.maxAttempts &&\n          this.fnArg?.maxAttempts - 1 === this.fnArg.attempt\n        ) {\n          errorIsRetriable = false;\n        }\n\n        if (errorIsRetriable) {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepError,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        } else {\n          return {\n            ...outgoingOp,\n            op: StepOpCode.StepFailed,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            error,\n          };\n        }\n      })\n      .then((op) => ({\n        ...op,\n        timing: interval,\n      }));\n  }\n\n  /**\n   * Starts execution of the user's function, including triggering checkpoints\n   * and middleware hooks where appropriate.\n   */\n  private async startExecution(): Promise<void> {\n    /**\n     * Mutate input as neccessary based on middleware.\n     */\n    await this.transformInput();\n\n    /**\n     * Start the timer to time out the run if needed.\n     */\n    void this.timeout?.start();\n\n    await this.state.hooks?.beforeMemoization?.();\n\n    /**\n     * If we had no state to begin with, immediately end the memoization phase.\n     */\n    if (this.state.allStateUsed()) {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n    }\n\n    /**\n     * Trigger the user's function.\n     */\n    runAsPromise(() => this.userFnToRun(this.fnArg))\n      .finally(async () => {\n        await this.state.hooks?.afterMemoization?.();\n        await this.state.hooks?.beforeExecution?.();\n        await this.state.hooks?.afterExecution?.();\n      })\n      .then((data) => {\n        this.state.setCheckpoint({ type: \"function-resolved\", data });\n      })\n      .catch((error) => {\n        this.state.setCheckpoint({ type: \"function-rejected\", error });\n      });\n  }\n\n  /**\n   * Using middleware, transform input before running.\n   */\n  private async transformInput() {\n    const inputMutations = await this.state.hooks?.transformInput?.({\n      ctx: { ...this.fnArg },\n      steps: Object.values(this.state.stepState),\n      fn: this.options.fn,\n      reqArgs: this.options.reqArgs,\n    });\n\n    if (inputMutations?.ctx) {\n      this.fnArg = inputMutations.ctx;\n    }\n\n    if (inputMutations?.steps) {\n      this.state.stepState = Object.fromEntries(\n        inputMutations.steps.map((step) => [step.id, step]),\n      );\n    }\n  }\n\n  /**\n   * Using middleware, transform output before returning.\n   */\n  private async transformOutput(\n    dataOrError: Parameters<\n      NonNullable<RunHookStack[\"transformOutput\"]>\n    >[0][\"result\"],\n  ): Promise<ExecutionResult> {\n    const output = { ...dataOrError } as Partial<OutgoingOp>;\n\n    const isStepExecution = Boolean(this.state.executingStep);\n\n    const transformedOutput = await this.state.hooks?.transformOutput?.({\n      result: { ...output },\n      step: this.state.executingStep,\n    });\n\n    const { data, error } = { ...output, ...transformedOutput?.result };\n\n    if (!isStepExecution) {\n      await this.state.hooks?.finished?.({\n        result: { ...(typeof error !== \"undefined\" ? { error } : { data }) },\n      });\n    }\n\n    if (typeof error !== \"undefined\") {\n      /**\n       * Ensure we give middleware the chance to decide on retriable behaviour\n       * by looking at the error returned from output transformation.\n       */\n      let retriable: boolean | string = !(\n        error instanceof NonRetriableError ||\n        (error instanceof StepError &&\n          error === this.state.recentlyRejectedStepError)\n      );\n      if (retriable && error instanceof RetryAfterError) {\n        retriable = error.retryAfter;\n      }\n\n      const serializedError = minifyPrettyError(serializeError(error));\n\n      return {\n        type: \"function-rejected\",\n        ctx: this.fnArg,\n        ops: this.ops,\n        error: serializedError,\n        retriable,\n      };\n    }\n\n    return {\n      type: \"function-resolved\",\n      ctx: this.fnArg,\n      ops: this.ops,\n      data: undefinedToNull(data),\n    };\n  }\n\n  private createExecutionState(): V1ExecutionState {\n    const d = createDeferredPromiseWithStack<Checkpoint>();\n    let checkpointResolve = d.deferred.resolve;\n    const checkpointResults = d.results;\n\n    const loop: V1ExecutionState[\"loop\"] = (async function* (\n      cleanUp?: () => void,\n    ) {\n      try {\n        while (true) {\n          const res = (await checkpointResults.next()).value;\n          if (res) {\n            yield res;\n          }\n        }\n      } finally {\n        cleanUp?.();\n      }\n    })(() => {\n      this.timeout?.clear();\n      void checkpointResults.return();\n    });\n\n    const stepsToFulfill = Object.keys(this.options.stepState).length;\n\n    const state: V1ExecutionState = {\n      stepState: this.options.stepState,\n      stepsToFulfill,\n      steps: new Map(),\n      loop,\n      hasSteps: Boolean(stepsToFulfill),\n      stepCompletionOrder: [...this.options.stepCompletionOrder],\n      remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n      setCheckpoint: (checkpoint: Checkpoint) => {\n        ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n      },\n      allStateUsed: () => {\n        return this.state.remainingStepsToBeSeen.size === 0;\n      },\n    };\n\n    return state;\n  }\n\n  get ops(): Record<string, MemoizedOp> {\n    return Object.fromEntries(this.state.steps);\n  }\n\n  private createFnArg(): Context.Any {\n    const step = this.createStepTools();\n\n    let fnArg = {\n      ...(this.options.data as { event: EventPayload }),\n      step,\n    } as Context.Any;\n\n    /**\n     * Handle use of the `onFailure` option by deserializing the error.\n     */\n    if (this.options.isFailureHandler) {\n      const eventData = z\n        .object({ error: jsonErrorSchema })\n        .parse(fnArg.event?.data);\n\n      (fnArg as Partial<Pick<FailureEventArgs, \"error\">>) = {\n        ...fnArg,\n        error: deserializeError(eventData.error),\n      };\n    }\n\n    return this.options.transformCtx?.(fnArg) ?? fnArg;\n  }\n\n  private createStepTools(): ReturnType<typeof createStepTools> {\n    /**\n     * A list of steps that have been found and are being rolled up before being\n     * reported to the core loop.\n     */\n    const foundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the subset of found steps to report that have not yet been\n     * handled. Used for fast access to steps that need to be handled in order.\n     */\n    const unhandledFoundStepsToReport: Map<string, FoundStep> = new Map();\n\n    /**\n     * A map of the latest sequential step indexes found for each step ID. Used\n     * to ensure that we don't index steps in parallel.\n     *\n     * Note that these must be sequential; if we've seen or assigned `a:1`,\n     * `a:2` and `a:4`, the latest sequential step index is `2`.\n     *\n     */\n    const expectedNextStepIndexes: Map<string, number> = new Map();\n\n    /**\n     * An ordered list of step IDs that have yet to be handled in this\n     * execution. Used to ensure that we handle steps in the order they were\n     * found and based on the `stepCompletionOrder` in this execution's state.\n     */\n    const remainingStepCompletionOrder: string[] =\n      this.state.stepCompletionOrder.slice();\n\n    /**\n     * A promise that's used to ensure that step reporting cannot be run more than\n     * once in a given asynchronous time span.\n     */\n    let foundStepsReportPromise: Promise<void> | undefined;\n\n    /**\n     * A promise that's used to represent middleware hooks running before\n     * execution.\n     */\n    let beforeExecHooksPromise: Promise<void> | undefined;\n\n    /**\n     * A flag used to ensure that we only warn about parallel indexing once per\n     * execution to avoid spamming the console.\n     */\n    let warnOfParallelIndexing = false;\n\n    /**\n     * Counts the number of times we've extended this tick.\n     */\n    let tickExtensionCount = 0;\n\n    /**\n     * Given a colliding step ID, maybe warn the user about parallel indexing.\n     */\n    const maybeWarnOfParallelIndexing = (userlandCollisionId: string) => {\n      if (warnOfParallelIndexing) {\n        return;\n      }\n\n      const hashedCollisionId = _internals.hashId(userlandCollisionId);\n\n      const stepExists = this.state.steps.has(hashedCollisionId);\n      if (stepExists) {\n        const stepFoundThisTick = foundStepsToReport.has(hashedCollisionId);\n        if (!stepFoundThisTick) {\n          warnOfParallelIndexing = true;\n\n          console.warn(\n            prettyError({\n              type: \"warn\",\n              whatHappened:\n                \"We detected that you have multiple steps with the same ID.\",\n              code: ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n              why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${userlandCollisionId}\".`,\n              reassurance:\n                \"Your function is still running, though it may exhibit unexpected behaviour.\",\n              consequences:\n                \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n              toFixNow:\n                \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n            }),\n          );\n        }\n      }\n    };\n\n    /**\n     * A helper used to report steps to the core loop. Used after adding an item\n     * to `foundStepsToReport`.\n     */\n    const reportNextTick = () => {\n      // Being explicit instead of using `??=` to appease TypeScript.\n      if (foundStepsReportPromise) {\n        return;\n      }\n\n      let extensionPromise: Promise<void>;\n      if (++tickExtensionCount >= 10) {\n        tickExtensionCount = 0;\n        extensionPromise = resolveNextTick();\n      } else {\n        extensionPromise = resolveAfterPending();\n      }\n\n      foundStepsReportPromise = extensionPromise\n        /**\n         * Ensure that we wait for this promise to resolve before continuing.\n         *\n         * The groups in which steps are reported can affect how we detect some\n         * more complex determinism issues like parallel indexing. This promise\n         * can represent middleware hooks being run early, in the middle of\n         * ingesting steps to report.\n         *\n         * Because of this, it's important we wait for this middleware to resolve\n         * before continuing to report steps to ensure that all steps have a\n         * chance to be reported throughout this asynchronous action.\n         */\n        .then(() => beforeExecHooksPromise)\n        .then(() => {\n          foundStepsReportPromise = undefined;\n\n          for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n            const nextStepId = remainingStepCompletionOrder[i];\n            if (!nextStepId) {\n              // Strange - skip this empty index\n              continue;\n            }\n\n            const handled = unhandledFoundStepsToReport\n              .get(nextStepId)\n              ?.handle();\n            if (handled) {\n              remainingStepCompletionOrder.splice(i, 1);\n              unhandledFoundStepsToReport.delete(nextStepId);\n              return void reportNextTick();\n            }\n          }\n\n          // If we've handled no steps in this \"tick,\" roll up everything we've\n          // found and report it.\n          const steps = [...foundStepsToReport.values()] as [\n            FoundStep,\n            ...FoundStep[],\n          ];\n          foundStepsToReport.clear();\n          unhandledFoundStepsToReport.clear();\n\n          return void this.state.setCheckpoint({\n            type: \"steps-found\",\n            steps: steps,\n          });\n        });\n    };\n\n    /**\n     * A helper used to push a step to the list of steps to report.\n     */\n    const pushStepToReport = (step: FoundStep) => {\n      foundStepsToReport.set(step.hashedId, step);\n      unhandledFoundStepsToReport.set(step.hashedId, step);\n      reportNextTick();\n    };\n\n    const stepHandler: StepHandler = async ({\n      args,\n      matchOp,\n      opts,\n    }): Promise<unknown> => {\n      await beforeExecHooksPromise;\n\n      const stepOptions = getStepOptions(args[0]);\n      const opId = matchOp(stepOptions, ...args.slice(1));\n\n      if (this.state.executingStep) {\n        /**\n         * If a step is found after asynchronous actions during another step's\n         * execution, everything is fine. The problem here is if we've found\n         * that a step nested inside another a step, which is something we don't\n         * support at the time of writing.\n         *\n         * In this case, we could use something like Async Hooks to understand\n         * how the step is being triggered, though this isn't available in all\n         * environments.\n         *\n         * Therefore, we'll only show a warning here to indicate that this is\n         * potentially an issue.\n         */\n        console.warn(\n          prettyError({\n            whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${\n              opId.displayName ?? opId.id\n            }\\``,\n            consequences: \"Nesting `step.*` tooling is not supported.\",\n            type: \"warn\",\n            reassurance:\n              \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n            stack: true,\n            toFixNow:\n              \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n            code: ErrCode.NESTING_STEPS,\n          }),\n        );\n      }\n\n      if (this.state.steps.has(_internals.hashId(opId.id))) {\n        const originalId = opId.id;\n        maybeWarnOfParallelIndexing(originalId);\n\n        const expectedNextIndex = expectedNextStepIndexes.get(originalId) ?? 1;\n        for (let i = expectedNextIndex; ; i++) {\n          const newId = originalId + STEP_INDEXING_SUFFIX + i;\n\n          if (!this.state.steps.has(_internals.hashId(newId))) {\n            expectedNextStepIndexes.set(originalId, i + 1);\n            opId.id = newId;\n            opId.userland.index = i;\n            break;\n          }\n        }\n      }\n\n      const { promise, resolve, reject } = createDeferredPromise();\n      const hashedId = _internals.hashId(opId.id);\n      const stepState = this.state.stepState[hashedId];\n      let isFulfilled = false;\n      if (stepState) {\n        stepState.seen = true;\n        this.state.remainingStepsToBeSeen.delete(hashedId);\n\n        if (typeof stepState.input === \"undefined\") {\n          isFulfilled = true;\n        }\n      }\n\n      let extraOpts: Record<string, unknown> | undefined;\n      let fnArgs = [...args];\n\n      if (\n        typeof stepState?.input !== \"undefined\" &&\n        Array.isArray(stepState.input)\n      ) {\n        switch (opId.op) {\n          // `step.run()` has its function input affected\n          case StepOpCode.StepPlanned: {\n            fnArgs = [...args.slice(0, 2), ...stepState.input];\n\n            extraOpts = { input: [...stepState.input] };\n            break;\n          }\n\n          // `step.ai.infer()` has its body affected\n          case StepOpCode.AiGateway: {\n            extraOpts = {\n              body: {\n                ...(typeof opId.opts?.body === \"object\"\n                  ? { ...opId.opts.body }\n                  : {}),\n                ...stepState.input[0],\n              },\n            };\n            break;\n          }\n        }\n      }\n\n      const step: FoundStep = {\n        ...opId,\n        opts: { ...opId.opts, ...extraOpts },\n        rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n        hashedId,\n        input: stepState?.input,\n\n        fn: opts?.fn ? () => opts.fn?.(...fnArgs) : undefined,\n        promise,\n        fulfilled: isFulfilled,\n        hasStepState: Boolean(stepState),\n        displayName: opId.displayName ?? opId.id,\n        handled: false,\n        handle: () => {\n          if (step.handled) {\n            return false;\n          }\n\n          this.debug(`handling step \"${hashedId}\"`);\n\n          step.handled = true;\n\n          // Refetch step state because it may have been changed since we found\n          // the step. This could be due to checkpointing, where we run this\n          // live and then return to the function.\n          const result = this.state.stepState[hashedId];\n\n          if (step.fulfilled && result) {\n            result.fulfilled = true;\n\n            // For some execution scenarios such as testing, `data`, `error`,\n            // and `input` may be `Promises`. This could also be the case for\n            // future middleware applications. For this reason, we'll make sure\n            // the values are fully resolved before continuing.\n            void Promise.all([result.data, result.error, result.input]).then(\n              () => {\n                if (typeof result.data !== \"undefined\") {\n                  resolve(result.data);\n                } else {\n                  this.state.recentlyRejectedStepError = new StepError(\n                    opId.id,\n                    result.error,\n                  );\n                  reject(this.state.recentlyRejectedStepError);\n                }\n              },\n            );\n          }\n\n          return true;\n        },\n      };\n\n      this.state.steps.set(hashedId, step);\n      this.state.hasSteps = true;\n      pushStepToReport(step);\n\n      /**\n       * If this is the last piece of state we had, we've now finished\n       * memoizing.\n       */\n      if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>\n        await (beforeExecHooksPromise = (async () => {\n          await this.state.hooks?.afterMemoization?.();\n          await this.state.hooks?.beforeExecution?.();\n        })());\n      }\n\n      return promise;\n    };\n\n    return createStepTools(this.options.client, this, stepHandler);\n  }\n\n  private resumeStepWithResult(resultOp: OutgoingOp): FoundStep {\n    const userlandStep = this.state.steps.get(resultOp.id);\n    if (!userlandStep) {\n      throw new Error(\n        \"Step not found in memoization state during async checkpointing; this should never happen and is a bug in the Inngest SDK\",\n      );\n    }\n\n    const data = undefinedToNull(resultOp.data);\n\n    userlandStep.data = data;\n    userlandStep.timing = resultOp.timing;\n    userlandStep.fulfilled = true;\n    userlandStep.hasStepState = true;\n    userlandStep.op = resultOp.op;\n    userlandStep.id = resultOp.id;\n\n    this.state.stepState[resultOp.id] = userlandStep;\n\n    userlandStep.handle();\n\n    return userlandStep;\n  }\n\n  private getUserFnToRun(): Handler.Any {\n    if (!this.options.isFailureHandler) {\n      return this.options.fn[\"fn\"];\n    }\n\n    if (!this.options.fn[\"onFailureFn\"]) {\n      /**\n       * Somehow, we've ended up detecting that this is a failure handler but\n       * doesn't have an `onFailure` function. This should never happen.\n       */\n      throw new Error(\"Cannot find function `onFailure` handler\");\n    }\n\n    return this.options.fn[\"onFailureFn\"];\n  }\n\n  private initializeTimer(state: V1ExecutionState): void {\n    if (!this.options.requestedRunStep) {\n      return;\n    }\n\n    this.timeout = createTimeoutPromise(this.timeoutDuration);\n\n    void this.timeout.then(async () => {\n      await this.state.hooks?.afterMemoization?.();\n      await this.state.hooks?.beforeExecution?.();\n      await this.state.hooks?.afterExecution?.();\n\n      state.setCheckpoint({\n        type: \"step-not-found\",\n        step: {\n          id: this.options.requestedRunStep as string,\n          op: StepOpCode.StepNotFound,\n        },\n      });\n    });\n  }\n\n  private async initializeMiddleware(): Promise<RunHookStack> {\n    const ctx = this.options.data as Pick<\n      Readonly<BaseContext<Inngest.Any>>,\n      \"event\" | \"events\" | \"runId\"\n    >;\n\n    const hooks = await getHookStack(\n      this.options.fn[\"middleware\"],\n      \"onFunctionRun\",\n      {\n        ctx,\n        fn: this.options.fn,\n        steps: Object.values(this.options.stepState),\n        reqArgs: this.options.reqArgs,\n      },\n      {\n        transformInput: (prev, output) => {\n          return {\n            ctx: { ...prev.ctx, ...output?.ctx },\n            fn: this.options.fn,\n            steps: prev.steps.map((step, i) => ({\n              ...step,\n              ...output?.steps?.[i],\n            })),\n            reqArgs: prev.reqArgs,\n          };\n        },\n        transformOutput: (prev, output) => {\n          return {\n            result: { ...prev.result, ...output?.result },\n            step: prev.step,\n          };\n        },\n      },\n    );\n\n    return hooks;\n  }\n}\n\n/**\n * Types of checkpoints that can be reached during execution.\n */\nexport interface Checkpoints {\n  \"steps-found\": { steps: [FoundStep, ...FoundStep[]] };\n  \"function-rejected\": { error: unknown };\n  \"function-resolved\": { data: unknown };\n  \"step-not-found\": { step: OutgoingOp };\n}\n\ntype Checkpoint = {\n  [K in keyof Checkpoints]: Simplify<{ type: K } & Checkpoints[K]>;\n}[keyof Checkpoints];\n\ntype CheckpointHandlers = Record<\n  StepMode,\n  {\n    [C in Checkpoint as C[\"type\"]]: (\n      checkpoint: C,\n\n      /**\n       * This is the number of checkpoints that have been seen before this one was\n       * triggered.\n       *\n       * The catch-all `\"\"` checkpoint does not increment this count.\n       */\n      i: number,\n    ) => MaybePromise<ExecutionResult | undefined>;\n  } & {\n    \"\": (\n      checkpoint: Checkpoint,\n\n      /**\n       * This is the number of checkpoints that have been seen before this one was\n       * triggered.\n       *\n       * The catch-all `\"\"` checkpoint does not increment this count.\n       */\n      i: number,\n    ) => MaybePromise<void>;\n  }\n>;\n\nexport interface V1ExecutionState {\n  /**\n   * A value that indicates that we're executing this step. Can be used to\n   * ensure steps are not accidentally nested until we support this across all\n   * platforms.\n   */\n  executingStep?: Readonly<Omit<OutgoingOp, \"id\">>;\n\n  /**\n   * A map of step IDs to their data, used to fill previously-completed steps\n   * with state from the executor.\n   */\n  stepState: Record<string, MemoizedOp>;\n\n  /**\n   * The number of steps we expect to fulfil based on the state passed from the\n   * Executor.\n   */\n  stepsToFulfill: number;\n\n  /**\n   * A map of step IDs to their functions to run. The executor can request a\n   * specific step to run, so we need to store the function to run here.\n   */\n  steps: Map<string, FoundStep>;\n\n  /**\n   * A flag which represents whether or not steps are understood to be used in\n   * this function. This is used to determine whether or not we should run\n   * some steps (such as `step.sendEvent`) inline as they are found.\n   */\n  hasSteps: boolean;\n\n  /**\n   * The core loop - a generator used to take an action upon finding the next\n   * checkpoint. Manages the flow of execution and cleaning up after itself.\n   */\n  loop: AsyncGenerator<Checkpoint, void, void>;\n\n  /**\n   * A function that resolves the `Promise` returned by `waitForNextDecision`.\n   */\n  setCheckpoint: (data: Checkpoint) => void;\n\n  /**\n   * Initialized middleware hooks for this execution.\n   *\n   * Middleware hooks are cached to ensure they can only be run once, which\n   * means that these hooks can be called in many different places to ensure we\n   * handle all possible execution paths.\n   */\n  hooks?: RunHookStack;\n\n  /**\n   * Returns whether or not all state passed from the executor has been used to\n   * fulfill found steps.\n   */\n  allStateUsed: () => boolean;\n\n  /**\n   * An ordered list of step IDs that represents the order in which their\n   * execution was completed.\n   */\n  stepCompletionOrder: string[];\n\n  /**\n   * An set of step IDs that have yet to be seen in this execution. Used to\n   * decide when to trigger middleware based on the current state.\n   */\n  remainingStepsToBeSeen: Set<string>;\n\n  /**\n   * If defined, this is the error that purposefully thrown when memoizing step\n   * state in order to support per-step errors.\n   *\n   * We use this so that if the function itself rejects with the same error, we\n   * know that it was entirely uncaught (or at the very least rethrown), so we\n   * should send a `NonRetriableError` to stop needless execution of a function\n   * that will continue to fail.\n   *\n   * TODO This is imperfect, as this state is currently kept around for longer\n   * than it needs to be. It should disappear as soon as we've seen that the\n   * error did not immediately throw. It may need to be refactored to work a\n   * little more smoothly with the core loop.\n   */\n  recentlyRejectedStepError?: StepError;\n\n  /**\n   * If defined, this indicates that we're running a checkpointed function run,\n   * and contains the data needed to report progress back to Inngest.\n   */\n  checkpointedRun?: {\n    fnId: string;\n    appId: string;\n    token?: string;\n  };\n}\n\nconst hashId = (id: string): string => {\n  return sha1().update(id).digest(\"hex\");\n};\n\nconst hashOp = (op: OutgoingOp): OutgoingOp => {\n  return {\n    ...op,\n    id: hashId(op.id),\n  };\n};\n\n/**\n * Exported for testing.\n */\nexport const _internals = { hashOp, hashId };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAgEA,MAAM,EAAE,SAASA;AAEjB,MAAaC,4BAAqD,YAAY;AAC5E,QAAO,IAAI,mBAAmB,QAAQ;;AAGxC,IAAM,qBAAN,cAAiCC,0CAA8C;CAC7E,AAAO,UAAUC,gCAAiB;CAElC,AAAQ;CACR,AAAQ;CACR,AAAQ;CACR,AAAQ,kBAAkB,MAAO;CACjC,AAAQ;CACR,AAAQ;;;;;;;;CASR,AAAQ;CAER,YAAY,YAAqC;EAC/C,MAAMC,UAAmC;GACvC,GAAG;GACH,UAAU,WAAW,YAAYC,uBAAS;GAC3C;AAED,QAAM,QAAQ;;;;AAKd,MAAI,KAAK,QAAQ,aAAaA,uBAAS,MACrC;OAAI,CAAC,KAAK,QAAQ,eAChB,OAAM,IAAI,MAAM,gDAAgD;;AAIpE,OAAK,cAAc,KAAK,gBAAgB;AACxC,OAAK,QAAQ,KAAK,sBAAsB;AACxC,OAAK,QAAQ,KAAK,aAAa;AAC/B,OAAK,qBAAqB,KAAK,0BAA0B;AACzD,OAAK,gBAAgB,KAAK,MAAM;AAEhC,OAAK,MACH,qCACA,KAAK,QAAQ,mBACT,wBAAwB,KAAK,QAAQ,iBAAiB,KACtD,oBACL;AAED,OAAK,MAAM,wBAAwB,OAAO,KAAK,KAAK,MAAM,UAAU,CAAC;;;;;CAMvE,AAAO,QAAQ;AACb,MAAI,CAAC,KAAK,WAAW;AACnB,QAAK,MAAM,wBAAwB;GAEnC,MAAM,SAASC,0BAAM,UAAU,WAAWC,wBAAQ;AAElD,QAAK,YAAYC,kCAAsB,CAAC,MAAM,QAAQ;AACpD,WAAO,IAAI,IACT;KACE,KAAK,KAAK,QAAQ;KAClB,WAAW;MACT,KAAK,KAAK;MACV,UAAU;MACX;KACF,EACD,YAAY;AACV,YAAO,OAAO,gBAAgB,sBAAsB,SAAS;AAC3D,wCAAmB,IAAI,KAAK,QAAQ,OAAO,EAAE,oBAAoB;OAC/D;OACA,OAAO,KAAK,QAAQ;OACpB,aAAa,KAAK,QAAQ,QAAQC,0BAAW;OAC7C,YAAY,KAAK,QAAQ,QAAQA,0BAAW;OAC7C,CAAC;AAEF,aAAO,KAAK,QAAQ,CACjB,MAAM,WAAW;AAChB,YAAK,MAAM,WAAW,OAAO;AAC7B,cAAO;QACP,CACD,cAAc;AACb,YAAK,KAAK;QACV;OACJ;MAEL;KACD;;AAGJ,SAAO,KAAK;;;;;CAMd,MAAc,SAAmC;AAC/C,MAAI;GACF,MAAM,uBAAuB,KAAK,qBAAqB,GAAG;AAC1D,QAAK,MAAM,QAAQ,MAAM,KAAK,sBAAsB;AACpD,SAAM,KAAK,gBAAgB;GAE3B,IAAI,IAAI;AAER,cAAW,MAAM,cAAc,KAAK,MAAM,MAAM;AAC9C,UAAM,qBAAqB,YAAY,EAAE;IAGzC,MAAM,SAAS,MADC,KAAK,qBAAqB,WAAW,KAAK,CAC7B,YAAY,IAAI;AAE7C,QAAI,OACF,QAAO;;WAGJ,OAAO;AACd,UAAO,MAAM,KAAK,gBAAgB,EAAE,OAAO,CAAC;YACpC;AACR,GAAK,KAAK,MAAM,KAAK,QAAQ;AAC7B,SAAM,KAAK,MAAM,OAAO,kBAAkB;;;;;;AAO5C,QAAM,IAAI,MAAM,+CAA+C;;CAGjE,MAAc,WAAW,OAAoC;AAC3D,MAAI,KAAK,QAAQ,aAAaJ,uBAAS,KACrC,KAAI,CAAC,KAAK,MAAM,iBAAiB;GAE/B,MAAM,MAAM,MAAM,KAAK,QAAQ,OAAO,cAAc,iBAAiB;IACnE,OAAO,KAAK,MAAM;IAClB,OAAO,KAAK,MAAM;IAClB;IACD,CAAC;AAEF,QAAK,MAAM,kBAAkB;IAC3B,OAAO,IAAI,KAAK;IAChB,MAAM,IAAI,KAAK;IACf,OAAO,IAAI,KAAK;IACjB;QAED,OAAM,KAAK,QAAQ,OAAO,cAAc,gBAAgB;GACtD,OAAO,KAAK,MAAM,gBAAgB;GAClC,MAAM,KAAK,MAAM,gBAAgB;GACjC,OAAO,KAAK,MAAM;GAClB;GACD,CAAC;WAEK,KAAK,QAAQ,aAAaA,uBAAS,oBAAoB;AAChE,OAAI,CAAC,KAAK,QAAQ,YAChB,OAAM,IAAI,MACR,iFACD;AAGH,OAAI,CAAC,KAAK,QAAQ,aAChB,OAAM,IAAI,MACR,kFACD;AAGH,SAAM,KAAK,QAAQ,OAAO,cAAc,qBAAqB;IAC3D,OAAO,KAAK,MAAM;IAClB,MAAM,KAAK,QAAQ;IACnB,aAAa,KAAK,QAAQ;IAC1B;IACD,CAAC;QAEF,OAAM,IAAI,MACR,+GACD;;CAIL,MAAc,2BACZ,OAC0B;AAC1B,QAAM,KAAK,WAAW,MAAM;AAE5B,MAAI,CAAC,KAAK,MAAM,iBAAiB,MAC/B,OAAM,IAAI,MAAM,gDAAgD;AAGlE,SAAO;GACL,MAAM;GACN,KAAK,KAAK;GACV,KAAK,KAAK;GACV,IAAIA,uBAAS;GACb,OAAO,KAAK,MAAM,iBAAiB;GACpC;;;;;;CAOH,AAAQ,iBAAiC;AACvC,MAAI,OAAO,KAAK,MAAM,gBAAgB,SACpC,QAAO;AAGT,SAAO,KAAK,MAAM,UAAU,KAAK,KAAK,MAAM;;;;;;CAO9C,AAAQ,2BAA+C;EACrD,MAAMK,2BACJ,eACG;AACH,QAAK,MAAM,GAAG,KAAK,QAAQ,SAAS,eAAe,WAAW;;EAGhE,MAAM,iBAAiB,OACrB,eAC6B;GAC7B,MAAM,kBAAkB,MAAM,KAAK,gBAAgB,WAAW;;;;;;AAO9D,OAAI,gBAAgB,SAAS,oBAC3B,QAAO;IACL,MAAM;IACN,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,MAAM;KACJ,GAAG;KACH,MAAM,gBAAgB;KACvB;IACF;YACQ,gBAAgB,SAAS,qBAAqB;IACvD,MAAM,kBAAkB;KACtB,GAAG;KACH,OAAO,gBAAgB;KACxB;AAED,QAAI,WAAW,OAAOC,yBAAW,YAAY;KAC3C,MAAM,MAAMC,8BAAe,gBAAgB,MAAM;AACjD,qBAAgB,OAAO;MACrB,cAAc;MACd,MAAM,IAAI;MACV,SAAS,IAAI;MACb,OAAO;MACR;;AAGH,WAAO;KACL,MAAM;KACN,KAAK,gBAAgB;KACrB,KAAK,gBAAgB;KACrB,WAAW,gBAAgB;KAC3B,MAAM;KACP;;AAGH,UAAO;;EAGT,MAAM,sBAAsB,YAEvB;GACH,MAAM,WAAW,MAAM,KAAK,eAC1B,MAAM,KAAK,KAAK,MAAM,MAAM,QAAQ,CAAC,CACtC;AACD,OAAI,SACF,QAAO;IACL,MAAM;IACN,KAAK,KAAK;IACV,KAAK,KAAK;IACV,OAAO;IACR;;EAML,MAAMC,eAAkD;GAKtD,IAAI;GAEJ,qBAAqB,OAAO,YAAY,MAAM;AAC5C,UAAM,KAAK,WAAW,CACpB;KACE,IAAIF,yBAAW;KACf,IAAI,WAAW,OAAO,WAAW;KACjC,MAAM,MAAM,KAAK,QAAQ,eAAgB,WAAW,KAAK;KAC1D,CACF,CAAC;AAGF,WAAO;KACL,MAAM;KACN,KAAK,KAAK;KACV,KAAK,KAAK;KACV,MAAM,WAAW;KAClB;;GAGH,sBAAsB,eAAe;AAInC,QAAI,KAAK,gBAAgB,CACvB,QAAO;KACL,MAAM;KACN,KAAK,KAAK;KACV,OAAO,WAAW;KAClB,KAAK,KAAK;KACV,WAAW;KACZ;AAIH,WAAO,KAAK,2BAA2B,CACrC;KACE,IAAI,WAAW,OAAO,WAAW;KACjC,aAAa;KACb,IAAIA,yBAAW;KACf,OAAO,WAAW;KACnB,CACF,CAAC;;GAGJ,mBAAmB,EAAE,WAAW;AAC9B,WAAO;KACL,MAAM;KACN,KAAK,KAAK;KACV,uBAAO,IAAI,MACT,8DACD;KACD,KAAK,KAAK;KACV,WAAW;KACZ;;GAGH,eAAe,OAAO,EAAE,YAAY;AAGlC,QAAI,MAAM,WAAW,KAAK,MAAM,GAAG,SAASN,uBAAS,KACnD,QAAO,KAAK,2BACV,MAAM,KAAK,YAAU;KAAE,GAAGS;KAAM,IAAIA,OAAK;KAAU,EAAE,CACtD;IAIH,MAAM,OAAO,KAAK,MAAM,MAAM,IAAI,MAAM,GAAG,GAAG;AAC9C,QAAI,CAAC,KACH,OAAM,IAAI,MACR,0HACD;IAGH,MAAM,SAAS,MAAM,KAAK,YAAY,KAAK;AAE3C,QAAI,OAAO,MACT,QAAO,KAAK,2BAA2B,CAAC,OAAO,CAAC;AAG3C,IAAM,MAAM,KAAK,WAAW,CACjC,KAAK,qBAAqB,OAAO,CAClC,CAAC;;GAEL;EAED,MAAMC,gBAAoD;GAKxD,IAAI;GAKJ,qBAAqB,OAAO,EAAE,WAAW;AAGvC,QAAI,KAAK,QAAQ,eACf,QAAO,MAAM,KAAK,QAAQ,eAAe,KAAK;AAGhD,WAAO,MAAM,KAAK,gBAAgB,EAAE,MAAM,CAAC;;GAM7C,qBAAqB,OAAO,eAAe;AACzC,WAAO,MAAM,KAAK,gBAAgB,EAAE,OAAO,WAAW,OAAO,CAAC;;GAOhE,eAAe,OAAO,EAAE,YAAY;IAClC,MAAM,aAAa,MAAM,KAAK,eAAe,MAAM;AACnD,QAAI,WACF,QAAO,eAAe,WAAW;AAGnC,WAAO,qBAAqB;;GAO9B,mBAAmB,EAAE,WAAW;AAC9B,WAAO;KACL,MAAM;KACN,KAAK,KAAK;KACV,KAAK,KAAK;KACV;KACD;;GAEJ;EAED,MAAMC,6BACJ;GACE,IAAI;GACJ,qBAAqB,OAAO,YAAY,MAAM;IAC5C,MAAM,SAAS,MAAM,cAAc,qBACjC,YACA,EACD;AACD,QAAI,QAAQ,SAAS,oBACnB,QAAO;KACL,MAAM;KACN,KAAK,OAAO;KACZ,KAAK,OAAO;KACZ,OAAO,CACL;MACE,IAAIL,yBAAW;MACf,IAAI,WAAW,OAAO,WAAW;MACjC,MAAM,OAAO;MACd,CACF;KACF;;GAKL,qBAAqB,cAAc;GACnC,kBAAkB,cAAc;GAChC,eAAe,OAAO,EAAE,YAAY;AAGlC,QAAI,KAAK,QAAQ,kBAAkB;AACjC,UAAK,MACH,wEACD;KAED,MAAM,OAAO,MAAM,MAChB,MAAM,EAAE,aAAa,KAAK,QAAQ,oBAAoB,EAAE,GAC1D;AACD,SAAI,MAAM;MACR,MAAM,aAAa,MAAM,KAAK,YAAY,KAAK;AAC/C,UAAI,WACF,QAAO,eAAe,WAAW;;;IAMvC,MAAM,EAAE,eAAe,aAAa,MAAM,QACvC,KAAK,SAAS;AACb,SAAI,CAAC,KAAK,aACR,KAAI,SAAS,KAAK,KAAK;cACd,CAAC,KAAK,UACf,KAAI,cAAc,KAAK,KAAK;AAG9B,YAAO;OAET;KAAE,eAAe,EAAE;KAAE,UAAU,EAAE;KAAE,CAIpC;AAED,SAAK,MAAM,4BAA4B;KACrC,eAAe,cAAc;KAC7B,UAAU,SAAS;KACpB,CAAC;AAGF,QAAI,CAAC,KAAK,QAAQ,oBAAoB,SAAS,QAAQ;KACrD,MAAM,aAAa,MAAM,KAAK,eAAe,SAAS;AACtD,SAAI,YAAY;AACd,WAAK,MAAM,kBAAkB,WAAW,GAAG,gBAAgB;AAM3D,UAAI,WAAW,MAEb,QAAO,eAAe,WAAW;AAGnC,WAAK,MAAM,sDAAsD;AAE1D,MAAM,MAAM,KAAK,WAAW,CACjC,KAAK,qBAAqB,WAAW,CACtC,CAAC;AAFF;;AAKF,YAAO,qBAAqB;;AAI9B,QAAI,cAAc,QAAQ;AACxB,UAAK,MAAM,YAAY,cAAc,OAAO,QAAQ;AAEpD,UAAK,MAAM,MAAM,cACf,MAAK,qBAAqB;MACxB,GAAG;MACH,IAAI,GAAG;MACR,CAAC;;;GAMT;AAEH,SAAO;IACJN,uBAAS,QAAQ;IACjBA,uBAAS,OAAO;IAChBA,uBAAS,qBAAqB;GAChC;;CAGH,AAAQ,qBAAqB,MAA0C;AACrE,SAAO,KAAK,mBAAmB,KAAK,QAAQ,UAAU;;CAMxD,MAAc,eACZ,OACiC;EACjC,MAAM,oBACJ,KAAK,QAAQ,oBAAoB,KAAK,oBAAoB,MAAM;AAClE,MAAI,CAAC,kBACH;EAGF,MAAM,OAAO,MAAM,MAChB,WAASS,OAAK,aAAa,qBAAqBA,OAAK,GACvD;AAED,MAAI,KACF,QAAO,MAAM,KAAK,YAAY,KAAK;AAO9B,EAAK,KAAK,SAAS,OAAO;;;;;;CAOnC,AAAQ,oBAAoB,OAAwC;;;;;AAKlE,MAAI,KAAK,QAAQ,0BAA2B;EAE5C,MAAM,mBAAmB,MAAM,QAAQ,SAAS,CAAC,KAAK,UAAU;AAChE,MAAI,iBAAiB,WAAW,EAAG;EAEnC,MAAM,KAAK,iBAAiB;AAE5B,MACE,MACA,GAAG,OAAOH,yBAAW,YAMrB,QAAO,GAAG;;CAMd,MAAc,eACZ,YACoD;AACpD,MAAI,KAAK,QAAQ,iBACf;EAGF,MAAM,WAAW,WAAW,QAAQ,KAAK,SAAS;AAChD,OAAI,CAAC,KAAK,aACR,KAAI,KAAK,KAAK;AAGhB,UAAO;KACN,EAAE,CAAgB;AAErB,MAAI,CAAC,SAAS,OACZ;;;;AAMF,QAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,QAAM,KAAK,MAAM,OAAO,mBAAmB;AAC3C,QAAM,KAAK,MAAM,OAAO,kBAAkB;EAE1C,MAAM,WAAW,SAAS,KAAiB,UAAU;GACnD,aAAa,KAAK;GAClB,IAAI,KAAK;GACT,IAAI,KAAK;GACT,MAAM,KAAK;GACX,MAAM,KAAK;GACX,UAAU,KAAK;GAChB,EAAE;;;;;AAMH,SAAO,MAAM,KAAK,kBAAkB,SAAS;;;;;;CAO/C,MAAc,kBACZ,OACY;AACZ,SAAO,QAAQ,IACb,MAAM,IAAI,OAAO,SAAS;AACxB,OAAI,KAAK,OAAOA,yBAAW,eACzB,QAAO;;;;;;;;;;;;GA8BT,MAAM,qBAAqB,OA3BF,MAAMM,uCAC7B,KAAK,QAAQ,GAAG,eAChB,eACA,QACA;IACE,iBAAiB,MAAM,WAAW;AAChC,YAAO;MAAE,GAAG;MAAM,GAAG;MAAQ;;IAE/B,kBAAkB,MAAM,WAAW;AACjC,YAAO,EACL,QAAQ;MAAE,GAAG,KAAK;MAAQ,GAAG,QAAQ;MAAQ,EAC9C;;IAEJ,CACF,EAaiD,iBAAiB,EACjE,UAAU,CACR;IACE,GAAI,KAAK,MAAM,WAAW,EAAE;IAC5B,MAAMC,8BAAe;IACtB,CACF,EACF,CAAC;GAEF,MAAM,aAAaC,6CAAoB,MACrC,oBAAoB,WAAW,MAAM,EAAE,CACxC;AAED,UAAO;IACL,GAAG;IACH,MAAM;KACJ,GAAG,KAAK;KACR,SAAS;MACP,GAAI,KAAK,MAAM,WAAW,EAAE;MAC5B,GAAG;MACJ;KACF;IACF;IACD,CACH;;CAGH,MAAc,YAAY,EACxB,IACA,MACA,MACA,IACA,aACA,UACA,YACiC;AACjC,OAAK,MAAM,8BAA8B,GAAG,GAAG;AAE/C,OAAK,SAAS,OAAO;AACrB,QAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,QAAM,KAAK,MAAM,OAAO,mBAAmB;EAE3C,MAAMC,aAAyB;GAC7B,IAAI;GACJ,IAAIT,yBAAW;GACf;GACA;GACA;GACA;GACD;AACD,OAAK,MAAM,gBAAgB;EAE3B,MAAM,QAAQ,MAAMU,yBAAa;AAEjC,MAAI,OAAO,UACT,OAAM,UAAU,gBAAgB;GAC9B;GACA,MAAM;GACP;AAGH,OAAK,MAAM,mBAAmB,GAAG,GAAG;EAEpC,IAAIC;AAEJ,SAAOC,wCAAuBC,8BAAa,GAAG,CAAC,CAC5C,QAAQ,YAAY;AACnB,QAAK,MAAM,4BAA4B,GAAG,GAAG;AAE7C,UAAO,KAAK,MAAM;AAClB,OAAI,OAAO,UACT,QAAO,MAAM,UAAU;AAGzB,SAAM,KAAK,MAAM,OAAO,kBAAkB;IAC1C,CACD,KAAiB,OAAO,EAAE,eAAe,UAAU,gBAAgB;AAClE,cAAW;AAEX,UAAO;IACL,GAAG;IACH,MAAM,MAAM;IACb;IACD,CACD,OAAmB,UAAU;GAC5B,IAAI,mBAAmB;AAEvB,OAAI,iBAAiBC,4CACnB,oBAAmB;YAEnB,KAAK,MAAM,eACX,KAAK,OAAO,cAAc,MAAM,KAAK,MAAM,QAE3C,oBAAmB;AAGrB,OAAI,iBACF,QAAO;IACL,GAAG;IACH,IAAId,yBAAW;IAEf;IACD;OAED,QAAO;IACL,GAAG;IACH,IAAIA,yBAAW;IAEf;IACD;IAEH,CACD,MAAM,QAAQ;GACb,GAAG;GACH,QAAQ;GACT,EAAE;;;;;;CAOP,MAAc,iBAAgC;;;;AAI5C,QAAM,KAAK,gBAAgB;;;;AAK3B,EAAK,KAAK,SAAS,OAAO;AAE1B,QAAM,KAAK,MAAM,OAAO,qBAAqB;;;;AAK7C,MAAI,KAAK,MAAM,cAAc,EAAE;AAC7B,SAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,SAAM,KAAK,MAAM,OAAO,mBAAmB;;;;;AAM7C,sCAAmB,KAAK,YAAY,KAAK,MAAM,CAAC,CAC7C,QAAQ,YAAY;AACnB,SAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,SAAM,KAAK,MAAM,OAAO,mBAAmB;AAC3C,SAAM,KAAK,MAAM,OAAO,kBAAkB;IAC1C,CACD,MAAM,SAAS;AACd,QAAK,MAAM,cAAc;IAAE,MAAM;IAAqB;IAAM,CAAC;IAC7D,CACD,OAAO,UAAU;AAChB,QAAK,MAAM,cAAc;IAAE,MAAM;IAAqB;IAAO,CAAC;IAC9D;;;;;CAMN,MAAc,iBAAiB;EAC7B,MAAM,iBAAiB,MAAM,KAAK,MAAM,OAAO,iBAAiB;GAC9D,KAAK,EAAE,GAAG,KAAK,OAAO;GACtB,OAAO,OAAO,OAAO,KAAK,MAAM,UAAU;GAC1C,IAAI,KAAK,QAAQ;GACjB,SAAS,KAAK,QAAQ;GACvB,CAAC;AAEF,MAAI,gBAAgB,IAClB,MAAK,QAAQ,eAAe;AAG9B,MAAI,gBAAgB,MAClB,MAAK,MAAM,YAAY,OAAO,YAC5B,eAAe,MAAM,KAAK,SAAS,CAAC,KAAK,IAAI,KAAK,CAAC,CACpD;;;;;CAOL,MAAc,gBACZ,aAG0B;EAC1B,MAAM,SAAS,EAAE,GAAG,aAAa;EAEjC,MAAM,kBAAkB,QAAQ,KAAK,MAAM,cAAc;EAEzD,MAAM,oBAAoB,MAAM,KAAK,MAAM,OAAO,kBAAkB;GAClE,QAAQ,EAAE,GAAG,QAAQ;GACrB,MAAM,KAAK,MAAM;GAClB,CAAC;EAEF,MAAM,EAAE,MAAM,UAAU;GAAE,GAAG;GAAQ,GAAG,mBAAmB;GAAQ;AAEnE,MAAI,CAAC,gBACH,OAAM,KAAK,MAAM,OAAO,WAAW,EACjC,QAAQ,EAAE,GAAI,OAAO,UAAU,cAAc,EAAE,OAAO,GAAG,EAAE,MAAM,EAAG,EACrE,CAAC;AAGJ,MAAI,OAAO,UAAU,aAAa;;;;;GAKhC,IAAIe,YAA8B,EAChC,iBAAiBD,+CAChB,iBAAiBE,+BAChB,UAAU,KAAK,MAAM;AAEzB,OAAI,aAAa,iBAAiBC,wCAChC,aAAY,MAAM;GAGpB,MAAM,kBAAkBC,iCAAkBjB,8BAAe,MAAM,CAAC;AAEhE,UAAO;IACL,MAAM;IACN,KAAK,KAAK;IACV,KAAK,KAAK;IACV,OAAO;IACP;IACD;;AAGH,SAAO;GACL,MAAM;GACN,KAAK,KAAK;GACV,KAAK,KAAK;GACV,MAAMkB,kCAAgB,KAAK;GAC5B;;CAGH,AAAQ,uBAAyC;EAC/C,MAAM,IAAIC,iDAA4C;EACtD,IAAI,oBAAoB,EAAE,SAAS;EACnC,MAAM,oBAAoB,EAAE;EAE5B,MAAMC,QAAkC,iBACtC,SACA;AACA,OAAI;AACF,WAAO,MAAM;KACX,MAAM,OAAO,MAAM,kBAAkB,MAAM,EAAE;AAC7C,SAAI,IACF,OAAM;;aAGF;AACR,eAAW;;WAEN;AACP,QAAK,SAAS,OAAO;AACrB,GAAK,kBAAkB,QAAQ;IAC/B;EAEF,MAAM,iBAAiB,OAAO,KAAK,KAAK,QAAQ,UAAU,CAAC;AAkB3D,SAhBgC;GAC9B,WAAW,KAAK,QAAQ;GACxB;GACA,uBAAO,IAAI,KAAK;GAChB;GACA,UAAU,QAAQ,eAAe;GACjC,qBAAqB,CAAC,GAAG,KAAK,QAAQ,oBAAoB;GAC1D,wBAAwB,IAAI,IAAI,KAAK,QAAQ,oBAAoB;GACjE,gBAAgB,eAA2B;AACzC,KAAC,CAAE,SAAS,qBAAsB,kBAAkB,WAAW;;GAEjE,oBAAoB;AAClB,WAAO,KAAK,MAAM,uBAAuB,SAAS;;GAErD;;CAKH,IAAI,MAAkC;AACpC,SAAO,OAAO,YAAY,KAAK,MAAM,MAAM;;CAG7C,AAAQ,cAA2B;EACjC,MAAM,OAAO,KAAK,iBAAiB;EAEnC,IAAI,QAAQ;GACV,GAAI,KAAK,QAAQ;GACjB;GACD;;;;AAKD,MAAI,KAAK,QAAQ,kBAAkB;GACjC,MAAM,YAAYC,SACf,OAAO,EAAE,OAAOC,+BAAiB,CAAC,CAClC,MAAM,MAAM,OAAO,KAAK;AAE3B,GAAC,QAAqD;IACpD,GAAG;IACH,OAAOC,gCAAiB,UAAU,MAAM;IACzC;;AAGH,SAAO,KAAK,QAAQ,eAAe,MAAM,IAAI;;CAG/C,AAAQ,kBAAsD;;;;;EAK5D,MAAMC,qCAA6C,IAAI,KAAK;;;;;EAM5D,MAAMC,8CAAsD,IAAI,KAAK;;;;;;;;;EAUrE,MAAMC,0CAA+C,IAAI,KAAK;;;;;;EAO9D,MAAMC,+BACJ,KAAK,MAAM,oBAAoB,OAAO;;;;;EAMxC,IAAIC;;;;;EAMJ,IAAIC;;;;;EAMJ,IAAI,yBAAyB;;;;EAK7B,IAAI,qBAAqB;;;;EAKzB,MAAM,+BAA+B,wBAAgC;AACnE,OAAI,uBACF;GAGF,MAAM,oBAAoB,WAAW,OAAO,oBAAoB;AAGhE,OADmB,KAAK,MAAM,MAAM,IAAI,kBAAkB,EAGxD;QAAI,CADsB,mBAAmB,IAAI,kBAAkB,EAC3C;AACtB,8BAAyB;AAEzB,aAAQ,KACNC,2BAAY;MACV,MAAM;MACN,cACE;MACF,MAAMC,uBAAQ;MACd,KAAK,0IAA0I,oBAAoB;MACnK,aACE;MACF,cACE;MACF,UACE;MACH,CAAC,CACH;;;;;;;;EASP,MAAM,uBAAuB;AAE3B,OAAI,wBACF;GAGF,IAAIC;AACJ,OAAI,EAAE,sBAAsB,IAAI;AAC9B,yBAAqB;AACrB,uBAAmBC,kCAAiB;SAEpC,oBAAmBC,sCAAqB;AAG1C,6BAA0B,iBAavB,WAAW,uBAAuB,CAClC,WAAW;AACV,8BAA0B;AAE1B,SAAK,IAAI,IAAI,GAAG,IAAI,6BAA6B,QAAQ,KAAK;KAC5D,MAAM,aAAa,6BAA6B;AAChD,SAAI,CAAC,WAEH;AAMF,SAHgB,4BACb,IAAI,WAAW,EACd,QAAQ,EACC;AACX,mCAA6B,OAAO,GAAG,EAAE;AACzC,kCAA4B,OAAO,WAAW;AACvC,MAAK,gBAAgB;AAA5B;;;IAMJ,MAAM,QAAQ,CAAC,GAAG,mBAAmB,QAAQ,CAAC;AAI9C,uBAAmB,OAAO;AAC1B,gCAA4B,OAAO;AAE5B,IAAK,KAAK,MAAM,cAAc;KACnC,MAAM;KACC;KACR,CAAC;KACF;;;;;EAMN,MAAM,oBAAoB,SAAoB;AAC5C,sBAAmB,IAAI,KAAK,UAAU,KAAK;AAC3C,+BAA4B,IAAI,KAAK,UAAU,KAAK;AACpD,mBAAgB;;EAGlB,MAAMC,cAA2B,OAAO,EACtC,MACA,SACA,WACsB;AACtB,SAAM;GAGN,MAAM,OAAO,QADOC,wCAAe,KAAK,GAAG,EACT,GAAG,KAAK,MAAM,EAAE,CAAC;AAEnD,OAAI,KAAK,MAAM;;;;;;;;;;;;;;AAcb,WAAQ,KACNN,2BAAY;IACV,cAAc,4DACZ,KAAK,eAAe,KAAK,GAC1B;IACD,cAAc;IACd,MAAM;IACN,aACE;IACF,OAAO;IACP,UACE;IACF,MAAMC,uBAAQ;IACf,CAAC,CACH;AAGH,OAAI,KAAK,MAAM,MAAM,IAAI,WAAW,OAAO,KAAK,GAAG,CAAC,EAAE;IACpD,MAAM,aAAa,KAAK;AACxB,gCAA4B,WAAW;IAEvC,MAAM,oBAAoB,wBAAwB,IAAI,WAAW,IAAI;AACrE,SAAK,IAAI,IAAI,oBAAqB,KAAK;KACrC,MAAM,QAAQ,aAAaM,gDAAuB;AAElD,SAAI,CAAC,KAAK,MAAM,MAAM,IAAI,WAAW,OAAO,MAAM,CAAC,EAAE;AACnD,8BAAwB,IAAI,YAAY,IAAI,EAAE;AAC9C,WAAK,KAAK;AACV,WAAK,SAAS,QAAQ;AACtB;;;;GAKN,MAAM,EAAE,SAAS,SAAS,WAAWC,wCAAuB;GAC5D,MAAM,WAAW,WAAW,OAAO,KAAK,GAAG;GAC3C,MAAM,YAAY,KAAK,MAAM,UAAU;GACvC,IAAI,cAAc;AAClB,OAAI,WAAW;AACb,cAAU,OAAO;AACjB,SAAK,MAAM,uBAAuB,OAAO,SAAS;AAElD,QAAI,OAAO,UAAU,UAAU,YAC7B,eAAc;;GAIlB,IAAIC;GACJ,IAAI,SAAS,CAAC,GAAG,KAAK;AAEtB,OACE,OAAO,WAAW,UAAU,eAC5B,MAAM,QAAQ,UAAU,MAAM,CAE9B,SAAQ,KAAK,IAAb;IAEE,KAAKxC,yBAAW;AACd,cAAS,CAAC,GAAG,KAAK,MAAM,GAAG,EAAE,EAAE,GAAG,UAAU,MAAM;AAElD,iBAAY,EAAE,OAAO,CAAC,GAAG,UAAU,MAAM,EAAE;AAC3C;IAIF,KAAKA,yBAAW;AACd,iBAAY,EACV,MAAM;MACJ,GAAI,OAAO,KAAK,MAAM,SAAS,WAC3B,EAAE,GAAG,KAAK,KAAK,MAAM,GACrB,EAAE;MACN,GAAG,UAAU,MAAM;MACpB,EACF;AACD;;GAKN,MAAMyC,OAAkB;IACtB,GAAG;IACH,MAAM;KAAE,GAAG,KAAK;KAAM,GAAG;KAAW;IACpC,SAAS;IACT;IACA,OAAO,WAAW;IAElB,IAAI,MAAM,WAAW,KAAK,KAAK,GAAG,OAAO,GAAG;IAC5C;IACA,WAAW;IACX,cAAc,QAAQ,UAAU;IAChC,aAAa,KAAK,eAAe,KAAK;IACtC,SAAS;IACT,cAAc;AACZ,SAAI,KAAK,QACP,QAAO;AAGT,UAAK,MAAM,kBAAkB,SAAS,GAAG;AAEzC,UAAK,UAAU;KAKf,MAAM,SAAS,KAAK,MAAM,UAAU;AAEpC,SAAI,KAAK,aAAa,QAAQ;AAC5B,aAAO,YAAY;AAMnB,MAAK,QAAQ,IAAI;OAAC,OAAO;OAAM,OAAO;OAAO,OAAO;OAAM,CAAC,CAAC,WACpD;AACJ,WAAI,OAAO,OAAO,SAAS,YACzB,SAAQ,OAAO,KAAK;YACf;AACL,aAAK,MAAM,4BAA4B,IAAIzB,4BACzC,KAAK,IACL,OAAO,MACR;AACD,eAAO,KAAK,MAAM,0BAA0B;;QAGjD;;AAGH,YAAO;;IAEV;AAED,QAAK,MAAM,MAAM,IAAI,UAAU,KAAK;AACpC,QAAK,MAAM,WAAW;AACtB,oBAAiB,KAAK;;;;;AAMtB,OAAI,CAAC,0BAA0B,KAAK,MAAM,cAAc,CAEtD,QAAO,0BAA0B,YAAY;AAC3C,UAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,UAAM,KAAK,MAAM,OAAO,mBAAmB;OACzC;AAGN,UAAO;;AAGT,SAAO0B,yCAAgB,KAAK,QAAQ,QAAQ,MAAM,YAAY;;CAGhE,AAAQ,qBAAqB,UAAiC;EAC5D,MAAM,eAAe,KAAK,MAAM,MAAM,IAAI,SAAS,GAAG;AACtD,MAAI,CAAC,aACH,OAAM,IAAI,MACR,2HACD;AAKH,eAAa,OAFAvB,kCAAgB,SAAS,KAAK;AAG3C,eAAa,SAAS,SAAS;AAC/B,eAAa,YAAY;AACzB,eAAa,eAAe;AAC5B,eAAa,KAAK,SAAS;AAC3B,eAAa,KAAK,SAAS;AAE3B,OAAK,MAAM,UAAU,SAAS,MAAM;AAEpC,eAAa,QAAQ;AAErB,SAAO;;CAGT,AAAQ,iBAA8B;AACpC,MAAI,CAAC,KAAK,QAAQ,iBAChB,QAAO,KAAK,QAAQ,GAAG;AAGzB,MAAI,CAAC,KAAK,QAAQ,GAAG;;;;;AAKnB,QAAM,IAAI,MAAM,2CAA2C;AAG7D,SAAO,KAAK,QAAQ,GAAG;;CAGzB,AAAQ,gBAAgB,OAA+B;AACrD,MAAI,CAAC,KAAK,QAAQ,iBAChB;AAGF,OAAK,UAAUwB,sCAAqB,KAAK,gBAAgB;AAEzD,EAAK,KAAK,QAAQ,KAAK,YAAY;AACjC,SAAM,KAAK,MAAM,OAAO,oBAAoB;AAC5C,SAAM,KAAK,MAAM,OAAO,mBAAmB;AAC3C,SAAM,KAAK,MAAM,OAAO,kBAAkB;AAE1C,SAAM,cAAc;IAClB,MAAM;IACN,MAAM;KACJ,IAAI,KAAK,QAAQ;KACjB,IAAI3C,yBAAW;KAChB;IACF,CAAC;IACF;;CAGJ,MAAc,uBAA8C;EAC1D,MAAM,MAAM,KAAK,QAAQ;AAmCzB,SA9Bc,MAAMM,uCAClB,KAAK,QAAQ,GAAG,eAChB,iBACA;GACE;GACA,IAAI,KAAK,QAAQ;GACjB,OAAO,OAAO,OAAO,KAAK,QAAQ,UAAU;GAC5C,SAAS,KAAK,QAAQ;GACvB,EACD;GACE,iBAAiB,MAAM,WAAW;AAChC,WAAO;KACL,KAAK;MAAE,GAAG,KAAK;MAAK,GAAG,QAAQ;MAAK;KACpC,IAAI,KAAK,QAAQ;KACjB,OAAO,KAAK,MAAM,KAAK,MAAM,OAAO;MAClC,GAAG;MACH,GAAG,QAAQ,QAAQ;MACpB,EAAE;KACH,SAAS,KAAK;KACf;;GAEH,kBAAkB,MAAM,WAAW;AACjC,WAAO;KACL,QAAQ;MAAE,GAAG,KAAK;MAAQ,GAAG,QAAQ;MAAQ;KAC7C,MAAM,KAAK;KACZ;;GAEJ,CACF;;;AAmJL,MAAM,UAAU,OAAuB;AACrC,QAAO,MAAM,CAAC,OAAO,GAAG,CAAC,OAAO,MAAM;;AAGxC,MAAM,UAAU,OAA+B;AAC7C,QAAO;EACL,GAAG;EACH,IAAI,OAAO,GAAG,GAAG;EAClB;;;;;AAMH,MAAa,aAAa;CAAE;CAAQ;CAAQ"}