{"version":3,"file":"EventSchemas.js","names":["runtimeSchemas: Record<string, unknown>"],"sources":["../../src/components/EventSchemas.ts"],"sourcesContent":["import type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport type { internalEvents } from \"../helpers/consts.ts\";\nimport type {\n  IsEmptyObject,\n  IsStringLiteral,\n  Simplify,\n} from \"../helpers/types.ts\";\nimport type * as z from \"../helpers/validators/zod.ts\";\nimport type {\n  CancelledEventPayload,\n  EventPayload,\n  FailureEventPayload,\n  FinishedEventPayload,\n  InvokedEventPayload,\n  ScheduledTimerEventPayload,\n} from \"../types.ts\";\n\n/**\n * Declares the shape of an event schema we expect from the user. This may be\n * different to what a user is sending us depending on the supported library,\n * but this normalized format is what we require as the end result.\n *\n * @internal\n */\nexport type NormalizedEventSchema = {\n  name?: string;\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  data?: Record<string, any>;\n  // biome-ignore lint/suspicious/noExplicitAny: <explanation>\n  user?: Record<string, any>;\n};\n\n/**\n * A helper type that declares a normalized custom part of the event schema.\n *\n * @public\n */\nexport type NormalizedEventSchemas = Record<string, NormalizedEventSchema>;\n\n/**\n * Asserts that the given type `T` contains a mapping for all internal events.\n *\n * Usage of this ensures that we never forget about an internal event in schemas\n * when adding new ones.\n *\n * It also ensures that the mapped name is not the enum type, as this would\n * require a user to use the enum type to access the event schema to declare\n * triggers, where we want to allow them to use the string literal.\n *\n * @public\n */\nexport type AssertInternalEventPayloads<\n  T extends Record<internalEvents, EventPayload>,\n> = {\n  [K in keyof T as `${K & string}`]: Simplify<\n    Omit<T[K], \"name\"> & { name: `${K & string}` }\n  >;\n};\n\n/**\n * A string error used to highlight to a user that they have a clashing name\n * between the event name and the key of the event schema.\n */\ntype ClashingNameError =\n  \"Error: Omit 'name' from event schemas or make sure it matches the key.\";\n\n/**\n * Given a type T, check if any of the keys in T are a clashing name. If they\n * are, return the error type, otherwise return the original type.\n */\ntype CheckNever<T> = ClashingNameError extends T[keyof T]\n  ? IsEmptyObject<T[keyof T]> extends true\n    ? T\n    : ClashingNameError\n  : T;\n\n/**\n * Given a type T, check if any of the keys in T are a clashing name. If they\n * are, return the error type for that key, otherwise return the original type.\n */\ntype PreventClashingNames<T> = CheckNever<{\n  [K in keyof T]: T[K] extends { name: infer N }\n    ? N extends K\n      ? T[K]\n      : K extends `${string}*${string}`\n        ? T[K] // TODO In this case, every obj should contain a name\n        : ClashingNameError\n    : T[K];\n}>;\n\n/**\n * A literal Zod schema, which is a Zod schema that has a literal string as the\n * event name. This can be used to create correct Zod schemas outside of the\n * `EventSchemas` class.\n *\n * @public\n */\nexport type LiteralZodEventSchema = z.ZodObject<{\n  name: z.ZodLiteral<string>;\n  data?: z.ValidZodValue;\n  user?: z.ValidZodValue;\n}>;\n\n/**\n * An array of literal zod event schemas.\n *\n * @public\n */\nexport type LiteralZodEventSchemas = LiteralZodEventSchema[];\n\n/**\n * A helper type that declares a standardised custom part of the event schema,\n * defined using Zod.\n *\n * @public\n */\nexport type ZodEventSchemas = Record<\n  string,\n  {\n    data?: z.ValidZodValue;\n    user?: z.ValidZodValue;\n  }\n>;\n\n/**\n * A helper type that takes a union of Zod schemas and extracts the literal\n * matching event from the given schemas. Required when picking out types from\n * a union that require inference to work.\n *\n * @public\n */\nexport type PickLiterals<T> = {\n  [K in keyof T]: Extract<T[K], { name: z.ZodLiteral<K> }>;\n};\n\n/**\n * A helper type to extract the name from a given literal Zod schema.\n *\n * @public\n */\nexport type GetName<T> = T extends z.ZodObject<infer U>\n  ? U extends { name: z.ZodLiteral<infer S extends string> }\n    ? S\n    : never\n  : never;\n\n/**\n * Given an input T, infer the shape of the Zod schema if that input is a Zod\n * object.\n *\n * @public\n */\nexport type InferZodShape<T> = T extends z.AnyZodObject ? T[\"shape\"] : never;\n\n/**\n * Given a set of literal Zod schemas, convert them into a record of Zod schemas\n * with the literal name as the key.\n *\n * @public\n */\nexport type LiteralToRecordZodSchemas<T> = PickLiterals<\n  T extends LiteralZodEventSchemas\n    ? {\n        [I in keyof T as GetName<T[I]>]: InferZodShape<T[I]>;\n      }\n    : T extends ZodEventSchemas\n      ? T\n      : never\n>;\n\n/**\n * Given a set of Zod schemas in a record format, convert them into a normalized\n * event schema format.\n *\n * @public\n */\nexport type ZodToNormalizedSchema<T extends ZodEventSchemas> = {\n  [EventName in keyof T & string]: {\n    [Key in keyof T[EventName] & string]: T[EventName][Key] extends z.ZodTypeAny\n      ? z.ZodInfer<T[EventName][Key]>\n      : T[EventName][Key];\n  };\n};\n\n/**\n * A helper type to convert input schemas into the format expected by the\n * `EventSchemas` class, which ensures that each event contains all pieces of\n * information required.\n *\n * It purposefully uses slightly more complex (read: verbose) mapped types to\n * flatten the output and preserve comments.\n *\n * @public\n */\nexport type NormalizedEventSchemaToPayload<T> = {\n  [K in keyof T & string]: AddName<\n    Simplify<Omit<EventPayload, keyof T[K]> & T[K]>,\n    K\n  >;\n};\n\n/**\n * A helper type to add a given name to each object in a type if it doesn't\n * exist as a string literal.\n *\n * Use in this way ensures simpler types can enforce preserving comments.\n */\nexport type AddName<TObj, TDefaultName extends string> = TObj extends {\n  name: string;\n}\n  ? IsStringLiteral<TObj[\"name\"]> extends true\n    ? TObj\n    : Simplify<TObj & { name: TDefaultName }>\n  : Simplify<TObj & { name: TDefaultName }>;\n\n/**\n * A helper type to combine two event schemas together, ensuring the result is\n * as flat as possible and that we don't accidentally overwrite existing schemas\n * with a generic `string` key.\n *\n * @public\n */\nexport type Combine<\n  TCurr extends Record<string, EventPayload>,\n  TInc extends NormalizedEventSchemas,\n> = IsStringLiteral<keyof TCurr & string> extends true\n  ? Simplify<\n      Omit<TCurr, keyof NormalizedEventSchemaToPayload<TInc>> &\n        NormalizedEventSchemaToPayload<TInc>\n    >\n  : NormalizedEventSchemaToPayload<TInc>;\n\n/**\n * A record of event names to a schema for their data.\n */\nexport type StandardSchemas = Record<string, StandardSchemaV1>;\n\n/**\n * Conversion of Standard Schemas to the normalized type, including a literal of\n * the event name.\n */\nexport type StandardToNormalizedSchema<T extends StandardSchemas> = {\n  [K in keyof T & string]: AddName<\n    {\n      // biome-ignore lint/suspicious/noExplicitAny: Only this type is allowed for data and we need `any` for elsewhere\n      data: StandardSchemaV1.InferOutput<T[K]> extends Record<string, any>\n        ? StandardSchemaV1.InferOutput<T[K]>\n        : never;\n    },\n    K\n  >;\n};\n\n/**\n * Provide an `EventSchemas` class to type events, providing type safety when\n * sending events and running functions via Inngest.\n *\n * You can provide generated Inngest types, custom types, types using Zod, or\n * a combination of the above. See {@link EventSchemas} for more information.\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromZod({\n *     \"app/user.created\": {\n *       data: z.object({\n *         id: z.string(),\n *         name: z.string(),\n *       }),\n *     },\n *   }),\n * });\n * ```\n *\n * @public\n */\nexport class EventSchemas<\n  S extends Record<string, EventPayload> = AssertInternalEventPayloads<{\n    [internalEvents.FunctionFailed]: FailureEventPayload;\n    [internalEvents.FunctionFinished]: FinishedEventPayload;\n    [internalEvents.FunctionInvoked]: InvokedEventPayload;\n    [internalEvents.FunctionCancelled]: CancelledEventPayload;\n    [internalEvents.ScheduledTimer]: ScheduledTimerEventPayload;\n  }>,\n> {\n  protected runtimeSchemas: Record<string, unknown> = {};\n\n  private addRuntimeSchemas(schemas: Record<string, unknown>) {\n    this.runtimeSchemas = {\n      ...this.runtimeSchemas,\n      ...schemas,\n    };\n  }\n\n  /**\n   * Use generated Inngest types to type events.\n   */\n  public fromGenerated<T extends NormalizedEventSchemas>(): EventSchemas<\n    Combine<S, T>\n  > {\n    return this;\n  }\n\n  /**\n   * Use a `Record<>` type to type events.\n   *\n   * @example\n   *\n   * ```ts\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromRecord<{\n   *     \"app/user.created\": {\n   *       data: {\n   *         id: string;\n   *         name: string;\n   *       };\n   *     };\n   *   }>(),\n   * });\n   * ```\n   */\n  public fromRecord<T extends NormalizedEventSchemas>(\n    ..._args: PreventClashingNames<T> extends ClashingNameError\n      ? [ClashingNameError]\n      : []\n  ): EventSchemas<Combine<S, T>> {\n    return this;\n  }\n\n  /**\n   * Use a union type to type events.\n   *\n   * @example\n   *\n   * ```ts\n   * type AccountCreated = {\n   *   name: \"app/account.created\";\n   *   data: { org: string };\n   *   user: { id: string };\n   * };\n   *\n   * type AccountDeleted = {\n   *   name: \"app/account.deleted\";\n   *   data: { org: string };\n   *   user: { id: string };\n   * };\n   *\n   * type Events = AccountCreated | AccountDeleted;\n   *\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromUnion<Events>(),\n   * });\n   * ```\n   */\n  public fromUnion<\n    T extends { name: string } & NormalizedEventSchema,\n  >(): EventSchemas<\n    Combine<\n      S,\n      {\n        [K in T[\"name\"]]: Extract<T, { name: K }>;\n      }\n    >\n  > {\n    return this;\n  }\n\n  /**\n   * Use Zod to type events.\n   *\n   * @deprecated Use {@link fromSchema}.\n   *\n   * @example\n   *\n   * ```ts\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromZod({\n   *     \"app/user.created\": {\n   *       data: z.object({\n   *         id: z.string(),\n   *         name: z.string(),\n   *       }),\n   *     },\n   *   }),\n   * });\n   * ```\n   */\n  public fromZod<T extends ZodEventSchemas | LiteralZodEventSchemas>(\n    schemas: T,\n  ): EventSchemas<\n    Combine<\n      S,\n      ZodToNormalizedSchema<\n        T extends ZodEventSchemas ? T : LiteralToRecordZodSchemas<T>\n      >\n    >\n  > {\n    let runtimeSchemas: Record<string, unknown>;\n\n    if (Array.isArray(schemas)) {\n      runtimeSchemas = schemas.reduce((acc, schema) => {\n        const {\n          name: { value: name },\n          ...rest\n        } = schema.shape;\n\n        return {\n          ...acc,\n          [name]: rest,\n        };\n      }, {});\n    } else {\n      runtimeSchemas = schemas;\n    }\n\n    this.addRuntimeSchemas(runtimeSchemas);\n\n    return this;\n  }\n\n  /**\n   * Use anything compliant with Standard Schema to type events.\n   *\n   * @example\n   *\n   * ```ts\n   * export const inngest = new Inngest({\n   *   id: \"my-app\",\n   *   schemas: new EventSchemas().fromSchema({\n   *     \"app/user.created\": z.object({\n   *       id: z.string(),\n   *       name: z.string(),\n   *     }),\n   *   }),\n   * });\n   * ```\n   */\n  public fromSchema<T extends StandardSchemas>(\n    schemas: T,\n  ): EventSchemas<Combine<S, StandardToNormalizedSchema<T>>> {\n    this.addRuntimeSchemas(\n      Object.entries(schemas).reduce((acc, [name, schema]) => {\n        return {\n          ...acc,\n          [name]: {\n            data: schema,\n          },\n        };\n      }, {}),\n    );\n\n    return this;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAsRA,IAAa,eAAb,MAQE;CACA,AAAU,iBAA0C,EAAE;CAEtD,AAAQ,kBAAkB,SAAkC;AAC1D,OAAK,iBAAiB;GACpB,GAAG,KAAK;GACR,GAAG;GACJ;;;;;CAMH,AAAO,gBAEL;AACA,SAAO;;;;;;;;;;;;;;;;;;;;;CAsBT,AAAO,WACL,GAAG,OAG0B;AAC7B,SAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BT,AAAO,YASL;AACA,SAAO;;;;;;;;;;;;;;;;;;;;;;;CAwBT,AAAO,QACL,SAQA;EACA,IAAIA;AAEJ,MAAI,MAAM,QAAQ,QAAQ,CACxB,kBAAiB,QAAQ,QAAQ,KAAK,WAAW;GAC/C,MAAM,EACJ,MAAM,EAAE,OAAO,QACf,GAAG,SACD,OAAO;AAEX,UAAO;IACL,GAAG;KACF,OAAO;IACT;KACA,EAAE,CAAC;MAEN,kBAAiB;AAGnB,OAAK,kBAAkB,eAAe;AAEtC,SAAO;;;;;;;;;;;;;;;;;;;CAoBT,AAAO,WACL,SACyD;AACzD,OAAK,kBACH,OAAO,QAAQ,QAAQ,CAAC,QAAQ,KAAK,CAAC,MAAM,YAAY;AACtD,UAAO;IACL,GAAG;KACF,OAAO,EACN,MAAM,QACP;IACF;KACA,EAAE,CAAC,CACP;AAED,SAAO"}