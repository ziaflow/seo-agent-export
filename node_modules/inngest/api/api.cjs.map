{"version":3,"file":"api.cjs","names":["z","hashSigningKey","defaultInngestApiBaseUrl","devServerAvailable","defaultDevServerHost","finalUrl: URL","ok","fetchWithAuthFallback","err","data: unknown","stepsSchemas","errorSchema","getErrorMessage","batchSchema","json: unknown","rawData: unknown"],"sources":["../../src/api/api.ts"],"sourcesContent":["import type { fetch } from \"cross-fetch\";\nimport { z } from \"zod/v3\";\nimport type { ActionResponse } from \"../components/InngestCommHandler.ts\";\nimport {\n  defaultDevServerHost,\n  defaultInngestApiBaseUrl,\n  type ExecutionVersion,\n} from \"../helpers/consts.ts\";\nimport { devServerAvailable } from \"../helpers/devserver.ts\";\nimport type { Mode } from \"../helpers/env.ts\";\nimport { getErrorMessage } from \"../helpers/errors.ts\";\nimport { fetchWithAuthFallback } from \"../helpers/net.ts\";\nimport { hashSigningKey } from \"../helpers/strings.ts\";\nimport {\n  type APIStepPayload,\n  err,\n  type OutgoingOp,\n  ok,\n  type Result,\n} from \"../types.ts\";\nimport {\n  type BatchResponse,\n  batchSchema,\n  type ErrorResponse,\n  errorSchema,\n  type StepsResponse,\n  stepsSchemas,\n} from \"./schema.ts\";\n\ntype FetchT = typeof fetch;\n\nconst realtimeSubscriptionTokenSchema = z.object({\n  jwt: z.string(),\n});\n\nconst sendSignalSuccessResponseSchema = z.object({\n  data: z.object({\n    run_id: z.string().min(1),\n  }),\n});\n\nconst checkpointNewRunResponseSchema = z.object({\n  data: z.object({\n    fn_id: z.string().min(1),\n    app_id: z.string().min(1),\n    run_id: z.string().min(1),\n    token: z.string().min(1).optional(),\n  }),\n});\n\nexport namespace InngestApi {\n  export interface Options {\n    baseUrl?: string;\n    signingKey: string;\n    signingKeyFallback: string | undefined;\n    fetch: FetchT;\n    mode: Mode;\n  }\n\n  export interface Subscription {\n    topics: string[];\n    channel: string;\n  }\n\n  export interface PublishOptions extends Subscription {\n    runId?: string;\n  }\n\n  export interface SendSignalOptions {\n    signal: string;\n    data?: unknown;\n  }\n\n  export interface SendSignalResponse {\n    /**\n     * The ID of the run that was signaled.\n     *\n     * If this is undefined, the signal could not be matched to a run.\n     */\n    runId: string | undefined;\n  }\n}\n\nexport class InngestApi {\n  public apiBaseUrl?: string;\n  private signingKey: string;\n  private signingKeyFallback: string | undefined;\n  private readonly fetch: FetchT;\n  private mode: Mode;\n\n  constructor({\n    baseUrl,\n    signingKey,\n    signingKeyFallback,\n    fetch,\n    mode,\n  }: InngestApi.Options) {\n    this.apiBaseUrl = baseUrl;\n    this.signingKey = signingKey;\n    this.signingKeyFallback = signingKeyFallback;\n    this.fetch = fetch;\n    this.mode = mode;\n  }\n\n  private get hashedKey(): string {\n    return hashSigningKey(this.signingKey);\n  }\n\n  private get hashedFallbackKey(): string | undefined {\n    if (!this.signingKeyFallback) {\n      return;\n    }\n\n    return hashSigningKey(this.signingKeyFallback);\n  }\n\n  // set the signing key in case it was not instantiated previously\n  setSigningKey(key: string | undefined) {\n    if (typeof key === \"string\" && this.signingKey === \"\") {\n      this.signingKey = key;\n    }\n  }\n\n  setSigningKeyFallback(key: string | undefined) {\n    if (typeof key === \"string\" && !this.signingKeyFallback) {\n      this.signingKeyFallback = key;\n    }\n  }\n\n  private async getTargetUrl(path: string): Promise<URL> {\n    if (this.apiBaseUrl) {\n      return new URL(path, this.apiBaseUrl);\n    }\n\n    let url = new URL(path, defaultInngestApiBaseUrl);\n\n    if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n      const devAvailable = await devServerAvailable(\n        defaultDevServerHost,\n        this.fetch,\n      );\n\n      if (devAvailable) {\n        url = new URL(path, defaultDevServerHost);\n      }\n    }\n\n    return url;\n  }\n\n  private async req(\n    url: string | URL,\n    options?: RequestInit,\n  ): Promise<Result<Response, unknown>> {\n    const finalUrl: URL =\n      typeof url === \"string\" ? await this.getTargetUrl(url) : url;\n\n    try {\n      const res = await fetchWithAuthFallback({\n        authToken: this.hashedKey,\n        authTokenFallback: this.hashedFallbackKey,\n        fetch: this.fetch,\n        url: finalUrl,\n        options: {\n          ...options,\n          headers: {\n            \"Content-Type\": \"application/json\",\n            ...options?.headers,\n          },\n        },\n      });\n\n      return ok(res);\n    } catch (error) {\n      return err(error);\n    }\n  }\n\n  async getRunSteps(\n    runId: string,\n    version: ExecutionVersion,\n  ): Promise<Result<StepsResponse, ErrorResponse>> {\n    const result = await this.req(`/v0/runs/${runId}/actions`);\n    if (result.ok) {\n      const res = result.value;\n      const data: unknown = await res.json();\n\n      if (res.ok) {\n        return ok(stepsSchemas[version].parse(data));\n      }\n\n      return err(errorSchema.parse(data));\n    }\n\n    return err({\n      error: getErrorMessage(\n        result.error,\n        \"Unknown error retrieving step data\",\n      ),\n      status: 500,\n    });\n  }\n\n  async getRunBatch(\n    runId: string,\n  ): Promise<Result<BatchResponse, ErrorResponse>> {\n    const result = await this.req(`/v0/runs/${runId}/batch`);\n    if (result.ok) {\n      const res = result.value;\n      const data: unknown = await res.json();\n\n      if (res.ok) {\n        return ok(batchSchema.parse(data));\n      }\n\n      return err(errorSchema.parse(data));\n    }\n\n    return err({\n      error: getErrorMessage(\n        result.error,\n        \"Unknown error retrieving event batch\",\n      ),\n      status: 500,\n    });\n  }\n\n  async publish(\n    publishOptions: InngestApi.PublishOptions,\n    // biome-ignore lint/suspicious/noExplicitAny: anything is acceptable\n    data: any,\n  ): Promise<Result<void, ErrorResponse>> {\n    // todo it may not be a \"text/stream\"\n    const isStream = data instanceof ReadableStream;\n\n    const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n    url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n    if (publishOptions.runId) {\n      url.searchParams.set(\"run_id\", publishOptions.runId);\n    }\n    for (const topic of publishOptions.topics) {\n      url.searchParams.append(\"topic\", topic);\n    }\n\n    const result = await this.req(url, {\n      body: isStream\n        ? data\n        : typeof data === \"string\"\n          ? data\n          : JSON.stringify(data),\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n      },\n      ...(isStream ? { duplex: \"half\" } : {}),\n    });\n    if (result.ok) {\n      const res = result.value;\n      if (!res.ok) {\n        throw new Error(\n          `Failed to publish event: ${res.status} ${res.statusText}`,\n        );\n      }\n\n      return ok<void>(undefined);\n    }\n\n    return err({\n      error: getErrorMessage(result.error, \"Unknown error publishing event\"),\n      status: 500,\n    });\n  }\n\n  async sendSignal(\n    signalOptions: InngestApi.SendSignalOptions,\n    options?: {\n      headers?: Record<string, string>;\n    },\n  ): Promise<Result<InngestApi.SendSignalResponse, ErrorResponse>> {\n    const url = await this.getTargetUrl(\"/v1/signals\");\n\n    const body = {\n      signal: signalOptions.signal,\n      data: signalOptions.data,\n    };\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...options?.headers,\n        },\n      },\n    })\n      .then(async (res) => {\n        // A 404 is valid if the signal was not found.\n        if (res.status === 404) {\n          return ok<InngestApi.SendSignalResponse>({\n            runId: undefined,\n          });\n        }\n\n        // Save a clone of the response we can use to get the text of if we fail\n        // to parse the JSON.\n        const resClone = res.clone();\n\n        // JSON!\n        let json: unknown;\n        try {\n          json = await res.json();\n        } catch {\n          // res.json() failed so not a valid JSON response\n          return err({\n            error: `Failed to send signal: ${res.status} ${\n              res.statusText\n            } - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        // If we're not 2xx, something went wrong.\n        if (!res.ok) {\n          try {\n            return err(errorSchema.parse(json));\n          } catch {\n            // schema parse failed\n            return err({\n              error: `Failed to send signal: ${res.status} ${\n                res.statusText\n              } - ${await res.text()}`,\n              status: res.status,\n            });\n          }\n        }\n\n        // If we are 2xx, we should have a run_id.\n        const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n        if (!parseRes.success) {\n          return err({\n            error: `Successfully sent signal, but response parsing failed: ${\n              res.status\n            } ${res.statusText} - ${await resClone.text()}`,\n            status: res.status,\n          });\n        }\n\n        return ok({\n          runId: parseRes.data.data.run_id,\n        });\n      })\n      .catch((error) => {\n        // Catch-all if various things go wrong\n        return err({\n          error: getErrorMessage(error, \"Unknown error sending signal\"),\n          status: 500,\n        });\n      });\n  }\n\n  async getSubscriptionToken(\n    channel: string,\n    topics: string[],\n  ): Promise<string> {\n    const url = await this.getTargetUrl(\"/v1/realtime/token\");\n\n    const body = topics.map((topic) => ({\n      channel,\n      name: topic,\n      kind: \"run\",\n    }));\n\n    return fetchWithAuthFallback({\n      authToken: this.hashedKey,\n      authTokenFallback: this.hashedFallbackKey,\n      fetch: this.fetch,\n      url,\n      options: {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n      },\n    })\n      .then(async (res) => {\n        if (!res.ok) {\n          throw new Error(\n            `Failed to get subscription token: ${res.status} ${\n              res.statusText\n            } - ${await res.text()}`,\n          );\n        }\n\n        const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n\n        return data.jwt;\n      })\n      .catch((error) => {\n        throw new Error(\n          getErrorMessage(error, \"Unknown error getting subscription token\"),\n        );\n      });\n  }\n\n  /**\n   * Start a new run, optionally passing in a number of steps to initialize the\n   * run with.\n   */\n  async checkpointNewRun(args: {\n    runId: string;\n    event: APIStepPayload;\n    steps?: OutgoingOp[];\n  }): Promise<z.output<typeof checkpointNewRunResponseSchema>> {\n    const body = JSON.stringify({\n      run_id: args.runId,\n      event: args.event,\n      steps: args.steps,\n    });\n\n    const result = await this.req(\"/v1/checkpoint\", {\n      method: \"POST\",\n      body,\n    });\n\n    if (!result.ok) {\n      throw new Error(\n        getErrorMessage(result.error, \"Unknown error checkpointing new run\"),\n      );\n    }\n\n    const res = result.value;\n    if (res.ok) {\n      const rawData: unknown = await res.json();\n      const data = checkpointNewRunResponseSchema.parse(rawData);\n\n      return data;\n    }\n\n    throw new Error(\n      `Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`,\n    );\n  }\n\n  /**\n   * Checkpoint steps for a given sync run.\n   */\n  async checkpointSteps(args: {\n    runId: string;\n    fnId: string;\n    appId: string;\n    steps: OutgoingOp[];\n  }): Promise<void> {\n    const body = JSON.stringify({\n      fn_id: args.fnId,\n      app_id: args.appId,\n      run_id: args.runId,\n      steps: args.steps,\n    });\n\n    const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {\n      method: \"POST\",\n      body,\n    });\n\n    if (!result.ok) {\n      throw new Error(\n        getErrorMessage(result.error, \"Unknown error checkpointing steps\"),\n      );\n    }\n\n    const res = result.value;\n    if (!res.ok) {\n      throw new Error(\n        `Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`,\n      );\n    }\n  }\n\n  /**\n   * Checkpoint steps for a given async run.\n   */\n  async checkpointStepsAsync(args: {\n    runId: string;\n    fnId: string;\n    queueItemId: string;\n    steps: OutgoingOp[];\n  }): Promise<void> {\n    const body = JSON.stringify({\n      run_id: args.runId,\n      fn_id: args.fnId,\n      qi_id: args.queueItemId,\n      steps: args.steps,\n    });\n\n    const result = await this.req(`/v1/checkpoint/${args.runId}/async`, {\n      method: \"POST\",\n      body,\n    });\n\n    if (!result.ok) {\n      throw new Error(\n        getErrorMessage(result.error, \"Unknown error checkpointing async\"),\n      );\n    }\n\n    const res = result.value;\n    if (!res.ok) {\n      throw new Error(\n        `Failed to checkpoint async: ${res.status} ${res.statusText} - ${await res.text()}`,\n      );\n    }\n  }\n}\n"],"mappings":"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"}