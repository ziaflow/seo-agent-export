import { defaultDevServerHost, defaultInngestApiBaseUrl } from "../helpers/consts.js";
import { err, ok } from "../types.js";
import { batchSchema, errorSchema, stepsSchemas } from "./schema.js";
import { getErrorMessage } from "../helpers/errors.js";
import { hashSigningKey } from "../helpers/strings.js";
import { devServerAvailable } from "../helpers/devserver.js";
import { fetchWithAuthFallback } from "../helpers/net.js";
import { z } from "zod/v3";

//#region src/api/api.ts
const realtimeSubscriptionTokenSchema = z.object({ jwt: z.string() });
const sendSignalSuccessResponseSchema = z.object({ data: z.object({ run_id: z.string().min(1) }) });
const checkpointNewRunResponseSchema = z.object({ data: z.object({
	fn_id: z.string().min(1),
	app_id: z.string().min(1),
	run_id: z.string().min(1),
	token: z.string().min(1).optional()
}) });
var InngestApi = class {
	apiBaseUrl;
	signingKey;
	signingKeyFallback;
	fetch;
	mode;
	constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }) {
		this.apiBaseUrl = baseUrl;
		this.signingKey = signingKey;
		this.signingKeyFallback = signingKeyFallback;
		this.fetch = fetch;
		this.mode = mode;
	}
	get hashedKey() {
		return hashSigningKey(this.signingKey);
	}
	get hashedFallbackKey() {
		if (!this.signingKeyFallback) return;
		return hashSigningKey(this.signingKeyFallback);
	}
	setSigningKey(key) {
		if (typeof key === "string" && this.signingKey === "") this.signingKey = key;
	}
	setSigningKeyFallback(key) {
		if (typeof key === "string" && !this.signingKeyFallback) this.signingKeyFallback = key;
	}
	async getTargetUrl(path) {
		if (this.apiBaseUrl) return new URL(path, this.apiBaseUrl);
		let url = new URL(path, defaultInngestApiBaseUrl);
		if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
			if (await devServerAvailable(defaultDevServerHost, this.fetch)) url = new URL(path, defaultDevServerHost);
		}
		return url;
	}
	async req(url, options) {
		const finalUrl = typeof url === "string" ? await this.getTargetUrl(url) : url;
		try {
			return ok(await fetchWithAuthFallback({
				authToken: this.hashedKey,
				authTokenFallback: this.hashedFallbackKey,
				fetch: this.fetch,
				url: finalUrl,
				options: {
					...options,
					headers: {
						"Content-Type": "application/json",
						...options?.headers
					}
				}
			}));
		} catch (error) {
			return err(error);
		}
	}
	async getRunSteps(runId, version) {
		const result = await this.req(`/v0/runs/${runId}/actions`);
		if (result.ok) {
			const res = result.value;
			const data = await res.json();
			if (res.ok) return ok(stepsSchemas[version].parse(data));
			return err(errorSchema.parse(data));
		}
		return err({
			error: getErrorMessage(result.error, "Unknown error retrieving step data"),
			status: 500
		});
	}
	async getRunBatch(runId) {
		const result = await this.req(`/v0/runs/${runId}/batch`);
		if (result.ok) {
			const res = result.value;
			const data = await res.json();
			if (res.ok) return ok(batchSchema.parse(data));
			return err(errorSchema.parse(data));
		}
		return err({
			error: getErrorMessage(result.error, "Unknown error retrieving event batch"),
			status: 500
		});
	}
	async publish(publishOptions, data) {
		const isStream = data instanceof ReadableStream;
		const url = await this.getTargetUrl("/v1/realtime/publish");
		url.searchParams.set("channel", publishOptions.channel || "");
		if (publishOptions.runId) url.searchParams.set("run_id", publishOptions.runId);
		for (const topic of publishOptions.topics) url.searchParams.append("topic", topic);
		const result = await this.req(url, {
			body: isStream ? data : typeof data === "string" ? data : JSON.stringify(data),
			method: "POST",
			headers: { "Content-Type": isStream ? "text/stream" : "application/json" },
			...isStream ? { duplex: "half" } : {}
		});
		if (result.ok) {
			const res = result.value;
			if (!res.ok) throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);
			return ok(void 0);
		}
		return err({
			error: getErrorMessage(result.error, "Unknown error publishing event"),
			status: 500
		});
	}
	async sendSignal(signalOptions, options) {
		const url = await this.getTargetUrl("/v1/signals");
		const body = {
			signal: signalOptions.signal,
			data: signalOptions.data
		};
		return fetchWithAuthFallback({
			authToken: this.hashedKey,
			authTokenFallback: this.hashedFallbackKey,
			fetch: this.fetch,
			url,
			options: {
				method: "POST",
				body: JSON.stringify(body),
				headers: {
					"Content-Type": "application/json",
					...options?.headers
				}
			}
		}).then(async (res) => {
			if (res.status === 404) return ok({ runId: void 0 });
			const resClone = res.clone();
			let json;
			try {
				json = await res.json();
			} catch {
				return err({
					error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,
					status: res.status
				});
			}
			if (!res.ok) try {
				return err(errorSchema.parse(json));
			} catch {
				return err({
					error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,
					status: res.status
				});
			}
			const parseRes = sendSignalSuccessResponseSchema.safeParse(json);
			if (!parseRes.success) return err({
				error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,
				status: res.status
			});
			return ok({ runId: parseRes.data.data.run_id });
		}).catch((error) => {
			return err({
				error: getErrorMessage(error, "Unknown error sending signal"),
				status: 500
			});
		});
	}
	async getSubscriptionToken(channel, topics) {
		const url = await this.getTargetUrl("/v1/realtime/token");
		const body = topics.map((topic) => ({
			channel,
			name: topic,
			kind: "run"
		}));
		return fetchWithAuthFallback({
			authToken: this.hashedKey,
			authTokenFallback: this.hashedFallbackKey,
			fetch: this.fetch,
			url,
			options: {
				method: "POST",
				body: JSON.stringify(body),
				headers: { "Content-Type": "application/json" }
			}
		}).then(async (res) => {
			if (!res.ok) throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
			return realtimeSubscriptionTokenSchema.parse(await res.json()).jwt;
		}).catch((error) => {
			throw new Error(getErrorMessage(error, "Unknown error getting subscription token"));
		});
	}
	/**
	* Start a new run, optionally passing in a number of steps to initialize the
	* run with.
	*/
	async checkpointNewRun(args) {
		const body = JSON.stringify({
			run_id: args.runId,
			event: args.event,
			steps: args.steps
		});
		const result = await this.req("/v1/checkpoint", {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(getErrorMessage(result.error, "Unknown error checkpointing new run"));
		const res = result.value;
		if (res.ok) {
			const rawData = await res.json();
			return checkpointNewRunResponseSchema.parse(rawData);
		}
		throw new Error(`Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
	/**
	* Checkpoint steps for a given sync run.
	*/
	async checkpointSteps(args) {
		const body = JSON.stringify({
			fn_id: args.fnId,
			app_id: args.appId,
			run_id: args.runId,
			steps: args.steps
		});
		const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(getErrorMessage(result.error, "Unknown error checkpointing steps"));
		const res = result.value;
		if (!res.ok) throw new Error(`Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
	/**
	* Checkpoint steps for a given async run.
	*/
	async checkpointStepsAsync(args) {
		const body = JSON.stringify({
			run_id: args.runId,
			fn_id: args.fnId,
			qi_id: args.queueItemId,
			steps: args.steps
		});
		const result = await this.req(`/v1/checkpoint/${args.runId}/async`, {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(getErrorMessage(result.error, "Unknown error checkpointing async"));
		const res = result.value;
		if (!res.ok) throw new Error(`Failed to checkpoint async: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
};

//#endregion
export { InngestApi };
//# sourceMappingURL=api.js.map