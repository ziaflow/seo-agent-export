{"version":3,"file":"schema.cjs","names":["z","jsonErrorSchema","ExecutionVersion"],"sources":["../../src/api/schema.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ExecutionVersion } from \"../helpers/consts.ts\";\nimport { type EventPayload, jsonErrorSchema } from \"../types.ts\";\n\nexport const errorSchema = z.object({\n  error: z.string(),\n  status: z.number(),\n});\nexport type ErrorResponse = z.infer<typeof errorSchema>;\n\nconst v0StepSchema = z\n  .record(\n    z.any().refine((v) => typeof v !== \"undefined\", {\n      message: \"Values in steps must be defined\",\n    }),\n  )\n  .optional()\n  .nullable();\n\nconst v1StepSchema = z\n  .record(\n    z\n      .object({\n        type: z.literal(\"data\").optional().default(\"data\"),\n        data: z.any().refine((v) => typeof v !== \"undefined\", {\n          message: \"Data in steps must be defined\",\n        }),\n      })\n      .strict()\n      .or(\n        z\n          .object({\n            type: z.literal(\"error\").optional().default(\"error\"),\n            error: jsonErrorSchema,\n          })\n          .strict(),\n      )\n      .or(\n        z\n          .object({\n            type: z.literal(\"input\").optional().default(\"input\"),\n            input: z.any().refine((v) => typeof v !== \"undefined\", {\n              message: \"If input is present it must not be `undefined`\",\n            }),\n          })\n          .strict(),\n      )\n\n      /**\n       * If the result isn't a distcint `data` or `error` object, then it's\n       * likely that the executor has set this directly to a value, for example\n       * in the case of `sleep` or `waitForEvent`.\n       *\n       * In this case, pull the entire value through as data.\n       */\n\n      .or(z.any().transform((v) => ({ type: \"data\" as const, data: v }))),\n  )\n  .default({});\n\nconst v2StepSchema = v1StepSchema;\n\nexport const stepsSchemas = {\n  [ExecutionVersion.V0]: v0StepSchema,\n  [ExecutionVersion.V1]: v1StepSchema,\n  [ExecutionVersion.V2]: v2StepSchema,\n} satisfies Record<ExecutionVersion, z.ZodSchema>;\n\nexport type StepsResponse = {\n  [V in ExecutionVersion]: z.infer<(typeof stepsSchemas)[V]>;\n}[ExecutionVersion];\n\nexport const batchSchema = z.array(\n  z.record(z.any()).transform((v) => v as EventPayload),\n);\nexport type BatchResponse = z.infer<typeof batchSchema>;\n"],"mappings":";;;;;;AAIA,MAAa,cAAcA,SAAE,OAAO;CAClC,OAAOA,SAAE,QAAQ;CACjB,QAAQA,SAAE,QAAQ;CACnB,CAAC;AAGF,MAAM,eAAeA,SAClB,OACCA,SAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EAC9C,SAAS,mCACV,CAAC,CACH,CACA,UAAU,CACV,UAAU;AAEb,MAAM,eAAeA,SAClB,OACCA,SACG,OAAO;CACN,MAAMA,SAAE,QAAQ,OAAO,CAAC,UAAU,CAAC,QAAQ,OAAO;CAClD,MAAMA,SAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EACpD,SAAS,iCACV,CAAC;CACH,CAAC,CACD,QAAQ,CACR,GACCA,SACG,OAAO;CACN,MAAMA,SAAE,QAAQ,QAAQ,CAAC,UAAU,CAAC,QAAQ,QAAQ;CACpD,OAAOC;CACR,CAAC,CACD,QAAQ,CACZ,CACA,GACCD,SACG,OAAO;CACN,MAAMA,SAAE,QAAQ,QAAQ,CAAC,UAAU,CAAC,QAAQ,QAAQ;CACpD,OAAOA,SAAE,KAAK,CAAC,QAAQ,MAAM,OAAO,MAAM,aAAa,EACrD,SAAS,kDACV,CAAC;CACH,CAAC,CACD,QAAQ,CACZ,CAUA,GAAGA,SAAE,KAAK,CAAC,WAAW,OAAO;CAAE,MAAM;CAAiB,MAAM;CAAG,EAAE,CAAC,CACtE,CACA,QAAQ,EAAE,CAAC;AAEd,MAAM,eAAe;AAErB,MAAa,eAAe;EACzBE,gCAAiB,KAAK;EACtBA,gCAAiB,KAAK;EACtBA,gCAAiB,KAAK;CACxB;AAMD,MAAa,cAAcF,SAAE,MAC3BA,SAAE,OAAOA,SAAE,KAAK,CAAC,CAAC,WAAW,MAAM,EAAkB,CACtD"}