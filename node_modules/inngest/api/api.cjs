const require_rolldown_runtime = require('../_virtual/rolldown_runtime.cjs');
const require_consts = require('../helpers/consts.cjs');
const require_types = require('../types.cjs');
const require_schema = require('./schema.cjs');
const require_errors = require('../helpers/errors.cjs');
const require_strings = require('../helpers/strings.cjs');
const require_devserver = require('../helpers/devserver.cjs');
const require_net = require('../helpers/net.cjs');
let zod_v3 = require("zod/v3");

//#region src/api/api.ts
const realtimeSubscriptionTokenSchema = zod_v3.z.object({ jwt: zod_v3.z.string() });
const sendSignalSuccessResponseSchema = zod_v3.z.object({ data: zod_v3.z.object({ run_id: zod_v3.z.string().min(1) }) });
const checkpointNewRunResponseSchema = zod_v3.z.object({ data: zod_v3.z.object({
	fn_id: zod_v3.z.string().min(1),
	app_id: zod_v3.z.string().min(1),
	run_id: zod_v3.z.string().min(1),
	token: zod_v3.z.string().min(1).optional()
}) });
var InngestApi = class {
	apiBaseUrl;
	signingKey;
	signingKeyFallback;
	fetch;
	mode;
	constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode }) {
		this.apiBaseUrl = baseUrl;
		this.signingKey = signingKey;
		this.signingKeyFallback = signingKeyFallback;
		this.fetch = fetch;
		this.mode = mode;
	}
	get hashedKey() {
		return require_strings.hashSigningKey(this.signingKey);
	}
	get hashedFallbackKey() {
		if (!this.signingKeyFallback) return;
		return require_strings.hashSigningKey(this.signingKeyFallback);
	}
	setSigningKey(key) {
		if (typeof key === "string" && this.signingKey === "") this.signingKey = key;
	}
	setSigningKeyFallback(key) {
		if (typeof key === "string" && !this.signingKeyFallback) this.signingKeyFallback = key;
	}
	async getTargetUrl(path) {
		if (this.apiBaseUrl) return new URL(path, this.apiBaseUrl);
		let url = new URL(path, require_consts.defaultInngestApiBaseUrl);
		if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {
			if (await require_devserver.devServerAvailable(require_consts.defaultDevServerHost, this.fetch)) url = new URL(path, require_consts.defaultDevServerHost);
		}
		return url;
	}
	async req(url, options) {
		const finalUrl = typeof url === "string" ? await this.getTargetUrl(url) : url;
		try {
			return require_types.ok(await require_net.fetchWithAuthFallback({
				authToken: this.hashedKey,
				authTokenFallback: this.hashedFallbackKey,
				fetch: this.fetch,
				url: finalUrl,
				options: {
					...options,
					headers: {
						"Content-Type": "application/json",
						...options?.headers
					}
				}
			}));
		} catch (error) {
			return require_types.err(error);
		}
	}
	async getRunSteps(runId, version) {
		const result = await this.req(`/v0/runs/${runId}/actions`);
		if (result.ok) {
			const res = result.value;
			const data = await res.json();
			if (res.ok) return require_types.ok(require_schema.stepsSchemas[version].parse(data));
			return require_types.err(require_schema.errorSchema.parse(data));
		}
		return require_types.err({
			error: require_errors.getErrorMessage(result.error, "Unknown error retrieving step data"),
			status: 500
		});
	}
	async getRunBatch(runId) {
		const result = await this.req(`/v0/runs/${runId}/batch`);
		if (result.ok) {
			const res = result.value;
			const data = await res.json();
			if (res.ok) return require_types.ok(require_schema.batchSchema.parse(data));
			return require_types.err(require_schema.errorSchema.parse(data));
		}
		return require_types.err({
			error: require_errors.getErrorMessage(result.error, "Unknown error retrieving event batch"),
			status: 500
		});
	}
	async publish(publishOptions, data) {
		const isStream = data instanceof ReadableStream;
		const url = await this.getTargetUrl("/v1/realtime/publish");
		url.searchParams.set("channel", publishOptions.channel || "");
		if (publishOptions.runId) url.searchParams.set("run_id", publishOptions.runId);
		for (const topic of publishOptions.topics) url.searchParams.append("topic", topic);
		const result = await this.req(url, {
			body: isStream ? data : typeof data === "string" ? data : JSON.stringify(data),
			method: "POST",
			headers: { "Content-Type": isStream ? "text/stream" : "application/json" },
			...isStream ? { duplex: "half" } : {}
		});
		if (result.ok) {
			const res = result.value;
			if (!res.ok) throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);
			return require_types.ok(void 0);
		}
		return require_types.err({
			error: require_errors.getErrorMessage(result.error, "Unknown error publishing event"),
			status: 500
		});
	}
	async sendSignal(signalOptions, options) {
		const url = await this.getTargetUrl("/v1/signals");
		const body = {
			signal: signalOptions.signal,
			data: signalOptions.data
		};
		return require_net.fetchWithAuthFallback({
			authToken: this.hashedKey,
			authTokenFallback: this.hashedFallbackKey,
			fetch: this.fetch,
			url,
			options: {
				method: "POST",
				body: JSON.stringify(body),
				headers: {
					"Content-Type": "application/json",
					...options?.headers
				}
			}
		}).then(async (res) => {
			if (res.status === 404) return require_types.ok({ runId: void 0 });
			const resClone = res.clone();
			let json;
			try {
				json = await res.json();
			} catch {
				return require_types.err({
					error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,
					status: res.status
				});
			}
			if (!res.ok) try {
				return require_types.err(require_schema.errorSchema.parse(json));
			} catch {
				return require_types.err({
					error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,
					status: res.status
				});
			}
			const parseRes = sendSignalSuccessResponseSchema.safeParse(json);
			if (!parseRes.success) return require_types.err({
				error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,
				status: res.status
			});
			return require_types.ok({ runId: parseRes.data.data.run_id });
		}).catch((error) => {
			return require_types.err({
				error: require_errors.getErrorMessage(error, "Unknown error sending signal"),
				status: 500
			});
		});
	}
	async getSubscriptionToken(channel, topics) {
		const url = await this.getTargetUrl("/v1/realtime/token");
		const body = topics.map((topic) => ({
			channel,
			name: topic,
			kind: "run"
		}));
		return require_net.fetchWithAuthFallback({
			authToken: this.hashedKey,
			authTokenFallback: this.hashedFallbackKey,
			fetch: this.fetch,
			url,
			options: {
				method: "POST",
				body: JSON.stringify(body),
				headers: { "Content-Type": "application/json" }
			}
		}).then(async (res) => {
			if (!res.ok) throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);
			return realtimeSubscriptionTokenSchema.parse(await res.json()).jwt;
		}).catch((error) => {
			throw new Error(require_errors.getErrorMessage(error, "Unknown error getting subscription token"));
		});
	}
	/**
	* Start a new run, optionally passing in a number of steps to initialize the
	* run with.
	*/
	async checkpointNewRun(args) {
		const body = JSON.stringify({
			run_id: args.runId,
			event: args.event,
			steps: args.steps
		});
		const result = await this.req("/v1/checkpoint", {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(require_errors.getErrorMessage(result.error, "Unknown error checkpointing new run"));
		const res = result.value;
		if (res.ok) {
			const rawData = await res.json();
			return checkpointNewRunResponseSchema.parse(rawData);
		}
		throw new Error(`Failed to checkpoint new run: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
	/**
	* Checkpoint steps for a given sync run.
	*/
	async checkpointSteps(args) {
		const body = JSON.stringify({
			fn_id: args.fnId,
			app_id: args.appId,
			run_id: args.runId,
			steps: args.steps
		});
		const result = await this.req(`/v1/checkpoint/${args.runId}/steps`, {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(require_errors.getErrorMessage(result.error, "Unknown error checkpointing steps"));
		const res = result.value;
		if (!res.ok) throw new Error(`Failed to checkpoint steps: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
	/**
	* Checkpoint steps for a given async run.
	*/
	async checkpointStepsAsync(args) {
		const body = JSON.stringify({
			run_id: args.runId,
			fn_id: args.fnId,
			qi_id: args.queueItemId,
			steps: args.steps
		});
		const result = await this.req(`/v1/checkpoint/${args.runId}/async`, {
			method: "POST",
			body
		});
		if (!result.ok) throw new Error(require_errors.getErrorMessage(result.error, "Unknown error checkpointing async"));
		const res = result.value;
		if (!res.ok) throw new Error(`Failed to checkpoint async: ${res.status} ${res.statusText} - ${await res.text()}`);
	}
};

//#endregion
exports.InngestApi = InngestApi;
//# sourceMappingURL=api.cjs.map