type DeferredPromiseReturn<T> = {
    promise: Promise<T>;
    resolve: (value: T) => DeferredPromiseReturn<T>;
    reject: (reason: any) => DeferredPromiseReturn<T>;
};
/**
 * Creates and returns Promise that can be resolved or rejected with the
 * returned `resolve` and `reject` functions.
 *
 * Resolving or rejecting the function will return a new set of Promise control
 * functions. These can be ignored if the original Promise is all that's needed.
 */
export declare const createDeferredPromise: <T>() => DeferredPromiseReturn<T>;
/**
 * Send an HTTP request with the given signing key. If the response is a 401 or
 * 403, then try again with the fallback signing key
 */
export declare function fetchWithAuthFallback<TFetch extends typeof fetch>({ authToken, authTokenFallback, fetch, options, url, }: {
    authToken: string | undefined;
    authTokenFallback: string | undefined;
    fetch: TFetch;
    options?: Parameters<TFetch>[1];
    url: URL | string;
}): Promise<Response>;
/**
 * Given an unknown value, try to parse it as a `boolean`. Useful for parsing
 * environment variables that could be a selection of different values such as
 * `"true"`, `"1"`.
 *
 * If the value could not be confidently parsed as a `boolean` or was seen to be
 * `undefined`, this function returns `undefined`.
 */
export declare const parseAsBoolean: (value: unknown) => boolean | undefined;
export {};
//# sourceMappingURL=util.d.ts.map