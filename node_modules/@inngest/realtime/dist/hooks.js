"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InngestSubscriptionState = void 0;
exports.useInngestSubscription = useInngestSubscription;
const react_1 = require("react");
const subscribe_1 = require("./subscribe");
var InngestSubscriptionState;
(function (InngestSubscriptionState) {
    InngestSubscriptionState["Closed"] = "closed";
    InngestSubscriptionState["Error"] = "error";
    InngestSubscriptionState["RefreshingToken"] = "refresh_token";
    InngestSubscriptionState["Connecting"] = "connecting";
    InngestSubscriptionState["Active"] = "active";
    InngestSubscriptionState["Closing"] = "closing";
})(InngestSubscriptionState || (exports.InngestSubscriptionState = InngestSubscriptionState = {}));
/**
 * TODO
 */
function useInngestSubscription({ token: tokenInput, refreshToken, key, enabled = true, bufferInterval = 0, }) {
    const [token, setToken] = (0, react_1.useState)(tokenInput);
    const [data, setData] = (0, react_1.useState)([]);
    const [freshData, setFreshData] = (0, react_1.useState)([]);
    const [error, setError] = (0, react_1.useState)(null);
    const [state, setState] = (0, react_1.useState)(InngestSubscriptionState.Closed);
    const subscriptionRef = (0, react_1.useRef)(null);
    const readerRef = (0, react_1.useRef)(null);
    const messageBuffer = (0, react_1.useRef)([]);
    const bufferIntervalRef = (0, react_1.useRef)(bufferInterval);
    // Sync token if tokenInput prop changes
    (0, react_1.useEffect)(() => {
        if (tokenInput)
            setToken(tokenInput);
    }, [tokenInput]);
    // Token fetch fallback on mount
    (0, react_1.useEffect)(() => {
        if (!token) {
            if (refreshToken) {
                setState(InngestSubscriptionState.RefreshingToken);
                refreshToken()
                    .then((newToken) => setToken(newToken))
                    .catch((err) => {
                    setError(err);
                    setState(InngestSubscriptionState.Error);
                });
            }
            else {
                setError(new Error("No token provided and no refreshToken handler."));
                setState(InngestSubscriptionState.Error);
            }
        }
    }, []);
    // Subscription management
    (0, react_1.useEffect)(() => {
        setError(null);
        if (!enabled || !token)
            return;
        let cancelled = false;
        const start = async () => {
            try {
                setState(InngestSubscriptionState.Connecting);
                const stream = await (0, subscribe_1.subscribe)({ ...token });
                if (cancelled)
                    return;
                subscriptionRef.current = stream;
                setState(InngestSubscriptionState.Active);
                // Explicitly get and manage the reader so that we can manually release
                // the lock if anything goes wrong or we're done with it.
                //
                // Especially when this is unmounted.
                const reader = stream.getReader();
                readerRef.current = reader;
                try {
                    while (!cancelled) {
                        const { done, value } = await reader.read();
                        if (done || cancelled)
                            break;
                        if (bufferIntervalRef.current === 0) {
                            setFreshData([value]);
                            setData((prev) => [...prev, value]);
                        }
                        else {
                            messageBuffer.current.push(value);
                        }
                    }
                }
                finally {
                    try {
                        reader.releaseLock();
                    }
                    catch {
                        // Reader might already be released
                    }
                    readerRef.current = null;
                }
                // Stream has closed cleanly
                if (!cancelled) {
                    setState(InngestSubscriptionState.Closed);
                    if (enabled)
                        start();
                }
            }
            catch (err) {
                if (cancelled)
                    return;
                if (refreshToken) {
                    setState(InngestSubscriptionState.RefreshingToken);
                    refreshToken()
                        .then((newToken) => setToken(newToken))
                        .catch((e) => {
                        setError(e);
                        setState(InngestSubscriptionState.Error);
                    });
                }
                else {
                    setError(err);
                    setState(InngestSubscriptionState.Error);
                }
            }
        };
        start();
        return () => {
            cancelled = true;
            const cleanup = async () => {
                const readerToRemove = readerRef.current;
                const subToRemove = subscriptionRef.current;
                readerRef.current = null;
                subscriptionRef.current = null;
                try {
                    await readerToRemove?.cancel();
                }
                catch {
                    // Reader might already be cancelled
                }
                try {
                    readerToRemove?.releaseLock();
                }
                catch {
                    // Reader might already be released
                }
                try {
                    await subToRemove?.cancel();
                }
                catch {
                    // Subscription might already be cancelled
                }
            };
            cleanup()
                .catch((err) => {
                console.error("Error cleaning up Inngest subscription", err);
            })
                .finally(() => {
                // Ensure state is always updated even if cleanup fails
                setState(InngestSubscriptionState.Closed);
            });
        };
    }, [token, enabled, key]);
    // Buffer flushing
    (0, react_1.useEffect)(() => {
        bufferIntervalRef.current = bufferInterval;
        let interval = null;
        if (bufferInterval > 0) {
            interval = setInterval(() => {
                if (messageBuffer.current.length > 0) {
                    const buffered = [...messageBuffer.current];
                    messageBuffer.current = [];
                    setFreshData(buffered);
                    setData((prev) => [...prev, ...buffered]);
                }
            }, bufferInterval);
        }
        return () => {
            if (interval)
                clearInterval(interval);
        };
    }, [bufferInterval]);
    return {
        data,
        latestData: data[data.length - 1] ?? null,
        freshData,
        error,
        state,
    };
}
//# sourceMappingURL=hooks.js.map