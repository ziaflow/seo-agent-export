"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamFanout = void 0;
/**
 * TODO
 */
class StreamFanout {
    #writers = new Set();
    /**
     * TODO
     */
    createStream(
    /**
     * TODO
     */
    transform) {
        const { readable, writable } = new TransformStream({
            transform: (chunk, controller) => {
                controller.enqueue(transform ? transform(chunk) : chunk);
            },
        });
        const writer = writable.getWriter();
        this.#writers.add(writer);
        // Eagerly remove the writer is the stream is closed
        writer.closed
            .catch(() => { }) // Suppress unhandled promise rejection to avoid noisy logs
            .finally(() => {
            this.#writers.delete(writer);
        });
        return readable;
    }
    /**
     * TODO
     */
    write(
    /**
     * TODO
     */
    chunk) {
        for (const writer of this.#writers) {
            writer.ready
                .then(() => writer.write(chunk))
                // Dereference the writer if we fail, as this means it's closed
                .catch(() => this.#writers.delete(writer));
        }
    }
    /**
     * TODO
     */
    close() {
        for (const writer of this.#writers) {
            try {
                writer.close();
            }
            catch {
                // Ignore errors, as we are closing the stream and the writer may
                // already be closed, especially if the stream is closed before the
                // writer is closed or if the stream is cancelled.
            }
        }
        this.#writers.clear();
    }
    /**
     * TODO
     */
    size() {
        return this.#writers.size;
    }
}
exports.StreamFanout = StreamFanout;
//# sourceMappingURL=StreamFanout.js.map