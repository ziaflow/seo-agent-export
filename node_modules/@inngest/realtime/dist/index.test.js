"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = assertType;
/* eslint-disable @typescript-eslint/no-unused-vars */
const inngest_1 = require("inngest");
const v = __importStar(require("valibot"));
const channel_1 = require("./channel");
const subscribe_1 = require("./subscribe");
const topic_1 = require("./topic");
/**
 * assert the subject satisfies the specified type T
 * @type T the type to check against.
 */
function assertType(subject) { }
describe("subscribe", () => {
    const app = new inngest_1.Inngest({ id: "test" });
    describe("types", () => {
        const createdTopic = (0, topic_1.topic)("created").schema(v.object({
            id: v.string(),
            name: v.string(),
        }));
        const updatedTopic = (0, topic_1.topic)("updated").type();
        const unusedTopic = (0, topic_1.topic)("unused").type();
        const staticChannel = (0, channel_1.channel)("static")
            .addTopic(createdTopic)
            .addTopic(updatedTopic)
            .addTopic(unusedTopic);
        const userChannel = (0, channel_1.channel)((userId) => `user/${userId}`)
            .addTopic(createdTopic)
            .addTopic(updatedTopic)
            .addTopic(unusedTopic);
        describe("channels and topics", () => {
            describe("topic", () => {
                test("can create a blank topic", () => {
                    const t = (0, topic_1.topic)("test");
                    expect(t).toBeDefined();
                    assertType(t);
                    expect(t.name).toBe("test");
                    assertType(t.name);
                    expect(t.getSchema()).toBeUndefined();
                    assertType(true);
                    assertType(true);
                });
                test("topic ID must be a string", () => {
                    const _fn = () => {
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)(1);
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)({ foo: "bar" });
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)(undefined);
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)();
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)(null);
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)(true);
                        // @ts-expect-error Topic ID must be a string
                        (0, topic_1.topic)(false);
                    };
                });
                test("can type a topic", () => {
                    const t = (0, topic_1.topic)("test").type();
                    expect(t).toBeDefined();
                    assertType(t);
                    expect(t.name).toBe("test");
                    assertType(t.name);
                    expect(t.getSchema()).toBeUndefined();
                    assertType(true);
                    assertType(true);
                });
                test("can overwrite a topic's type", () => {
                    const t = (0, topic_1.topic)("test").type().type();
                    expect(t).toBeDefined();
                    assertType(t);
                    expect(t.name).toBe("test");
                    assertType(t.name);
                    expect(t.getSchema()).toBeUndefined();
                    assertType(true);
                    assertType(true);
                });
                test("can add a schema to a topic", () => {
                    const t = (0, topic_1.topic)("test").schema(v.string());
                    expect(t).toBeDefined();
                    assertType(t);
                    expect(t.name).toBe("test");
                    assertType(t.name);
                    expect(t.getSchema()).toBeDefined();
                    assertType(true);
                    assertType(true);
                });
                test("schema must be a valid schema", () => {
                    const _fn = () => {
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema({ foo: "bar" });
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema(undefined);
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema();
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema(null);
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema(true);
                        // @ts-expect-error Invalid schema
                        (0, topic_1.topic)("test").schema(false);
                    };
                });
            });
            describe("channel", () => {
                test("can create a blank channel", () => {
                    const c = (0, channel_1.channel)("test");
                    expect(c).toBeDefined();
                    expect(c).toBeInstanceOf(Function);
                    assertType(c);
                });
                test("running a static channel definition gets a channel", () => {
                    const c = staticChannel();
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c.name).toBe("static");
                    expect(c.created).toBeDefined();
                    assertType(c.created);
                    expect(c.updated).toBeDefined();
                    assertType(c.updated);
                });
                test("running a dynamic channel definition gets a channel", () => {
                    const c = userChannel("123");
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c.name).toBe("user/123");
                    expect(c.created).toBeDefined();
                    assertType(c.created);
                    expect(c.updated).toBeDefined();
                    assertType(c.updated);
                });
                test("channel ID must be a string or a builder", () => {
                    const _fn = () => {
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)(1);
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)({ foo: "bar" });
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)(undefined);
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)();
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)(null);
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)(true);
                        // @ts-expect-error Channel ID must be a string
                        (0, channel_1.channel)(false);
                    };
                });
                test("can create a blank dynamic channel", () => {
                    const c = (0, channel_1.channel)((userId) => `user/${userId}`);
                    expect(c).toBeDefined();
                    expect(c).toBeInstanceOf(Function);
                    assertType(c);
                });
                test("can add a topic to a channel", () => {
                    const c = (0, channel_1.channel)("test").addTopic(createdTopic);
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c().created).toBeDefined();
                    assertType(c().created);
                });
                test("can add multiple topics to a channel", () => {
                    const c = (0, channel_1.channel)("test")
                        .addTopic(createdTopic)
                        .addTopic(updatedTopic);
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c().created).toBeDefined();
                    assertType(c().created);
                    expect(c().updated).toBeDefined();
                    assertType(c().updated);
                });
                test("can create a static channel using the types of another channel", () => {
                    const c = (0, channel_1.typeOnlyChannel)("static");
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c.topics.created).toBeDefined();
                    assertType(c.topics.created);
                    expect(c.topics.updated).toBeDefined();
                    assertType(c.topics.updated);
                    expect(c.created).toBeDefined();
                    assertType(c.created);
                    expect(c.updated).toBeDefined();
                    assertType(c.updated);
                });
                test("static channel ID must be correct if using the types of another channel", () => {
                    const _fn = () => {
                        // @ts-expect-error Incorrect channel
                        (0, channel_1.typeOnlyChannel)("staatic");
                    };
                });
                test("can create a dynamic channel using the types of another channel", () => {
                    const c = (0, channel_1.typeOnlyChannel)("user/123");
                    expect(c).toBeDefined();
                    assertType(c);
                    expect(c.created).toBeDefined();
                    assertType(c.created);
                    expect(c.updated).toBeDefined();
                    assertType(c.updated);
                });
                test("dynamic channel ID must be correct if using the types of another channel", () => {
                    const _fn = () => {
                        // @ts-expect-error Incorrect channel
                        (0, channel_1.typeOnlyChannel)("foo");
                    };
                });
            });
        });
        describe("strings only", () => {
            test("can subscribe with just strings", () => {
                const _fn = async () => {
                    const stream = await (0, subscribe_1.subscribe)({
                        channel: "test",
                        topics: ["foo", "bar"],
                    }, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    }
                };
            });
        });
        describe("type-only channel import", () => {
            test("errors if channel name is incorrect", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        // @ts-expect-error Incorrect channel
                        channel: (0, channel_1.typeOnlyChannel)("test"),
                        topics: ["created", "updated"],
                    });
                };
            });
            test("errors if topic names are incorrect with static channel", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        channel: (0, channel_1.typeOnlyChannel)("static"),
                        // @ts-expect-error Incorrect topic
                        topics: ["created", "updated", "test"],
                    });
                };
            });
            test("errors if topic names are incorrect with dynamic channel", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        channel: (0, channel_1.typeOnlyChannel)("user/123"),
                        // @ts-expect-error Incorrect topic
                        topics: ["created", "updated", "test"],
                    });
                };
            });
            test("can subscribe using types only of a static channel", () => {
                const _fn = async () => {
                    const stream = await (0, subscribe_1.subscribe)({
                        channel: (0, channel_1.typeOnlyChannel)("static"),
                        topics: ["created", "updated"],
                    }, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
            test("can subscribe using types only of a dynamic channel", () => {
                const _fn = async () => {
                    const stream = await (0, subscribe_1.subscribe)({
                        channel: (0, channel_1.typeOnlyChannel)("user/123"),
                        topics: ["created", "updated"],
                    }, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
        });
        describe("runtime channel import", () => {
            test("errors if static definition given", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        // @ts-expect-error Definition given
                        channel: staticChannel,
                        topics: ["created", "updated"],
                    });
                };
            });
            test("errors if dynamic definition given", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        // @ts-expect-error Definition given
                        channel: userChannel,
                        topics: ["created", "updated"],
                    });
                };
            });
            test("errors if topic names are incorrect with static channel", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        channel: staticChannel(),
                        // @ts-expect-error Incorrect topic
                        topics: ["created", "updated", "test"],
                    });
                };
            });
            test("errors if topic names are incorrect with dynamic channel", () => {
                const _fn = () => {
                    void (0, subscribe_1.subscribe)({
                        channel: userChannel("123"),
                        // @ts-expect-error Incorrect topic
                        topics: ["created", "updated", "test"],
                    });
                };
            });
            test("can subscribe with runtime import of a static channel", () => {
                const _fn = async () => {
                    const stream = await (0, subscribe_1.subscribe)({
                        channel: staticChannel(),
                        topics: ["created", "updated"],
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
            test("can subscribe with runtime import of a dynamic channel", () => {
                const _fn = async () => {
                    const stream = await (0, subscribe_1.subscribe)({
                        channel: userChannel("123"),
                        topics: ["created", "updated"],
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
        });
        describe("tokens", () => {
            test("can subscribe with a string-only token", () => {
                const _fn = async () => {
                    const token = await (0, subscribe_1.getSubscriptionToken)(app, {
                        channel: "test",
                        topics: ["foo", "bar"],
                    });
                    const stream = await (0, subscribe_1.subscribe)(token, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "foo") {
                            assertType(true);
                        }
                        else {
                            assertType(true);
                        }
                    }
                };
            });
            test("can subscribe with a type-only import static typed token", () => {
                const _fn = async () => {
                    const token = await (0, subscribe_1.getSubscriptionToken)(app, {
                        channel: (0, channel_1.typeOnlyChannel)("static"),
                        topics: ["created", "updated"],
                    });
                    const stream = await (0, subscribe_1.subscribe)(token, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
            test("can subscribe with a runtime import static typed token", () => {
                const _fn = async () => {
                    const token = await (0, subscribe_1.getSubscriptionToken)(app, {
                        channel: staticChannel(),
                        topics: ["created", "updated"],
                    });
                    const stream = await (0, subscribe_1.subscribe)(token, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
            test("can subscribe with a type-only import dynamic typed token", () => {
                const _fn = async () => {
                    const token = await (0, subscribe_1.getSubscriptionToken)(app, {
                        channel: (0, channel_1.typeOnlyChannel)("user/123"),
                        topics: ["created", "updated"],
                    });
                    const stream = await (0, subscribe_1.subscribe)(token, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
            test("can subscribe with a runtime import dynamic typed token", () => {
                const _fn = async () => {
                    const token = await (0, subscribe_1.getSubscriptionToken)(app, {
                        channel: userChannel("123"),
                        topics: ["created", "updated"],
                    });
                    const stream = await (0, subscribe_1.subscribe)(token, (message) => {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    });
                    for await (const message of stream) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                    const reader = stream.getReader();
                    const { value: message, done } = await reader.read();
                    if (!done) {
                        assertType(message.channel);
                        assertType(message.topic);
                        if (message.topic === "created") {
                            assertType(message.data);
                        }
                        else {
                            assertType(message.data);
                        }
                    }
                };
            });
        });
    });
});
//# sourceMappingURL=index.test.js.map